<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>design on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/design/</link>
    <description>Recent content in design on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 24 Aug 2021 11:40:29 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>30.包含min函数的栈</title>
      <link>https://www.pengjielee.cn/post/sword2/30.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link>
      <pubDate>Tue, 24 Aug 2021 11:40:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/30.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid>
      <description>题目 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.min(); --&amp;gt; 返回 -2. 提示：
各函数的调用总次数不超过 20000 次
注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * initialize your data structure here. */ var MinStack = function() { //主存储栈 this.mainStack = []; //辅助栈 this.secondaryStack = []; }; /** * @param {number} x * @return {void} */ MinStack.</description>
    </item>
    
    <item>
      <title>09.用两个栈实现队列</title>
      <link>https://www.pengjielee.cn/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 24 Aug 2021 11:37:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1： 输入： [&amp;#34;CQueue&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;deleteHead&amp;#34;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [&amp;#34;CQueue&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;deleteHead&amp;#34;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 &amp;lt;= values &amp;lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思考 队列特点：先进先出；
栈特点：先进后出；
JS实现 var CQueue = function() { //辅助栈1：插入栈 this.insertStack = []; //辅助栈2：弹出栈 this.popStack = []; return null; }; /** * @param {number} value * @return {void} */ CQueue.prototype.appendTail = function(value) { //插入时，把元素直接插入插入栈 this.insertStack.push(value); return null; }; /** * @return {number} */ CQueue.</description>
    </item>
    
    <item>
      <title>297.二叉树的序列化与反序列化</title>
      <link>https://www.pengjielee.cn/post/leetcode/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 19 May 2021 13:22:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
示例 1： 输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[1,2] 提示：
树中结点数在范围 [0, 10^4] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。
众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。
1、广度优先搜索可以按照层次的顺序从上到下遍历所有的节点；
2、深度优先搜索可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将深度优先搜索策略区分为：
先序遍历 中序遍历 后序遍历 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.</description>
    </item>
    
    <item>
      <title>380.常数时间插入、删除和获取随机元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/380.%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 19 May 2021 11:18:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/380.%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</guid>
      <description>题目 设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。
insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :
// 初始化一个空的集合。 RandomizedSet randomSet = new RandomizedSet(); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。 randomSet.insert(1); // 返回 false ，表示集合中不存在 2 。 randomSet.remove(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。 randomSet.insert(2); // getRandom 应随机返回 1 或 2 。 randomSet.getRandom(); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。 randomSet.remove(1); // 2 已在集合中，所以返回 false 。 randomSet.insert(2); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。 randomSet.</description>
    </item>
    
    <item>
      <title>384.打乱数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/384._%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 17 Mar 2021 17:29:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/384._%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 示例：
输入 [&amp;#34;Solution&amp;#34;, &amp;#34;shuffle&amp;#34;, &amp;#34;reset&amp;#34;, &amp;#34;shuffle&amp;#34;] [[[1, 2, 3]], [], [], []] 输出 [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] 解释 Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2] 提示：</description>
    </item>
    
    <item>
      <title>155.最小栈</title>
      <link>https://www.pengjielee.cn/post/leetcode/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</link>
      <pubDate>Mon, 15 Mar 2021 13:10:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</guid>
      <description>题目 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例:
输入： [&amp;#34;MinStack&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;getMin&amp;#34;,&amp;#34;pop&amp;#34;,&amp;#34;top&amp;#34;,&amp;#34;getMin&amp;#34;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.getMin(); --&amp;gt; 返回 -2. 提示：
pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-stack 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 栈特点：先进后出。
使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。
当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中； 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出； 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/min-stack/solution/zui-xiao-zhan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * initialize your data structure here.</description>
    </item>
    
  </channel>
</rss>
