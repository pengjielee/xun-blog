<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body><div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="page-title">sword2</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/sword2/21.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/">21.调整数组顺序使奇数位于偶数前面</a>
    </div><div class="post-meta">
    <div class="date">2021-08-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
示例： 输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示：
0 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1: 两次遍历
/** * @param {number[]} nums * @return {number[]} */ var exchange = function(nums) { const result = []; //第一次遍历，添加奇数 for(let num of nums){ if(num % 2 != 0){ result.push(num); } } //第二次遍历，添加偶数 for(let num of nums){ if(num % 2 === 0){ result.push(num); } } return result; }; 参考2：头尾双指针</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/22.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/">22.链表中倒数第k个节点</a>
    </div><div class="post-meta">
    <div class="date">2021-08-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 链表：1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回：4 -&gt; 5
链表长度：5，倒数第2，即正数第 3
JS实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var getKthFromEnd = function(head, k) { // 获取链表长度 const getLength = (head) =&gt; { let length = 0; let curr = head; while(curr) { length++; curr = curr.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/28.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/">28.对称的二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-08-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false 限制：
0 &lt;= 节点个数 &lt;= 1000
注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/">27.二叉树的镜像</a>
    </div><div class="post-meta">
    <div class="date">2021-08-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入： 4 / \ 2 7 / \ / \ 1 3 6 9 镜像输出： 4 / \ 7 2 / \ / \ 9 6 3 1 示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制：
0 &lt;= 节点个数 &lt;= 1000
注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var mirrorTree = function(root) { if(root === null){ return null; } const temp = root.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_20.%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/">20.表示数值的字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_19.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/">19.正则表达式匹配</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/18.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/">18.删除链表的节点</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意：此题对比原题有改动
示例 1: 输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明：
题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1:
/** * Definition for singly-linked list. * function ListNode(val) { * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_17.%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/">17.打印从1到最大的n位数</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_16.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/">16.数值的整数次方</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_15.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/">15.二进制中1的个数</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_14-ii.%E5%89%AA%E7%BB%B3%E5%AD%90ii/">14-ii.剪绳子ii</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]&hellip;k[m - 1] 。请问 k[0]k[1]&hellip;*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：
2 &lt;= n &lt;= 1000 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var cuttingRope = function(n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_14-i.%E5%89%AA%E7%BB%B3%E5%AD%90/">14-i.剪绳子</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]&hellip;k[m-1] 。请问 k[0]k[1]&hellip;*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：
2 &lt;= n &lt;= 58 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var cuttingRope = function(n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_13.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/">13.机器人的运动范围</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_12.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/">12.矩阵中的路径</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/">11.旋转数组的最小数字</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">07.重建二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">04.二维数组中的查找</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/search/" rel="tag">search</a>
        </div>
</div>

        <p class="summary">题目 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制：
0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000
注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var findNumberIn2DArray = function(matrix, target) { const rows = matrix.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">03.数组中重复的数字</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3
限制：
2 &lt;= n &lt;= 100000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var findRepeatNumber = function(nums) { const map = new Map(); for(let i = 0; i &lt; nums.length; i++){ if(map.has(nums[i])){ return nums[i] } map.set(nums[i],true); } }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_68-ii.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">68-ii.二叉树的最近公共祖先</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/67.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/">67.把字符串转换成整数</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−2^31, 2^31− 1]。如果数值超过这个范围，请返回 INT_MAX (2^31− 1) 或INT_MIN (−2^31) 。
示例1:
输入: &ldquo;42&rdquo; 输出: 42 示例2:
输入: &quot; -42&quot; 输出: -42 解释: 第一个非空白字符为 &lsquo;-&rsquo;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例3:
输入: &ldquo;4193 with words&rdquo; 输出: 4193 解释: 转换截止于数字 &lsquo;3&rsquo; ，因为它的下一个字符不为数字。 示例4:
输入: &ldquo;words and 987&rdquo; 输出: 0 解释: 第一个非空字符是 &lsquo;w&rsquo;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例5:
输入: &ldquo;-91283472332&rdquo; 输出: -2147483648 解释: 数字 &ldquo;-91283472332&rdquo; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_66.%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/">66.构建乘积数组</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_65.%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/">65.不用加减乘除做加法</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/bit-operation/" rel="tag">bit-operation</a>
        </div>
</div>

        <p class="summary">题目 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
示例: 输入: a = 1, b = 1 输出: 2 提示：
a, b 均可能是负数或 0 结果不会溢出 32 位整数
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} a * @param {number} b * @return {number} */ var add = function(a, b) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_62.%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/">62.圆圈中最后剩下的数字</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_61.%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/">61.扑克牌中的顺子</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_60.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/">60.n个骰子的点数</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
示例 1:
输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示2:
输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
限制：
1 &lt;= n &lt;= 11
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number[]} */ var dicesProbability = function(n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/57.%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/">57.和为s的两个数字</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2： 输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] 限制：
1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^6
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let left = 0, right = nums.length - 1; while(nums.length){ const num1 = nums[left], num2 = nums[right]; if(num1 + num2 === target){ return [num1, num2]; } else if(num1 + num2 &lt; target){ left++; } else { right--; } } return [-1,-1]; }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/64.%E6%B1%821&#43;2&#43;&#43;n/">64.求1&#43;2&#43;…&#43;n</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 求 1+2+&hellip;+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
示例 1：
输入: n = 3 输出: 6 示例 2：
输入: n = 9 输出: 45 限制：
1 &lt;= n &lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qiu-12n-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var sumNums = function(n) { let result = n; result &amp;&amp; (result += sumNums(n - 1)); return result; }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/48.%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">48.最长不含重复字符的子字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例 1: 输入: &#34;abcabcbb&#34; 输出: 3 解释: 因为无重复字符的最长子串是 &#34;abc&#34;，所以其长度为 3。 示例 2: 输入: &#34;bbbbb&#34; 输出: 1 解释: 因为无重复字符的最长子串是 &#34;b&#34;，所以其长度为 1。 示例 3: 输入: &#34;pwwkew&#34; 输出: 3 解释: 因为无重复字符的最长子串是 &#34;wke&#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&#34;pwke&#34; 是一个子序列，不是子串。 提示：
s.length &lt;= 40000 注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { const map = new Map(); let left = 0, max = 0; for(let i = 0; i &lt; s.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_46.%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">46</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/47.%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/">47.礼物的最大价值</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
示例 1: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示：
0 &lt; grid.length &lt;= 200 0 &lt; grid[0].length &lt;= 200
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 设 f(i,j) 为从棋盘左上角走至单元格 (i,j) 的礼物最大累计价值，易得到以下递推关系：f(i,j) 等于 f(i,j-1) 和 f(i-1,j) 中的较大值加上当前单元格礼物价值 grid(i,j) 。
f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j) 作者：jyd 链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考1：滚动数组
/** * @param {number[][]} grid * @return {number} */ var maxValue = function (grid) { const rows = grid.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_42.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/">42.连续子数组的最大和</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
        </div>
</div>

        <p class="summary">题目 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。
示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示：
1 &lt;= arr.length &lt;= 10^5 -100 &lt;= arr[i] &lt;= 100 注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var maxSubArray = function(nums) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_63.%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/">63.股票的最大利润</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制：
0 &lt;= 数组长度 &lt;= 10^5
注意：本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_10-ii.%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/">10-II.青蛙跳台阶问题</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：2 示例 2：
输入：n = 7 输出：21 示例 3：
输入：n = 0 输出：1 提示：
0 &lt;= n &lt;= 100 注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var numWays = function(n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_10-i.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">10-I.斐波那契数列</a>
    </div><div class="post-meta">
    <div class="date">2021-08-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1： 输入：n = 2 输出：1 示例 2： 输入：n = 5 输出：5 提示：
0 &lt;= n &lt;= 100
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var fib = function(n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_58.ii.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">58.II.左旋转字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/math/" rel="tag">math</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">05.替换空格</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。
示例 1：
输入：s = &ldquo;We are happy.&rdquo; 输出：&ldquo;We%20are%20happy.&rdquo; 限制：
0 &lt;= s 的长度 &lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {string} */ var replaceSpace = function(s) { let result = &#39;&#39;; for(let i = 0; i &lt; s.length; i++){ if(s[i] === &#39; &#39;){ result += &#39;%20&#39;; }else { result += s[i]; } } return result; }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_35.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/">35.复杂链表的复制</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：
输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]]
示例 3：
输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]]
示例 4： 输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。
提示：
-10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。
注意：本题与主站 138 题相同：https://leetcode-cn.com/problems/copy-list-with-random-pointer/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * // Definition for a Node. * function Node(val, next, random) { * this.val = val; * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/24.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">24.反转链表</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/recursion/" rel="tag">recursion</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制：
0 &lt;= 节点个数 &lt;= 5000
注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { let prev = null; let curr = head; while(curr) { //获取当前节点的next const next = curr.next; //当前节点的next指向prev curr.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">06.从尾到头打印链表</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
                <a class="tags_link" href="/tags/recursion/" rel="tag">recursion</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制：
0 &lt;= 链表长度 &lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、reverse()方法，反转数组
/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {number[]} */ var reversePrint = function(head) { const result = []; let current = head; while(current){ result.push(current.val); current = current.next; } return result.reverse(); }; 2、借助栈</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/30.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/">30.包含min函数的栈</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
                <a class="tags_link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <p class="summary">题目 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --&gt; 返回 -3. minStack.pop(); minStack.top(); --&gt; 返回 0. minStack.min(); --&gt; 返回 -2. 提示：
各函数的调用总次数不超过 20000 次
注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * initialize your data structure here. */ var MinStack = function() { //主存储栈 this.mainStack = []; //辅助栈 this.secondaryStack = []; }; /** * @param {number} x * @return {void} */ MinStack.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">09.用两个栈实现队列</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
                <a class="tags_link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <p class="summary">题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1： 输入： [&#34;CQueue&#34;,&#34;appendTail&#34;,&#34;deleteHead&#34;,&#34;deleteHead&#34;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [&#34;CQueue&#34;,&#34;deleteHead&#34;,&#34;appendTail&#34;,&#34;appendTail&#34;,&#34;deleteHead&#34;,&#34;deleteHead&#34;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思考 队列特点：先进先出；
栈特点：先进后出；
JS实现 var CQueue = function() { //辅助栈1：插入栈 this.insertStack = []; //辅助栈2：弹出栈 this.popStack = []; return null; }; /** * @param {number} value * @return {void} */ CQueue.prototype.appendTail = function(value) { //插入时，把元素直接插入插入栈 this.insertStack.push(value); return null; }; /** * @return {number} */ CQueue.</p>
    
</div>

        </section>
        
    <div class="pagination">
            <a class="pagination__item pagination__item--prev btn" href="/tags/sword2/">Prev</a>
        <span class="pagination__item pagination__item--current">2/5</span>
            <a class="pagination__item pagination__item--next btn" href="/tags/sword2/page/3/">Next</a>
    </div>

    </div>

        </div></body>
</html>
