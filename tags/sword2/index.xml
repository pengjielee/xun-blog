<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sword2 on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/sword2/</link>
    <description>Recent content in sword2 on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 27 Aug 2021 13:57:16 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/sword2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>21.调整数组顺序使奇数位于偶数前面</title>
      <link>https://www.pengjielee.cn/post/sword2/21.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link>
      <pubDate>Fri, 27 Aug 2021 13:57:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/21.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid>
      <description>题目 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
示例： 输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示：
0 &amp;lt;= nums.length &amp;lt;= 50000 1 &amp;lt;= nums[i] &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1: 两次遍历
/** * @param {number[]} nums * @return {number[]} */ var exchange = function(nums) { const result = []; //第一次遍历，添加奇数 for(let num of nums){ if(num % 2 != 0){ result.push(num); } } //第二次遍历，添加偶数 for(let num of nums){ if(num % 2 === 0){ result.push(num); } } return result; }; 参考2：头尾双指针</description>
    </item>
    
    <item>
      <title>22.链表中倒数第k个节点</title>
      <link>https://www.pengjielee.cn/post/sword2/22.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 27 Aug 2021 13:43:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/22.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>题目 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
示例： 给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2. 返回链表 4-&amp;gt;5. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2. 返回：4 -&amp;gt; 5
链表长度：5，倒数第2，即正数第 3
JS实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var getKthFromEnd = function(head, k) { // 获取链表长度 const getLength = (head) =&amp;gt; { let length = 0; let curr = head; while(curr) { length++; curr = curr.</description>
    </item>
    
    <item>
      <title>28.对称的二叉树</title>
      <link>https://www.pengjielee.cn/post/sword2/28.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 27 Aug 2021 13:17:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/28.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.</description>
    </item>
    
    <item>
      <title>27.二叉树的镜像</title>
      <link>https://www.pengjielee.cn/post/sword2/27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Fri, 27 Aug 2021 13:17:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>题目 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入： 4 / \ 2 7 / \ / \ 1 3 6 9 镜像输出： 4 / \ 7 2 / \ / \ 9 6 3 1 示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var mirrorTree = function(root) { if(root === null){ return null; } const temp = root.</description>
    </item>
    
    <item>
      <title>18.删除链表的节点</title>
      <link>https://www.pengjielee.cn/post/sword2/18.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 26 Aug 2021 17:14:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/18.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>题目 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意：此题对比原题有改动
示例 1: 输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9. 示例 2: 输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9. 说明：
题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1:
/** * Definition for singly-linked list. * function ListNode(val) { * this.</description>
    </item>
    
    <item>
      <title>04.二维数组中的查找</title>
      <link>https://www.pengjielee.cn/post/sword2/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Wed, 25 Aug 2021 15:06:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>题目 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制：
0 &amp;lt;= n &amp;lt;= 1000 0 &amp;lt;= m &amp;lt;= 1000
注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var findNumberIn2DArray = function(matrix, target) { const rows = matrix.</description>
    </item>
    
    <item>
      <title>03.数组中重复的数字</title>
      <link>https://www.pengjielee.cn/post/sword2/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 25 Aug 2021 15:05:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3
限制：
2 &amp;lt;= n &amp;lt;= 100000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var findRepeatNumber = function(nums) { const map = new Map(); for(let i = 0; i &amp;lt; nums.length; i++){ if(map.has(nums[i])){ return nums[i] } map.set(nums[i],true); } }; </description>
    </item>
    
    <item>
      <title>67.把字符串转换成整数</title>
      <link>https://www.pengjielee.cn/post/sword2/67.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 25 Aug 2021 15:04:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/67.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</guid>
      <description>题目 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−2^31, 2^31− 1]。如果数值超过这个范围，请返回 INT_MAX (2^31− 1) 或INT_MIN (−2^31) 。
示例1:
输入: &amp;ldquo;42&amp;rdquo; 输出: 42 示例2:
输入: &amp;quot; -42&amp;quot; 输出: -42 解释: 第一个非空白字符为 &amp;lsquo;-&amp;rsquo;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例3:
输入: &amp;ldquo;4193 with words&amp;rdquo; 输出: 4193 解释: 转换截止于数字 &amp;lsquo;3&amp;rsquo; ，因为它的下一个字符不为数字。 示例4:
输入: &amp;ldquo;words and 987&amp;rdquo; 输出: 0 解释: 第一个非空字符是 &amp;lsquo;w&amp;rsquo;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例5:
输入: &amp;ldquo;-91283472332&amp;rdquo; 输出: -2147483648 解释: 数字 &amp;ldquo;-91283472332&amp;rdquo; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</description>
    </item>
    
    <item>
      <title>57.和为s的两个数字</title>
      <link>https://www.pengjielee.cn/post/sword2/57.%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 25 Aug 2021 13:44:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/57.%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>题目 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2： 输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] 限制：
1 &amp;lt;= nums.length &amp;lt;= 10^5 1 &amp;lt;= nums[i] &amp;lt;= 10^6
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let left = 0, right = nums.length - 1; while(nums.length){ const num1 = nums[left], num2 = nums[right]; if(num1 + num2 === target){ return [num1, num2]; } else if(num1 + num2 &amp;lt; target){ left++; } else { right--; } } return [-1,-1]; }; </description>
    </item>
    
    <item>
      <title>64.求1&#43;2&#43;…&#43;n</title>
      <link>https://www.pengjielee.cn/post/sword2/64.%E6%B1%821&#43;2&#43;&#43;n/</link>
      <pubDate>Wed, 25 Aug 2021 13:36:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/64.%E6%B1%821&#43;2&#43;&#43;n/</guid>
      <description>题目 求 1+2+&amp;hellip;+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
示例 1：
输入: n = 3 输出: 6 示例 2：
输入: n = 9 输出: 45 限制：
1 &amp;lt;= n &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qiu-12n-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var sumNums = function(n) { let result = n; result &amp;amp;&amp;amp; (result += sumNums(n - 1)); return result; }; </description>
    </item>
    
    <item>
      <title>48.最长不含重复字符的子字符串</title>
      <link>https://www.pengjielee.cn/post/sword2/48.%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 25 Aug 2021 09:05:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/48.%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例 1: 输入: &amp;#34;abcabcbb&amp;#34; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。 示例 2: 输入: &amp;#34;bbbbb&amp;#34; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。 示例 3: 输入: &amp;#34;pwwkew&amp;#34; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。 提示：
s.length &amp;lt;= 40000 注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { const map = new Map(); let left = 0, max = 0; for(let i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>47.礼物的最大价值</title>
      <link>https://www.pengjielee.cn/post/sword2/47.%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</link>
      <pubDate>Wed, 25 Aug 2021 09:04:11 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/47.%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</guid>
      <description>题目 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
示例 1: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示：
0 &amp;lt; grid.length &amp;lt;= 200 0 &amp;lt; grid[0].length &amp;lt;= 200
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 设 f(i,j) 为从棋盘左上角走至单元格 (i,j) 的礼物最大累计价值，易得到以下递推关系：f(i,j) 等于 f(i,j-1) 和 f(i-1,j) 中的较大值加上当前单元格礼物价值 grid(i,j) 。
f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j) 作者：jyd 链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考1：滚动数组
/** * @param {number[][]} grid * @return {number} */ var maxValue = function (grid) { const rows = grid.</description>
    </item>
    
    <item>
      <title>05.替换空格</title>
      <link>https://www.pengjielee.cn/post/sword2/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link>
      <pubDate>Tue, 24 Aug 2021 15:03:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid>
      <description>题目 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
示例 1：
输入：s = &amp;ldquo;We are happy.&amp;rdquo; 输出：&amp;ldquo;We%20are%20happy.&amp;rdquo; 限制：
0 &amp;lt;= s 的长度 &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {string} */ var replaceSpace = function(s) { let result = &amp;#39;&amp;#39;; for(let i = 0; i &amp;lt; s.length; i++){ if(s[i] === &amp;#39; &amp;#39;){ result += &amp;#39;%20&amp;#39;; }else { result += s[i]; } } return result; }; </description>
    </item>
    
    <item>
      <title>24.反转链表</title>
      <link>https://www.pengjielee.cn/post/sword2/24.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 24 Aug 2021 13:34:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/24.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
示例: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 5000
注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { let prev = null; let curr = head; while(curr) { //获取当前节点的next const next = curr.next; //当前节点的next指向prev curr.</description>
    </item>
    
    <item>
      <title>06.从尾到头打印链表</title>
      <link>https://www.pengjielee.cn/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 24 Aug 2021 13:34:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制：
0 &amp;lt;= 链表长度 &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、reverse()方法，反转数组
/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {number[]} */ var reversePrint = function(head) { const result = []; let current = head; while(current){ result.push(current.val); current = current.next; } return result.reverse(); }; 2、借助栈</description>
    </item>
    
    <item>
      <title>30.包含min函数的栈</title>
      <link>https://www.pengjielee.cn/post/sword2/30.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link>
      <pubDate>Tue, 24 Aug 2021 11:40:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/30.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid>
      <description>题目 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.min(); --&amp;gt; 返回 -2. 提示：
各函数的调用总次数不超过 20000 次
注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * initialize your data structure here. */ var MinStack = function() { //主存储栈 this.mainStack = []; //辅助栈 this.secondaryStack = []; }; /** * @param {number} x * @return {void} */ MinStack.</description>
    </item>
    
    <item>
      <title>09.用两个栈实现队列</title>
      <link>https://www.pengjielee.cn/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 24 Aug 2021 11:37:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1： 输入： [&amp;#34;CQueue&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;deleteHead&amp;#34;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [&amp;#34;CQueue&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;deleteHead&amp;#34;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 &amp;lt;= values &amp;lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思考 队列特点：先进先出；
栈特点：先进后出；
JS实现 var CQueue = function() { //辅助栈1：插入栈 this.insertStack = []; //辅助栈2：弹出栈 this.popStack = []; return null; }; /** * @param {number} value * @return {void} */ CQueue.prototype.appendTail = function(value) { //插入时，把元素直接插入插入栈 this.insertStack.push(value); return null; }; /** * @return {number} */ CQueue.</description>
    </item>
    
  </channel>
</rss>
