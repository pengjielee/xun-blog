<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>array on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/array/</link>
    <description>Recent content in array on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 25 Aug 2021 15:06:04 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/array/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>04.二维数组中的查找</title>
      <link>https://www.pengjielee.cn/post/sword2/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Wed, 25 Aug 2021 15:06:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>题目 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制：
0 &amp;lt;= n &amp;lt;= 1000 0 &amp;lt;= m &amp;lt;= 1000
注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var findNumberIn2DArray = function(matrix, target) { const rows = matrix.</description>
    </item>
    
    <item>
      <title>03.数组中重复的数字</title>
      <link>https://www.pengjielee.cn/post/sword2/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 25 Aug 2021 15:05:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3
限制：
2 &amp;lt;= n &amp;lt;= 100000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var findRepeatNumber = function(nums) { const map = new Map(); for(let i = 0; i &amp;lt; nums.length; i++){ if(map.has(nums[i])){ return nums[i] } map.set(nums[i],true); } }; </description>
    </item>
    
    <item>
      <title>189.旋转数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 26 May 2021 11:00:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 提示：
1 &amp;lt;= nums.length &amp;lt;= 2 * 104 -2^31 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1 0 &amp;lt;= k &amp;lt;= 10^5 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>350.两个数组的交集II</title>
      <link>https://www.pengjielee.cn/post/leetcode/350._%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86ii/</link>
      <pubDate>Wed, 26 May 2021 10:34:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/350._%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86ii/</guid>
      <description>题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明：
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 1、哈希表
由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。
首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersect = function (nums1, nums2) { const len1 = nums1.length; const len2 = nums2.</description>
    </item>
    
    <item>
      <title>217.存在重复元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 26 May 2021 10:19:20 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid>
      <description>题目 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {boolean} */ var containsDuplicate = function (nums) { const map = new Map(); for (let i = 0; i &amp;lt; nums.length; i++) { //如果数不存在，设置默认出现次数为0 if (!map.has(nums[i])) { map.set(nums[i], 0); } //如果数已存在，出现次数+1 const number = map.</description>
    </item>
    
    <item>
      <title>122.买卖股票的最佳时机II</title>
      <link>https://www.pengjielee.cn/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</link>
      <pubDate>Mon, 26 Apr 2021 14:42:08 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</guid>
      <description>题目 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1: 输入: prices = [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入， 在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入， 在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: prices = [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入， 在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: prices = [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：</description>
    </item>
    
    <item>
      <title>922.按奇偶排序数组II</title>
      <link>https://www.pengjielee.cn/post/leetcode/922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</link>
      <pubDate>Sat, 17 Apr 2021 16:32:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</guid>
      <description>题目 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
你可以返回任何满足上述条件的数组作为答案。
示例：
输入：[4,2,5,7] 输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示：
2 &amp;lt;= A.length &amp;lt;= 20000 A.length % 2 == 0 0 &amp;lt;= A[i] &amp;lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[]} */ var sortArrayByParityII = function (nums) { const result = new Array(nums.length); let i = 0; // 第1次遍历，在偶数位上设置偶数 for (const num of nums) { if (num % 2 === 0) { result[i] = num; i += 2; } } i = 1; // 第2次遍历，在奇数位上设置奇数 for (const num of nums) { if (num % 2 === 1) { result[i] = num; i += 2; } } return result; }; </description>
    </item>
    
    <item>
      <title>905.按奇偶排序数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/905.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 17 Apr 2021 16:26:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/905.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。
你可以返回满足此条件的任何数组作为答案。
示例：
输入：[3,1,2,4] 输出：[2,4,3,1] 输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示：
1 &amp;lt;= A.length &amp;lt;= 5000 0 &amp;lt;= A[i] &amp;lt;= 5000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-array-by-parity 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} A * @return {number[]} */ var sortArrayByParity = function(A) { const result = []; // 第1次遍历，添加所有偶数 for(let item of A) { if(item % 2 === 0){ result.push(item); } } // 第2次遍历，添加所有奇数 for(let item of A) { if(item % 2 === 1){ result.</description>
    </item>
    
    <item>
      <title>349.两个数组的交集</title>
      <link>https://www.pengjielee.cn/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Sat, 17 Apr 2021 16:14:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 说明：
输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、排序 + 双指针
/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function (nums1, nums2) { const result = []; //分别对两个数组排序（从小到大） nums1.sort((a, b) =&amp;gt; a - b); nums2.sort((a, b) =&amp;gt; a - b); const len1 = nums1.</description>
    </item>
    
    <item>
      <title>015.三数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 15 Apr 2021 14:14:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2： 输入：nums = [] 输出：[] 示例 3： 输入：nums = [0] 输出：[] 提示：
0 &amp;lt;= nums.length &amp;lt;= 3000 -10^5 &amp;lt;= nums[i] &amp;lt;= 10^5
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function (nums) { let result = []; // 传入数组为null直接返回result if (nums === null) { return result; } const len = nums.</description>
    </item>
    
    <item>
      <title>088.合并两个有序数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/088.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 19 Mar 2021 17:06:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/088.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 提示：
nums1.length == m + n nums2.length == n 0 &amp;lt;= m, n &amp;lt;= 200 1 &amp;lt;= m + n &amp;lt;= 200 -10^9 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>384.打乱数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/384._%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 17 Mar 2021 17:29:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/384._%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 示例：
输入 [&amp;#34;Solution&amp;#34;, &amp;#34;shuffle&amp;#34;, &amp;#34;reset&amp;#34;, &amp;#34;shuffle&amp;#34;] [[[1, 2, 3]], [], [], []] 输出 [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] 解释 Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2] 提示：</description>
    </item>
    
    <item>
      <title>136.只出现一次的数字</title>
      <link>https://www.pengjielee.cn/post/leetcode/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 17 Mar 2021 16:44:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
位运算 异或运算：
任何数和 0 做异或运算，结果仍是原来的数； 任何数和其自身做异或运算，结果是0； 异或运算满足交换律和结合律； 位运算 XOR：当对一对数位进行位运算 XOR 时，如果数位是不同的则返回 1。
示例：
console.log(0 ^ 0); //0，规则1，规则2 console.log(0 ^ 1); //1，规则1 console.log(1 ^ 0); //1，规则1 console.log(1 ^ 1); //0，规则2 console.log(0 ^ 1); //1，规则1 console.log(0 ^ 10); //10，规则1 console.log(1 ^ 1); //0，规则2 console.log(2 ^ 2); //0，规则2 console.log(1 ^ 1 ^ 2); //2，规则1，2，3 console.</description>
    </item>
    
    <item>
      <title>026.删除有序数组中的重复项</title>
      <link>https://www.pengjielee.cn/post/leetcode/026.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Tue, 16 Mar 2021 15:29:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/026.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>题目 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); } 示例 1：
输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]</description>
    </item>
    
    <item>
      <title>001.两数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Tue, 16 Mar 2021 15:28:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
你可以按任意顺序返回答案。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示：
2 &amp;lt;= nums.length &amp;lt;= 10^3 -10^9 &amp;lt;= nums[i] &amp;lt;= 10^9 -10^9 &amp;lt;= target &amp;lt;= 10^9 只会存在一个有效答案 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { // 创建一个hashmap const map = new Map(); // 遍历数组 for (let i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>50.数组中重复的数字</title>
      <link>https://www.pengjielee.cn/post/sword/array_50.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 12 Mar 2021 15:17:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/array_50.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
详解 排序：将输入数组排序，再判断相邻位置是否存在相同数字，如果存在，对 duplication 赋值返回，否则继续比较
JS实现 function duplicate(numbers, duplication) { // write code here if (numbers.length &amp;lt;= 0) { return false; } numbers = numbers.sort(); for (let i = 0; i &amp;lt; numbers.length - 1; i++) { if (numbers[i] === numbers[i + 1]) { duplication[0] = numbers[i]; return true; } } return false; } Go实现 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sort&amp;#34; ) func main() { nums := []int{3, 1, 0, 2, 5, 3, 5} fmt.</description>
    </item>
    
    <item>
      <title>06.旋转数组的最小数字</title>
      <link>https://www.pengjielee.cn/post/sword/array_06.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 10 Mar 2021 14:18:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/array_06.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid>
      <description>题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组 {3,4,5,1,2} 为 {1,2,3,4,5} 的一个旋转，该数组的最小值为1。
原来的：{1,2,3,4,5}
旋转后：{3,4,5,1,2}
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
详解 旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的值 都大于 后面子数组中的元素。
注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。
思路：
我们用两个指针left，right分别指向数组的第一个元素和最后一个元素。 按照题目的旋转的规则，第一个元素应该是大于最后一个元素的没. 重复的元素）。 但是如果不是旋转，第一个元素肯定小于最后一个元素。
找到数组的中间元素。 中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。 移动之后，第一个指针仍然位于前面的递增数组中。 中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。 移动之后，第二个指针仍然位于后面的递增数组中。 这样可以缩小寻找的范围。 按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。 最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。 也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。
到目前为止以上思路很耗的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。
因此这一道题目比上一道题目多了些特殊情况：
我们看一组例子：｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。
这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。
第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。
因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。 也就无法移动指针来缩小查找的范围。
牛客网
https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba?f=discussion
JS实现 function minNumberInRotateArray(rotateArray) { // write code here const len = rotateArray.length; if (len === 0) { return 0; } let low = 0; let high = len - 1; while (low &amp;lt; high) { const mid = low + Math.</description>
    </item>
    
    <item>
      <title>01.二维数组中的查找</title>
      <link>https://www.pengjielee.cn/post/sword/array_01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Wed, 10 Mar 2021 10:31:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/array_01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>题目 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] 详解 暴力法 挨个遍历数组，如果找到就返回 true
时间复杂度：O(n^2) 空间复杂度：O(1)
从左下找 利用该二维数组的性质：
每一行都按照从左到右递增的顺序排序， 每一列都按照从上到下递增的顺序排序 换个说法，即对于左下角的值 m，m 是该行最小的数，是该列最大的数
每次将 m 和目标值 target 比较：
当 m &amp;lt; target，由于 m 已经是该行最大的元素，想要更大只有从列考虑，取值右移一位 当 m &amp;gt; target，由于 m 已经是该列最小的元素，想要更小只有从行考虑，取值上移一位 当 m = target，找到该值，返回 true 用某行最小或某列最大与 target 比较，每次可剔除一整行或一整列。
时间复杂度：O(行高 + 列宽) 空间复杂度：O(1)
从右上找 和从左下找道理一样，都是因为每次判断都能剔除一整行或一整列
时间复杂度：O(行高 + 列宽) 空间复杂度：O(1)
链接：https://www.nowcoder.com/questionTerminal/abc3fe2ce8e146608e868a70efebf62e?answerType=1&amp;amp;f=discussion 来源：牛客网
JS实现 //暴力法 function Find(target, array) { // write code here for (let i = 0; i &amp;lt; array.</description>
    </item>
    
  </channel>
</rss>
