<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/monokai-sublime.min.css" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
        <div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="title">algorithm</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/algorithm/23.%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/">洗牌算法</a>
    </div><div class="post-meta">
    <div class="date">2021-05-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">Fisher–Yates shuffle 核心思想是从1到n之间随机取出一个数和最后一个数(n)交换，然后从1到n-1之间随机取出一个数和倒数第二个数(n-1)交换&hellip;
步骤：
写下从 1 到 N 的数字 取一个从 1 到剩下的数字（包括这个数字）的随机数 k 从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位 重复第 2 步，直到所有的数字都被取出 第 3 步写出的这个序列，现在就是原始数字的随机排列 经典实现 步骤：
给定一组待混排的有限序列P 新初始化一个空的序列Q 从P中随机选取一个元素 将该元素放到序列Q的最后面，并从序列P中移除该元 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/algorithm/22.%E5%A0%86%E6%8E%92%E5%BA%8F/">堆排序</a>
    </div><div class="post-meta">
    <div class="date">2021-04-28</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">堆排序 1、参考代码
class HeapSort { //建堆 buildHeap(array) { //下标为0的位置保留 const arr = [0].concat(array); for (let i = arr.length; i &gt; 0; i--) { this._heapify(arr, arr.length, i); } return arr; } // 排序 sort(array) { const arr = this.buildHeap(array); // 先建堆 let len = arr.length - 1; while (len &gt; 1) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/algorithm/21.%E5%A0%86/">堆</a>
    </div><div class="post-meta">
    <div class="date">2021-04-28</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">理解堆 堆是一个完全二叉树； 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值； 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。
几个例子：
堆1：大顶堆 10 / \ 9 8 /\ /\ 6 5 7 4 / 3 堆2：大顶堆 10 / \ 8 9 /\ /\ 7 3 5 6 / 4 堆3：小顶堆 3 / \ 4 6 /\ /\ 5 8 9 10 / 7 堆的存储及操作 1、堆的存储
完全二叉树适合用数组来存储。
7 / \ 5 6 / \ / 4 2 1 用数组来存储： arr = [, 7, 5, 6, 4, 2, 1] idx = 0 1 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/algorithm/20.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">实现1 var division = (list, left, right) =&gt; { // 以最左边的数(left)为基准 var base = list[left]; while (left &lt; right) { // 从序列右端开始，向左遍历，直到找到小于base的数 while (left &lt; right &amp;&amp; list[right] &gt;= base) { right--; } // 找到了比base小的元素，将这个元素放到最左边的位置 list[left] = list[right]; // 从序列左端开始，向右遍历，直到找到大于base …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/algorithm/19.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/">二叉树题目合集</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">题目 求二叉树的最大深度； 求二叉树的最小深度； 求二叉树中节点的个数； 求二叉树中叶子节点的个数； 求二叉树中第k层节点的个数； 判断二叉树是否是平衡二叉树； 判断二叉树是否是完全二叉树； 判断两个二叉树是否完全相同； 判断两个二叉树是否互为镜像； 翻转二叉树/镜像二叉树； 求两个二叉树的最低公共祖先节点； 二叉树的前序遍历； 二叉树的中序遍历； 二叉树的后序遍历； 构造二叉树（前序遍历和中序遍历/后序遍历和中序遍历）； 二叉树中插入/删除节点； 输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径； 二叉树的搜索区间； 二叉树的层次遍历； 二叉树内两个节点的最长距离；  …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/algorithm/18.%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/">链表题目合集</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">题目 翻转链表； 判断链表是否有环； 链表排序； 链表相加求和； 获取链表倒数第n个节点； 删除链表倒数第n个节点； 删除链表中重复元素； 旋转链表； 重排链表； 链表划分； 翻转链表的n到m之间的节点； 合并K个排序过的链表； More 一篇文章搞定面试中的链表题目(java实现)
https://www.jianshu.com/p/a64d1ef95980</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/algorithm/17.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/">排序算法合集</a>
    </div><div class="post-meta">
    <div class="date">2021-04-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">算法度量 1、算法内存使用
原地排序（Sorted in place）算法，特指空间复杂度是 O(1) 的排序算法。
2、算法的稳定性
经过某种排序算法排序之后：
如果两个元素的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法； 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。 冒泡排序 var bubbleSort = (arr) =&gt; { const n = arr.length; if (n &lt;= 1) { return; } for (let i = 0; i &lt; n; i++) { for (let j = 0; j &lt; n - i - …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/algorithm/16.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">计数排序</a>
    </div><div class="post-meta">
    <div class="date">2021-04-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">桶排序 （Bucket sort） 核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。
比如对 9,10,20,45,40,27,32,35,31,50,53,63进行桶排序：
桶1（0-9）: 9 桶2（10-19）: 19 桶3（20-29）: 20,27 桶4（30-39）: 32,35,31 桶5（40-49）: 45,40, 桶6（50-59）: 50,53 桶6（60-69）: 63 桶排序的时间复杂度为什么是 O(n) 呢?
如果要排序的数据有 n 个，我们把它们均匀地划分到 m  …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/algorithm/15.%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/">排列组合</a>
    </div><div class="post-meta">
    <div class="date">2021-04-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">排列 一般地，从n个不同元素中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列(permutation)。特别地，当m=n时，这个排列被称作全排列(all permutation)。
var permute = (nums, k) =&gt; { let result = []; /* * 生成排列 * index表示向当前排列添加第index个元素。 * p表示当前的排列，其中拥有index-1个元素。 */ var generatePermutation = (nums, index, p) =&gt; { if (index === k) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/determine-symmetric-binary-tree/">判断对称二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-11</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">二叉树【 每个节点最多有两个子节点。
10 / \ 9 20 / \ 15 35 二叉树的特点：
每个节点最多有两个子树，节点的度最大为2； 左子树和右子树是有顺序的，次序不能颠倒； 即使某节点只有一个子树，也要区分左右子树； 对称二叉树 如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
10 / \ 5 5 / \ / \ 1 4 4 1 实现思路:
判断根节点相同； 左子树的右节点和右子树的左节点相同； 右子树的左节点和左子树的右节点相同； 模拟一个对称二叉树和非对称二叉树：
//对称二叉树 const symmetricalTree = { val: 8, left: { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/binary-search-tree/">二叉查找树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">二叉查找树 二叉查找树(binary search tree)：当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大。
class TreeNode { constructor(data) { this.data = data; this.left = null; this.right = null; } } class BinarySearchTree { constructor() { this.root = null; } insert(data) { var newNode = new TreeNode(data); if (this.root === null) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/binary-tree/">二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-09</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">树的概念 节点分类：
根节点 子节点 叶子节点 兄弟节点 其他：
树的深度：从根节点到最底层节点的层数。 树的深度：树中节点的最大层次称为树的深度（或树的高度）。 节点的度：节点拥有的子树数称为节点的度。 叶子节点：度为0的节点称为叶节点（或终端节点）。 分支节点：度不为0的节点称为分支节点（或非终端节点）。 树的度：树内各节点的度的最大值。 节点层次：从根开始，根为第一层，根的孩子为第二层。 二叉树 二叉树：每个节点最多有两个子节点。
10 / \ 9 20 / \ 15 35 二叉树的操作：
1、创建二叉树； 2、遍历二叉树；
先序遍历：先访问根节点，然后访问左节点，最后访问右节点（ …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/binary-tree-traversal/">二叉树遍历</a>
    </div><div class="post-meta">
    <div class="date">2021-03-09</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">树结构多种多样，我们最常用的还是二叉树。
特殊二叉树 1、满二叉树；
2、完全二叉树；
二叉树的存储 1、基于指针或者引用的二叉链式存储法；
2、基于数组的顺序存储法；
我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。
如果节点x存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i / 2 的位置存储的就是它的父节点。
通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/binary-search-deformation/">二分查找变形</a>
    </div><div class="post-meta">
    <div class="date">2021-03-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">查找第一个等于给定值的元素（有重复元素） const binarySearch = (arr, value) =&gt; { let low = 0, high = arr.length - 1; while (low &lt;= high) { const mid = parseInt(low + (high - low) / 2); if (arr[mid] === value) { if (mid === 0 || arr[mid - 1] != value) { return mid; } else { high = mid - 1; } } else if (arr[mid] …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/binary-search/">二分查找</a>
    </div><div class="post-meta">
    <div class="date">2021-03-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">循环实现（无重复元素） const binarySearch = (arr, value) =&gt; { let low = 0, high = arr.length - 1; while (low &lt;= high) { const mid = parseInt((low + high) / 2, 10); if (arr[mid] === value) { return mid; } else if (arr[mid] &lt; value) { low = mid + 1; } else { high = mid - 1; } } return -1; }; 递归实现（无重复元素） …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/print-the-serpentine-matrix/">打印蛇形矩阵</a>
    </div><div class="post-meta">
    <div class="date">2021-03-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">题目 对于给定的n，打印出如下型式的蛇形矩阵。例如
n=3时，输出： 1 2 3 8 9 4 7 6 5 n=4时，输出： 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7 参考 var snake = (n) =&gt; { let row = n, col = row; var q = Math.ceil(n / 2); // 旋转几圈 // 创建存放的数组 var result = new Array(row); for (var i = 0; i &lt; row; i++) { result[i] = new Array(col); } var n = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/merges-two-ordered-linked-lists/">合并两个有序链表</a>
    </div><div class="post-meta">
    <div class="date">2021-03-05</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">数据结构 // 节点类 class Node { constructor(value) { this.value = value; // 存储值 this.next = null; // 存储下一个节点的引用 } } //链表类 class LinkedList { constructor() { this.length = 0; //链表的长度 this.head = null; //链表的头结点 } //链表的插入方法 append(value) { var node = new Node(value); //创建节点 if (!this.head) { this.head = node; …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/merges-two-ordered-arrays/">合并两个有序数组</a>
    </div><div class="post-meta">
    <div class="date">2021-03-05</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">将两个有序数组合并成一个有序数组。
实现1 //O(n) time &amp; O(n) space var mergeArr1 = (arr1, arr2) =&gt; { var result = [], index1 = 0, index2 = 0, current = 0; while (current &lt; arr1.length + arr2.length) { //debugger; var element1 = arr1[index1]; var element2 = arr2[index2]; if (element1 &lt; element2) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/the-intersection-union-difference-subset-of-two-arrays/">两个数组的交集,并集,差集,子集.md</a>
    </div><div class="post-meta">
    <div class="date">2021-03-04</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">两个数组的交集 集合论中，设A，B是两个集合，由所有属于集合A且属于集合B的元素所组成的集合，叫做集合A与集合B的交集。
集合 {1,2,3} 和 {2,3,4} 的交集为 {2,3}。
//filter实现 let intersect = (a,b) =&gt; a.filter(x =&gt; b.indexOf(x) &gt; -1); //Set实现 let intersect1 = (a, b) =&gt; { return a.filter(x =&gt; new Set(b).has(x)); } let intersect2 = (a, b) =&gt; { let …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/determine-bracket-match/">判断括号匹配</a>
    </div><div class="post-meta">
    <div class="date">2021-03-03</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">如何判断左右小括号是否全部匹配。如 (( ))()((((()))))？
var isValid = function (str) { var stack = []; var map = { &#34;(&#34;: &#34;)&#34;, &#34;[&#34;: &#34;]&#34;, &#34;{&#34;: &#34;}&#34;, }; for (var char of str) { if (char in map) { stack.push(char); } else { if (!stack.length || char != map[stack.pop()]) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/fibonacci-sequence/">斐波那契数列</a>
    </div><div class="post-meta">
    <div class="date">2021-03-02</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">斐波那契数列 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
F(0) = 0, F(1) = 1, F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144&hellip; ，这个数列从第3项开始，每一项都等于前两项之和。
给定 N，计算 F(N) 1、递归
const fib = (n) =&gt; { if(n &lt;= 1) { return n; } return fib(n - 1) + fib(n - 2); }; 2、记忆化 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/determine-if-a-single-linked-list-has-a-loop/">判断单链表是否有环</a>
    </div><div class="post-meta">
    <div class="date">2021-02-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">链表数据结构 // 节点类 class Node { constructor(value) { this.value = value; // 存储值 this.next = null; // 存储下一个节点的引用 } } //链表类 class LinkedList { constructor() { this.length = 0; //链表的长度 this.head = null; //链表的头结点 } //添加节点 append(value) { var node = new Node(value); //创建节点 if (!this.head) { this.head = node; …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/algorithm/string-inversion/">字符串反转</a>
    </div><div class="post-meta">
    <div class="date">2021-02-09</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/algorithm/" rel="tag">algorithm</a>
        </div>
</div>

        <div class="summary">JS实现 //实现1 var reverse1 = (str) =&gt; { return str.split(&#34;&#34;).reverse().join(&#34;&#34;); }; //实现2 var reverse2 = (str) =&gt; { let result = &#34;&#34;; for (let char of str) { result = char + result; } return result; }; //实现3 var reverse3 = (str) =&gt; { return …</div>
    
</div>

        </section>
        
    <div class="pagination">
        <span class="pagination__item pagination__item--current">1/3</span>
            <a class="pagination__item pagination__item--next" href="/tags/algorithm/page/2/">Next</a>
    </div>

    </div>

        </div><script src="/js/highlight.min.js" />
<script>
    document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre").forEach((block) => {
            hljs.highlightBlock(block);
        });
    });
</script>
</body>
</html>
