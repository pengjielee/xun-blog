<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pointers on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/pointers/</link>
    <description>Recent content in pointers on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Apr 2021 10:25:59 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/pointers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>075.颜色分类</title>
      <link>https://www.pengjielee.cn/post/leetcode/075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</link>
      <pubDate>Thu, 15 Apr 2021 10:25:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</guid>
      <description>题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 示例 3： 输入：nums = [0] 输出：[0] 示例 4： 输入：nums = [1] 输出：[1] 提示：
n == nums.length 1 &amp;lt;= n &amp;lt;= 300 nums[i] 为 0、1 或 2 进阶：
你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-colors 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、单指针
在第一次遍历中，我们将数组中所有的 0 交换到数组的头部。
在第二次遍历中，我们将数组中所有的 1 交换到头部的 0 之后。 此时，所有的 2 都出现在数组的尾部，这样我们就完成了排序。
/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead.</description>
    </item>
    
  </channel>
</rss>
