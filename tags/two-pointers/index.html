<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body><div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="page-title">two-pointers</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/draft/sword2/_58.ii.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">58.II.左旋转字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/math/" rel="tag">math</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">06.从尾到头打印链表</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
                <a class="tags_link" href="/tags/recursion/" rel="tag">recursion</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制：
0 &lt;= 链表长度 &lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、reverse()方法，反转数组
/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {number[]} */ var reversePrint = function(head) { const result = []; let current = head; while(current){ result.push(current.val); current = current.next; } return result.reverse(); }; 2、借助栈</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/">125.验证回文串</a>
    </div><div class="post-meta">
    <div class="date">2021-05-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1: 输入: &#34;A man, a plan, a canal: Panama&#34; 输出: true 示例 2: 输入: &#34;race a car&#34; 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
知识点 charCodeAt()
charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
charAt()
方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。
&#39;a&#39;.charCodeAt(); //97 &#39;b&#39;.charCodeAt(); //98 ... &#39;z&#39;.charCodeAt(); //122 (97+26-1=122) &#39;A&#39;.charCodeAt(); //65 &#39;B&#39;.charCodeAt(); //66 ... &#39;Z&#39;.charCodeAt(); //90 (65+26-1=90) &#39;0&#39;.charCodeAt(); //48 &#39;1&#39;.charCodeAt(); //49 &#39;9&#39;.charCodeAt(); //57 (48+10-1=57) JS实现 /** * @param {string} s * @return {boolean} */ var isPalindrome = (str) =&gt; { // 字符串转为小写 str = str.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/633.%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/">633.平方数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/math/" rel="tag">math</a>
        </div>
</div>

        <p class="summary">题目 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c 。
示例 1： 输入：c = 5 输出：true 解释：1 * 1 + 2 * 2 = 5 示例 2： 输入：c = 3 输出：false 示例 3： 输入：c = 4 输出：true 解释：0 * 0 + 2 * 2 = 4 示例 4： 输入：c = 2 输出：true 解释：1 * 1 + 1 * 1= 2 示例 5： 输入：c = 1 输出：true 解释：0 * 0 + 1 * 1 = 1 提示： 0 &lt;= c &lt;= 2^31 - 1</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/680.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/">680.验证回文字符串II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
示例 1: 输入: &#34;aba&#34; 输出: True 示例 2: 输入: &#34;abca&#34; 输出: True 解释: 你可以删除c字符。 注意:
字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {boolean} */ var validPalindrome = function (s) { // 双指针，一个指向字符串开头，一个指向字符串末尾 let i = 0, j = s.length - 1; // 判断是否是回文串 const isPalindrome = (low, high) =&gt; { while (low &lt; high) { if (s.charAt(low) != s.charat(high)) { return false; } low++; high--; } return true; }; while (i &lt; j) { // 字符串开头与末尾不相等 if (s.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/524._%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/">524.通过删除字母匹配到字典里最长单词</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。
示例 1: 输入: s = &#34;abpcplea&#34;, d = [&#34;ale&#34;,&#34;apple&#34;,&#34;monkey&#34;,&#34;plea&#34;] 输出: &#34;apple&#34; 示例 2: 输入: s = &#34;abpcplea&#34;, d = [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;] 输出: &#34;a&#34; 说明:
所有输入的字符串只包含小写字母。 字典的大小不会超过 1000。 所有输入的字符串长度不会超过 1000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @param {string[]} dictionary * @return {string} */ var findLongestWord = function (s, dictionary) { let result = &#34;&#34;; // 遍历字典 for (let dstr of dictionary) { // 定义两个指针i,j，i用来指向整个字符串s，j用来指向字符串dstr for (let i = 0, j = 0; i &lt; s.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/">167.两数之和II-输入有序数组.md</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。
numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 提示：
2 &lt;= numbers.length &lt;= 3 * 10^4 -1000 &lt;= numbers[i] &lt;= 1000 numbers 按 递增顺序 排列 -1000 &lt;= target &lt;= 1000 仅存在一个有效答˜ 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/">019.删除链表的倒数第N个结点</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
示例 1： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 //删除倒数第2个后： 1 -&gt; 2 -&gt; 3 -&gt; 5 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示：
链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/">142.环形链表II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
进阶：
你是否可以使用 O(1) 空间解决此题？ 示例：
示例 1： 3 -&gt; 2 -&gt; 0 -&gt; -4 -&gt; 2 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 1 -&gt; 2 -&gt; 1 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 1 -&gt; null 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">141.环形链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
进阶：
你能用 O(1)（即，常量）内存解决此问题吗？ 示例：
示例 1： 3 -&gt; 2 -&gt; 0 -&gt; -4 [-&gt; 2] 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 1 -&gt; 2 [-&gt; 1] 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 1 -&gt; null 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">234.回文链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 请判断一个链表是否为回文链表。
示例 1: 输入: 1-&gt;2 输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、将值复制到数组中后用双指针法
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {boolean} */ var isPalindrome = function (head) { const values = []; // 将链表的值保存到数组中 while (head !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/">349.两个数组的交集</a>
    </div><div class="post-meta">
    <div class="date">2021-04-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 说明：
输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、排序 + 双指针
/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function (nums1, nums2) { const result = []; //分别对两个数组排序（从小到大） nums1.sort((a, b) =&gt; a - b); nums2.sort((a, b) =&gt; a - b); const len1 = nums1.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">015.三数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-04-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/sum/" rel="tag">sum</a>
        </div>
</div>

        <p class="summary">题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2： 输入：nums = [] 输出：[] 示例 3： 输入：nums = [0] 输出：[] 提示：
0 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function (nums) { let result = []; // 传入数组为null直接返回result if (nums === null) { return result; } const len = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">344.反转字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-03-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&#34;h&#34;,&#34;e&#34;,&#34;l&#34;,&#34;l&#34;,&#34;o&#34;] 输出：[&#34;o&#34;,&#34;l&#34;,&#34;l&#34;,&#34;e&#34;,&#34;h&#34;] 示例 2：
输入：[&#34;H&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;h&#34;] 输出：[&#34;h&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;H&#34;] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 双指针的解法：
1、将 left 指向字符数组首元素，right 指向字符数组尾元素。
2、当 left &lt; right：
交换 s[left] 和 s[right]； left 指针右移一位，即 left = left + 1； right 指针左移一位，即 right = right - 1。 3、当 left &gt;= right，反转结束，返回字符数组即可。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/reverse-string/solution/fan-zhuan-zi-fu-chuan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/088.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/">088.合并两个有序数组</a>
    </div><div class="post-meta">
    <div class="date">2021-03-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/merge/" rel="tag">merge</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
        </div>
</div>

        <p class="summary">题目 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 提示：
nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/026.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">026.删除有序数组中的重复项</a>
    </div><div class="post-meta">
    <div class="date">2021-03-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 示例 1：
输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]</p>
    
</div>

        </section>
    </div>
    
    <div class="pagination">
        <span class="pagination__item pagination__item--current">1/2</span>
            <a class="pagination__item pagination__item--next btn" href="/tags/two-pointers/page/2/">Next</a>
    </div>


        </div></body>
</html>
