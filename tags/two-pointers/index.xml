<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>two-pointers on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/two-pointers/</link>
    <description>Recent content in two-pointers on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 24 Aug 2021 15:04:22 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/two-pointers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>58.II.左旋转字符串</title>
      <link>https://www.pengjielee.cn/draft/sword2/_58.ii.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 24 Aug 2021 15:04:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_58.ii.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>06.从尾到头打印链表</title>
      <link>https://www.pengjielee.cn/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 24 Aug 2021 13:34:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制：
0 &amp;lt;= 链表长度 &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、reverse()方法，反转数组
/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {number[]} */ var reversePrint = function(head) { const result = []; let current = head; while(current){ result.push(current.val); current = current.next; } return result.reverse(); }; 2、借助栈</description>
    </item>
    
    <item>
      <title>125.验证回文串</title>
      <link>https://www.pengjielee.cn/post/leetcode/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Sat, 08 May 2021 10:31:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1: 输入: &amp;#34;A man, a plan, a canal: Panama&amp;#34; 输出: true 示例 2: 输入: &amp;#34;race a car&amp;#34; 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
知识点 charCodeAt()
charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
charAt()
方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。
&amp;#39;a&amp;#39;.charCodeAt(); //97 &amp;#39;b&amp;#39;.charCodeAt(); //98 ... &amp;#39;z&amp;#39;.charCodeAt(); //122 (97+26-1=122) &amp;#39;A&amp;#39;.charCodeAt(); //65 &amp;#39;B&amp;#39;.charCodeAt(); //66 ... &amp;#39;Z&amp;#39;.charCodeAt(); //90 (65+26-1=90) &amp;#39;0&amp;#39;.charCodeAt(); //48 &amp;#39;1&amp;#39;.charCodeAt(); //49 &amp;#39;9&amp;#39;.charCodeAt(); //57 (48+10-1=57) JS实现 /** * @param {string} s * @return {boolean} */ var isPalindrome = (str) =&amp;gt; { // 字符串转为小写 str = str.</description>
    </item>
    
    <item>
      <title>633.平方数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/633.%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 06 May 2021 10:28:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/633.%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c 。
示例 1： 输入：c = 5 输出：true 解释：1 * 1 + 2 * 2 = 5 示例 2： 输入：c = 3 输出：false 示例 3： 输入：c = 4 输出：true 解释：0 * 0 + 2 * 2 = 4 示例 4： 输入：c = 2 输出：true 解释：1 * 1 + 1 * 1= 2 示例 5： 输入：c = 1 输出：true 解释：0 * 0 + 1 * 1 = 1 提示： 0 &amp;lt;= c &amp;lt;= 2^31 - 1</description>
    </item>
    
    <item>
      <title>680.验证回文字符串II</title>
      <link>https://www.pengjielee.cn/post/leetcode/680.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 06 May 2021 09:58:17 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/680.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
示例 1: 输入: &amp;#34;aba&amp;#34; 输出: True 示例 2: 输入: &amp;#34;abca&amp;#34; 输出: True 解释: 你可以删除c字符。 注意:
字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {boolean} */ var validPalindrome = function (s) { // 双指针，一个指向字符串开头，一个指向字符串末尾 let i = 0, j = s.length - 1; // 判断是否是回文串 const isPalindrome = (low, high) =&amp;gt; { while (low &amp;lt; high) { if (s.charAt(low) != s.charat(high)) { return false; } low++; high--; } return true; }; while (i &amp;lt; j) { // 字符串开头与末尾不相等 if (s.</description>
    </item>
    
    <item>
      <title>524.通过删除字母匹配到字典里最长单词</title>
      <link>https://www.pengjielee.cn/post/leetcode/524._%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Thu, 06 May 2021 09:22:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/524._%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</guid>
      <description>题目 给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。
示例 1: 输入: s = &amp;#34;abpcplea&amp;#34;, d = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] 输出: &amp;#34;apple&amp;#34; 示例 2: 输入: s = &amp;#34;abpcplea&amp;#34;, d = [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出: &amp;#34;a&amp;#34; 说明:
所有输入的字符串只包含小写字母。 字典的大小不会超过 1000。 所有输入的字符串长度不会超过 1000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @param {string[]} dictionary * @return {string} */ var findLongestWord = function (s, dictionary) { let result = &amp;#34;&amp;#34;; // 遍历字典 for (let dstr of dictionary) { // 定义两个指针i,j，i用来指向整个字符串s，j用来指向字符串dstr for (let i = 0, j = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>167.两数之和II-输入有序数组.md</title>
      <link>https://www.pengjielee.cn/post/leetcode/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 25 Apr 2021 16:20:20 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。
numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;= numbers.length 。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 提示：
2 &amp;lt;= numbers.length &amp;lt;= 3 * 10^4 -1000 &amp;lt;= numbers[i] &amp;lt;= 1000 numbers 按 递增顺序 排列 -1000 &amp;lt;= target &amp;lt;= 1000 仅存在一个有效答˜ 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>019.删除链表的倒数第N个结点</title>
      <link>https://www.pengjielee.cn/post/leetcode/019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</link>
      <pubDate>Thu, 22 Apr 2021 09:15:56 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</guid>
      <description>题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
示例 1： 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 //删除倒数第2个后： 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 5 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示：
链表中结点的数目为 sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</description>
    </item>
    
    <item>
      <title>142.环形链表II</title>
      <link>https://www.pengjielee.cn/post/leetcode/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link>
      <pubDate>Thu, 22 Apr 2021 09:13:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid>
      <description>题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
进阶：
你是否可以使用 O(1) 空间解决此题？ 示例：
示例 1： 3 -&amp;gt; 2 -&amp;gt; 0 -&amp;gt; -4 -&amp;gt; 2 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 1 -&amp;gt; 2 -&amp;gt; 1 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 1 -&amp;gt; null 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：</description>
    </item>
    
    <item>
      <title>141.环形链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Apr 2021 09:13:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
进阶：
你能用 O(1)（即，常量）内存解决此问题吗？ 示例：
示例 1： 3 -&amp;gt; 2 -&amp;gt; 0 -&amp;gt; -4 [-&amp;gt; 2] 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 1 -&amp;gt; 2 [-&amp;gt; 1] 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 1 -&amp;gt; null 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示：</description>
    </item>
    
    <item>
      <title>234.回文链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Apr 2021 09:11:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 请判断一个链表是否为回文链表。
示例 1: 输入: 1-&amp;gt;2 输出: false 示例 2: 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、将值复制到数组中后用双指针法
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {boolean} */ var isPalindrome = function (head) { const values = []; // 将链表的值保存到数组中 while (head !</description>
    </item>
    
    <item>
      <title>349.两个数组的交集</title>
      <link>https://www.pengjielee.cn/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Sat, 17 Apr 2021 16:14:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 说明：
输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、排序 + 双指针
/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function (nums1, nums2) { const result = []; //分别对两个数组排序（从小到大） nums1.sort((a, b) =&amp;gt; a - b); nums2.sort((a, b) =&amp;gt; a - b); const len1 = nums1.</description>
    </item>
    
    <item>
      <title>015.三数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 15 Apr 2021 14:14:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2： 输入：nums = [] 输出：[] 示例 3： 输入：nums = [0] 输出：[] 提示：
0 &amp;lt;= nums.length &amp;lt;= 3000 -10^5 &amp;lt;= nums[i] &amp;lt;= 10^5
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function (nums) { let result = []; // 传入数组为null直接返回result if (nums === null) { return result; } const len = nums.</description>
    </item>
    
    <item>
      <title>344.反转字符串</title>
      <link>https://www.pengjielee.cn/post/leetcode/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 22 Mar 2021 10:12:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&amp;#34;h&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;o&amp;#34;] 输出：[&amp;#34;o&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;h&amp;#34;] 示例 2：
输入：[&amp;#34;H&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;h&amp;#34;] 输出：[&amp;#34;h&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;H&amp;#34;] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 双指针的解法：
1、将 left 指向字符数组首元素，right 指向字符数组尾元素。
2、当 left &amp;lt; right：
交换 s[left] 和 s[right]； left 指针右移一位，即 left = left + 1； right 指针左移一位，即 right = right - 1。 3、当 left &amp;gt;= right，反转结束，返回字符数组即可。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/reverse-string/solution/fan-zhuan-zi-fu-chuan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead.</description>
    </item>
    
    <item>
      <title>088.合并两个有序数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/088.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 19 Mar 2021 17:06:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/088.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 提示：
nums1.length == m + n nums2.length == n 0 &amp;lt;= m, n &amp;lt;= 200 1 &amp;lt;= m + n &amp;lt;= 200 -10^9 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>026.删除有序数组中的重复项</title>
      <link>https://www.pengjielee.cn/post/leetcode/026.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Tue, 16 Mar 2021 15:29:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/026.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>题目 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); } 示例 1：
输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]</description>
    </item>
    
  </channel>
</rss>
