<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/monokai-sublime.min.css" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
        <div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="title">question</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/fe/15.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8Fvs%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">15.观察者模式vs发布订阅模式</a>
    </div><div class="post-meta">
    <div class="date">2021-04-13</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">联系 / 意图 / 区别 / 适用场景 1、联系
发布-订阅模式是观察者模式的一种变体。发布-订阅只是把一部分功能抽象成一个独立的ChangeManager。
2、意图
都是某个对象(subject, publisher)改变，使依赖于它的多个对象(observers, subscribers)得到通知。
3、区别与适用场景
总的来说，发布-订阅模式适合更复杂的场景。
在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？
在「多对一」或者「多对多」场景下。一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是等所有发布者都更新完毕再通知订阅者？
这些逻辑都可以放 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/14.%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/">14.实现数组方法合集</a>
    </div><div class="post-meta">
    <div class="date">2021-04-13</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">实现数组方法flat // 实现1 var flat1 = (arr, number = 10) =&gt; { let result = [],count = 0; var helper = (arr) =&gt; { let res = []; count++; for (let item of arr) { if (Array.isArray(item)) { if (count === number) { break; } res = res.concat(helper(item)); } else { res.push(item); } } return res; }; result …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/12.css%E4%BC%98%E5%85%88%E7%BA%A7/">12.CSS优先级</a>
    </div><div class="post-meta">
    <div class="date">2021-04-13</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">一道题目 &lt;style&gt; .classA { color: blue; } .classB { color: red; } p { color: black; } &lt;/style&gt; &lt;p class=&#34;classB classA&#34;&gt;hello&lt;/p&gt; &lt;!-- 元素p内的文字最终什么颜色：red --&gt; 解释：“类选择器” 的优先级要高于 “类型选择器”；后面声明的类选择器 &gt; 先声明的类选择器，所以颜色为red（css）。
更多实例 1、
&lt;style&gt; div { width: 100px; …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/11.typeof%E6%93%8D%E4%BD%9C%E7%AC%A6/">11.typeof操作符</a>
    </div><div class="post-meta">
    <div class="date">2021-04-13</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">一道题目 typeof typeof typeof null; //&#39;string&#39; typeof操作符 typeof 操作符返回一个字符串，表示未经计算的操作数的类型。
语法：
typeof operand typeof(operand) 1、数值
console.log(typeof 42); //&#39;number&#39; console.log(typeof 3.14); //&#39;number&#39; console.log(typeof(42)); //&#39;number&#39; console.log(typeof Math.LN2); …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/10.function.prototype-object.prototype/">10.Function.prototype &amp; Object.prototype.md</a>
    </div><div class="post-meta">
    <div class="date">2021-04-13</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">一道题目 Function.prototype.a = () =&gt; alert(1); Object.prototype.b = () =&gt; alert(2); function Foo() {} var bar = new Foo(); bar.a(); //Uncaught TypeError: bar.a is not a function bar.b(); //2 表达式结果 以下为chrome 88.0.4324.96
function F(){}; var o = {}; // 这是一个构造函数 typeof F; //&#39;function&#39; // 这是一 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/09.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/">09.代码输出结果</a>
    </div><div class="post-meta">
    <div class="date">2021-04-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">1、 实现一个工具方法，将下划线命名格式的字符串转化为驼峰命名格式
//实现1 var convert1 = (name) =&gt; { let result = name.split(&#34;_&#34;); const [first, ...rest] = result; return ( first + rest .map((item) =&gt; item.substring(0, 1).toUpperCase() + item.substring(1)) .join(&#34;&#34;) ); }; //实现2 var convert2 = (name) =&gt; { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/08.%E9%83%A8%E9%97%A8%E7%BB%84%E5%90%88/">08.部门组合</a>
    </div><div class="post-meta">
    <div class="date">2021-04-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">题目 求部门安排所有组合。
示例1：
部门：{&#39;frontend&#39;: [1, 2], &#39;backend&#39;: [3, 4], &#39;devops&#39;: [5]} 人数：{&#39;frontend&#39;: 2, &#39;backend&#39;: 1} 组合：[[1, 2, 3], [1, 2, 4]] 要求：按员工ID升序排序
实现 /** * 部门安排所有组合 * @param departments: dict, key是部门名, value是每个部门对应所有员工ID数组 * 例 {&#39;frontend&#39;: [1, 2], …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/07.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/">07.字符串处理</a>
    </div><div class="post-meta">
    <div class="date">2021-04-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">统计数组中每个字符串出现次数 /** * 统计数组中每个字符串出现次数 * @param string[] strs: 字符串数组, 例如 [&#39;aa&#39;, &#39;ab&#39;, &#39;ab&#39;, &#39;cc&#39;, &#39;cba&#39;] * @return {[key: string]: number} 出现次数对象, 例如 { aa: 1, ab: 2, cc: 1, cba: 1 } */ var frequencyMap = (strs) =&gt; { const map = {}; for (let i = 0; i &lt; …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/06.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/">06.代码输出结果</a>
    </div><div class="post-meta">
    <div class="date">2021-04-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">1. function fn2(){ for(var i=0;i&lt;4;i++){ var timer=setInterval(function(i,timer){ console.log(i); clearInterval(timer) },10,i,timer); } } fn2(); 输出：0 1 2 3 3 3 3 重复
2. function fn1(){ for(var i=0;i&lt;4;i++){ var timer=setTimeout(function(i){ console.log(i); clearTimeout(timer) },10,i); } } …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/05.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/">05.代码输出结果</a>
    </div><div class="post-meta">
    <div class="date">2021-04-02</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">1. 输出是什么？ function sayHi() { console.log(name) console.log(age) var name = &#39;Lydia&#39; let age = 21 } sayHi() A: Lydia 和 undefined B: Lydia 和 ReferenceError C: ReferenceError 和 21 D: undefined 和 ReferenceError 我的：D（ok）
2. 输出是什么？ for (var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/04.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/">04.代码输出结果</a>
    </div><div class="post-meta">
    <div class="date">2021-03-30</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">33. 下面的代码打印什么内容，为什么？ var b = 10; (function b(){ b = 20; console.log(b); })(); 我的：20
正确：[Function b]
解析：
声明提前：一个声明在函数体内都是可见的，函数声明优先于变量声明； 在非匿名自执行函数中，函数变量为只读状态无法修改；
var b = 10; (function b() { // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值； // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/03.parseint%E4%B8%8Emap/">03.parseInt与map</a>
    </div><div class="post-meta">
    <div class="date">2021-03-29</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">[&lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;].map(parseInt) what &amp; why ? 1、parseInt
parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。
const intValue = parseInt(string[, radix]); string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。
radix 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/02.%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E7%81%AF/">02.实现信号灯</a>
    </div><div class="post-meta">
    <div class="date">2021-03-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">版本1：实现一个简单的信号灯切换 (function () { const start = () =&gt; { setTimeout(() =&gt; { console.log(&#34;红灯亮.&#34;); setTimeout(() =&gt; { console.log(&#34;绿灯亮.&#34;); setTimeout(() =&gt; { console.log(&#34;黄灯亮.&#34;); start(); }, 1 * 1000); }, 2 * 1000); }, 3 * 1000); }; start(); })(); 版本2： …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fe/01.%E4%BF%A1%E5%8F%B7%E7%81%AF%E6%8E%A7%E5%88%B6%E5%99%A8/">01.信号灯控制器</a>
    </div><div class="post-meta">
    <div class="date">2021-03-02</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">题目 信号灯控制器
用 React 实现一个信号灯（交通灯）控制器，要求：
默认情况下，
1.1. 红灯亮20秒，并且最后5秒闪烁；
1.2. 绿灯亮20秒，并且最后5秒闪烁；
1.3. 黄灯亮10秒；
1.4. 次序为 红-绿-黄-红-绿-黄； 灯的个数、颜色、持续时间、闪烁时间、灯光次序都可配置，如：
lights=[{color: &lsquo;#fff&rsquo;, duration: 10000, twinkleDuration: 5000}, &hellip; ] 参考 import React from &#39;react&#39;; import ReactDOM from …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/tags/question/index/">00.前端面试题合集</a>
    </div><div class="post-meta">
    <div class="date">2021-03-01</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/question/" rel="tag">question</a>
        </div>
</div>

        <div class="summary">&lsquo;##&rsquo; 1、node-interview
https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn
&lsquo;##&rsquo; 2、Front-end Developer Interview Questions
https://github.com/h5bp/Front-end-Developer-Interview-Questions
&lsquo;##&rsquo; 3、fe-interview
https://github.com/haizlin/fe-interview
前端 …</div>
    
</div>

        </section>
        
    <div class="pagination">
            <a class="pagination__item pagination__item--prev" href="/tags/question/">Prev</a>
        <span class="pagination__item pagination__item--current">2/2</span>
    </div>

    </div>

        </div><script src="/js/highlight.min.js" />
<script>
    document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre").forEach((block) => {
            hljs.highlightBlock(block);
        });
    });
</script>
</body>
</html>
