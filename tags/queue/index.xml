<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>queue on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/queue/</link>
    <description>Recent content in queue on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 24 Aug 2021 11:37:14 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>09.用两个栈实现队列</title>
      <link>https://www.pengjielee.cn/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 24 Aug 2021 11:37:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1： 输入： [&amp;#34;CQueue&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;deleteHead&amp;#34;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [&amp;#34;CQueue&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;deleteHead&amp;#34;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 &amp;lt;= values &amp;lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思考 队列特点：先进先出；
栈特点：先进后出；
JS实现 var CQueue = function() { //辅助栈1：插入栈 this.insertStack = []; //辅助栈2：弹出栈 this.popStack = []; return null; }; /** * @param {number} value * @return {void} */ CQueue.prototype.appendTail = function(value) { //插入时，把元素直接插入插入栈 this.insertStack.push(value); return null; }; /** * @return {number} */ CQueue.</description>
    </item>
    
    <item>
      <title>107.二叉树的层序遍历II</title>
      <link>https://www.pengjielee.cn/post/leetcode/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii/</link>
      <pubDate>Mon, 19 Apr 2021 14:06:42 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii/</guid>
      <description>题目 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回其自底向上的层序遍历为： [ [15,7], [9,20], [3] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、反转其返回结果（102.二叉树的层序遍历）
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrderBottom = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</description>
    </item>
    
    <item>
      <title>103.二叉树的锯齿形层序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:12:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回锯齿形层序遍历如下： [ [3], [20,9], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var zigzagLevelOrder = function (root) { // write code here const result = []; if (root === null) { return result; } const q = []; q.</description>
    </item>
    
    <item>
      <title>102.二叉树的层序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 20 Mar 2021 11:05:11 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例： 二叉树：[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层序遍历结果：
[ [3], [9,20], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</description>
    </item>
    
    <item>
      <title>101.对称二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 20 Mar 2021 09:52:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
1 / \ 2 2 \ \ 3 3 进阶：
你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归实现
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ?</description>
    </item>
    
    <item>
      <title>05.用两个栈实现队列</title>
      <link>https://www.pengjielee.cn/post/use-two-stacks-to-implement-the-queue/</link>
      <pubDate>Mon, 01 Mar 2021 13:39:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/use-two-stacks-to-implement-the-queue/</guid>
      <description>题目 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
详解 队列的特性是：“先进先出”，栈的特性是：“先进后出”。
当我们向模拟的队列插入数 a,b,c 时，假设插入的是 stack1，此时的栈情况为： 栈 stack1：{a,b,c} 栈 stack2：{} 当需要弹出一个数，根据队列的&amp;#34;先进先出&amp;#34;原则，a 先进入，则 a 应该先弹出。但是此时 a 在 stack1 的最下面，将 stack1 中全部元素逐个弹出压入 stack2，现在可以正确的从 stack2 中弹出 a，此时的栈情况为： 栈 stack1：{} 栈 stack2：{c,b} 继续弹出一个数，b 比 c 先进入&amp;#34;队列&amp;#34;，b 弹出，注意此时 b 在 stack2 的栈顶，可直接弹出，此时的栈情况为： 栈 stack1：{} 栈 stack2：{c} 此时向模拟队列插入一个数 d，还是插入 stack1，此时的栈情况为： 栈 stack1：{d} 栈 stack2：{c} 弹出一个数，c 比 d 先进入，c 弹出，注意此时 c 在 stack2 的栈顶，可直接弹出，此时的栈情况为： 栈 stack1：{d} 栈 stack2：{} 根据上述例子可得出结论：
当插入时，直接插入 stack1； 当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈 stack2，再弹出 stack2 栈顶元素； 链接：https://www.</description>
    </item>
    
  </channel>
</rss>
