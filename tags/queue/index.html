<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body><div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="page-title">queue</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">09.用两个栈实现队列</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
                <a class="tags_link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <p class="summary">题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1： 输入： [&#34;CQueue&#34;,&#34;appendTail&#34;,&#34;deleteHead&#34;,&#34;deleteHead&#34;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [&#34;CQueue&#34;,&#34;deleteHead&#34;,&#34;appendTail&#34;,&#34;appendTail&#34;,&#34;deleteHead&#34;,&#34;deleteHead&#34;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思考 队列特点：先进先出；
栈特点：先进后出；
JS实现 var CQueue = function() { //辅助栈1：插入栈 this.insertStack = []; //辅助栈2：弹出栈 this.popStack = []; return null; }; /** * @param {number} value * @return {void} */ CQueue.prototype.appendTail = function(value) { //插入时，把元素直接插入插入栈 this.insertStack.push(value); return null; }; /** * @return {number} */ CQueue.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii/">107.二叉树的层序遍历II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回其自底向上的层序遍历为： [ [15,7], [9,20], [3] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、反转其返回结果（102.二叉树的层序遍历）
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrderBottom = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">103.二叉树的锯齿形层序遍历</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回锯齿形层序遍历如下： [ [3], [20,9], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var zigzagLevelOrder = function (root) { // write code here const result = []; if (root === null) { return result; } const q = []; q.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">102.二叉树的层序遍历</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
</div>

        <p class="summary">题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例： 二叉树：[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层序遍历结果：
[ [3], [9,20], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">101.对称二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
1 / \ 2 2 \ \ 3 3 进阶：
你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归实现
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ?</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/use-two-stacks-to-implement-the-queue/">05.用两个栈实现队列</a>
    </div><div class="post-meta">
    <div class="date">2021-03-01</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/stack/" rel="tag">Stack</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="tags_link" href="/categories/swordoffer/" rel="tag">swordoffer</a>
        </div>
</div>

        <p class="summary">题目 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
详解 队列的特性是：“先进先出”，栈的特性是：“先进后出”。
当我们向模拟的队列插入数 a,b,c 时，假设插入的是 stack1，此时的栈情况为： 栈 stack1：{a,b,c} 栈 stack2：{} 当需要弹出一个数，根据队列的&#34;先进先出&#34;原则，a 先进入，则 a 应该先弹出。但是此时 a 在 stack1 的最下面，将 stack1 中全部元素逐个弹出压入 stack2，现在可以正确的从 stack2 中弹出 a，此时的栈情况为： 栈 stack1：{} 栈 stack2：{c,b} 继续弹出一个数，b 比 c 先进入&#34;队列&#34;，b 弹出，注意此时 b 在 stack2 的栈顶，可直接弹出，此时的栈情况为： 栈 stack1：{} 栈 stack2：{c} 此时向模拟队列插入一个数 d，还是插入 stack1，此时的栈情况为： 栈 stack1：{d} 栈 stack2：{c} 弹出一个数，c 比 d 先进入，c 弹出，注意此时 c 在 stack2 的栈顶，可直接弹出，此时的栈情况为： 栈 stack1：{d} 栈 stack2：{} 根据上述例子可得出结论：
当插入时，直接插入 stack1； 当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈 stack2，再弹出 stack2 栈顶元素； 链接：https://www.</p>
    
</div>

        </section>
    </div>
    


        </div></body>
</html>
