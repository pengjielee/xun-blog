<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body><div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="page-title">binary-search</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/leetcode/154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/">154.寻找旋转排序数组中的最小值II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], &hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], &hellip;, a[n-2]] 。
给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
示例 1： 输入：nums = [1,3,5] 输出：1 示例 2： 输入：nums = [2,2,2,0,1] 输出：0 提示：
n == nums.length 1 &lt;= n &lt;= 5000 -5000 &lt;= nums[i] &lt;= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/153.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/">153.寻找旋转排序数组中的最小值</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], &hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], &hellip;, a[n-2]] 。
给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
示例 1： 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2： 输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3： 输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">033.搜索旋转排序数组</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], &hellip;, nums[n-1], nums[0], nums[1], &hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2： 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3： 输入：nums = [1], target = 0 输出：-1 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/081.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/">081.搜索旋转排序数组II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], &hellip;, nums[n-1], nums[0], nums[1], &hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
示例 1： 输入：nums = [2,5,6,0,0,1,2], target = 0 输出：true 示例 2： 输入：nums = [2,5,6,0,0,1,2], target = 3 输出：false 提示：
1 &lt;= nums.length &lt;= 5000 -10^4 &lt;= nums[i] &lt;= 10^4 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -10^4 &lt;= target &lt;= 10^4 进阶：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/">034.在排序数组中查找元素的第一个和最后一个位置</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例：
示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示：
0 &lt;= nums.length &lt;= 10^5 -10^9 &lt;= nums[i] &lt;= 10^9 nums 是一个非递减数组 -10^9 &lt;= target &lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、
/** * @param {number[]} nums * @param {number} target * @return {number[]} */ // 查找第一个等于给定值的元素 const binarySearchFirst = (arr, target) =&gt; { let low = 0, high = arr.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/540.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/">540.有序数组中的单一元素</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
示例 1: 输入: [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2: 输入: [3,3,7,7,10,11,11] 输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、位运算
/** * @param {number[]} nums * @return {number} */ var singleNonDuplicate = function (nums) { let result = nums[0]; for (let i = 1; i &lt; nums.length; i++) { result = result ^ nums[i]; } return result; }; 2、二分搜索
我们的数组个数始终是奇数，因为有一个元素出现一次，其余元素出现两次。
var singleNonDuplicate = function (nums) { let low = 0, high = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/">167.两数之和II-输入有序数组.md</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。
numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 提示：
2 &lt;= numbers.length &lt;= 3 * 10^4 -1000 &lt;= numbers[i] &lt;= 1000 numbers 按 递增顺序 排列 -1000 &lt;= target &lt;= 1000 仅存在一个有效答˜ 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/069.x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/">069.x的平方根</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sqrtx 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于 x 平方根的整数部分ans 是满足 k^2 &lt;= x 的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。
二分查找的下界为 0，上界可以粗略地设定为 x。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number} x * @return {number} */ var mySqrt = function (x) { if (x &lt; 2) { return x; } let low = 1, high = Math.</p>
    
</div>

        </section>
    </div>
    


        </div></body>
</html>
