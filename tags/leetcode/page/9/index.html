<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/monokai-sublime.min.css" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
        <div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="title">leetcode</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/leetcode/463.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/">463.岛屿的周长</a>
    </div><div class="post-meta">
    <div class="date">2021-05-11</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <div class="summary">题目 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。
网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
示例 1： 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] 输出：16 解 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/">617.合并二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-05-11</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <div class="summary">题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
示例 1:
输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。
来源：力扣（LeetCode） 链 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/064.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/">064.最小路径和</a>
    </div><div class="post-meta">
    <div class="date">2021-05-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <div class="summary">题目 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示：
m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 来源：力 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_137.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97ii/">137.只出现一次的数字II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/bit/" rel="tag">bit</a>
        </div>
</div>

        <div class="summary">题目 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
示例 1： 输入：nums = [2,2,3,2] 输出：3 示例 2： 输入：nums = [0,1,0,1,0,1,99] 输出：99 提示：
1 &lt;= nums.length &lt;= 3 * 10^4 -2^31 &lt;= nums[i] &lt;= 2^31 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
来源：力扣（LeetCode） 链 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/">125.验证回文串</a>
    </div><div class="post-meta">
    <div class="date">2021-05-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <div class="summary">题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1: 输入: &#34;A man, a plan, a canal: Panama&#34; 输出: true 示例 2: 输入: &#34;race a car&#34; 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
知识点 charCodeAt() …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/">154.寻找旋转排序数组中的最小值II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <div class="summary">题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], &hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], &hellip;, a[n-2]] 。
给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/153.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/">153.寻找旋转排序数组中的最小值</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <div class="summary">题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], &hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], &hellip;, a[n-2]] 。
给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">033.搜索旋转排序数组</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <div class="summary">题目 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], &hellip;, nums[n-1], nums[0], nums[1], &hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/081.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/">081.搜索旋转排序数组II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <div class="summary">题目 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], &hellip;, nums[n-1], nums[0], nums[1], &hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你 旋转后 的数组 nums 和一个整数 target ， …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/">034.在排序数组中查找元素的第一个和最后一个位置</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <div class="summary">题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例：
示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示：
0 &lt;= …</div>
    
</div>

        </section>
        
    <div class="pagination">
            <a class="pagination__item pagination__item--prev" href="/tags/leetcode/page/8/">Prev</a>
        <span class="pagination__item pagination__item--current">9/21</span>
            <a class="pagination__item pagination__item--next" href="/tags/leetcode/page/10/">Next</a>
    </div>

    </div>

        </div><script src="/js/highlight.min.js"></script>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre").forEach((block) => {
            hljs.highlightBlock(block);
        });
        
        
        
        
        
        
        
        
        
        
    });
</script>
</body>
</html>
