<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/monokai-sublime.min.css" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
        <div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="title">leetcode</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/leetcode/097.%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/">097.交错字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <div class="summary">题目 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。
两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：
s = s1 + s2 + &hellip; + sn t = t1 + t2 + &hellip; + tm |n - m| &lt;= 1 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + &hellip; 或者 t1 + s1 + t2 + s2 + t3 + s3 + &hellip; 提示：a + b 意味着字符串 a 和 b 连接。</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/099.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">099.恢复二叉搜索树</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <div class="summary">题目 给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？
示例 1： 1 / \ 3 null / \ null 2 3 / \ 1 null / \ null 2 输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： 3 / \ 1 4 / \ / null null 2 2 / \ 1 4 / \ …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/016.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">016.最接近的三数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-07-13</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/sum/" rel="tag">sum</a>
        </div>
</div>

        <div class="summary">题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例：
输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 提示：
3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4
来源：力扣（LeetCode） 链 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/">189.旋转数组</a>
    </div><div class="post-meta">
    <div class="date">2021-05-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/array/" rel="tag">array</a>
        </div>
</div>

        <div class="summary">题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/350._%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86ii/">350.两个数组的交集II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/array/" rel="tag">array</a>
                <a class="link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <div class="summary">题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明：
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">217.存在重复元素</a>
    </div><div class="post-meta">
    <div class="date">2021-05-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/array/" rel="tag">array</a>
                <a class="link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <div class="summary">题目 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_007.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/">007.整数反转</a>
    </div><div class="post-meta">
    <div class="date">2021-05-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/math/" rel="tag">math</a>
        </div>
</div>

        <div class="summary">题目 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0 提示：
-2^31 &lt;= x &lt;= 2^31 - 1 来源：力扣（LeetCode） 链 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">297.二叉树的序列化与反序列化</a>
    </div><div class="post-meta">
    <div class="date">2021-05-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <div class="summary">题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
示例 1： 输入：root = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/380.%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/">380.常数时间插入、删除和获取随机元素</a>
    </div><div class="post-meta">
    <div class="date">2021-05-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <div class="summary">题目 设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。
insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :
// 初始化一个空的集合。 RandomizedSet randomSet = new RandomizedSet(); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。 randomSet.insert(1); // 返回 false ，表示集合中不存在 2 。 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/">322.零钱兑换</a>
    </div><div class="post-meta">
    <div class="date">2021-05-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <div class="summary">题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
你可以认为每种硬币的数量是无限的。
示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 输入：coins = [2], amount = 3 输出：-1 示例 3： 输入：coins = [1], amount = 0 输出：0 示例 4： 输入：coins = [1], amount = 1 输出：1 示例 5： 输入：coins = …</div>
    
</div>

        </section>
        
    <div class="pagination">
            <a class="pagination__item pagination__item--prev" href="/tags/leetcode/page/6/">Prev</a>
        <span class="pagination__item pagination__item--current">7/21</span>
            <a class="pagination__item pagination__item--next" href="/tags/leetcode/page/8/">Next</a>
    </div>

    </div>

        </div><script src="/js/highlight.min.js"></script>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre").forEach((block) => {
            hljs.highlightBlock(block);
        });
        
        
        
        
        
        
        
        
        
        
    });
</script>
</body>
</html>
