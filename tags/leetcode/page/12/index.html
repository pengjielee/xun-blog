<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body><div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="page-title">leetcode</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/draft/leetcode/_140.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii/">140</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/">139</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/138.%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/">138.复制带随机指针的链表</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random &ndash;&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random &ndash;&gt; y 。
返回复制链表的头节点。
用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2：
输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_134.%E5%8A%A0%E6%B2%B9%E7%AB%99/">134</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_133.%E5%85%8B%E9%9A%86%E5%9B%BE/">133</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2ii/">132</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/">131</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_146.lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">146</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/">150</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_149.%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/">149</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_147.%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">147</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99ii/">126.单词接龙II</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; &hellip; -&gt; sk 这样的单词序列，并满足：
每对相邻的单词之间仅有单个字母不同。 转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。 sk == endWord 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, &hellip;, sk] 的形式返回。
示例 1： 输入：beginWord = &#34;hit&#34;, endWord = &#34;cog&#34;, wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;,&#34;cog&#34;] 输出：[[&#34;hit&#34;,&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;cog&#34;],[&#34;hit&#34;,&#34;hot&#34;,&#34;lot&#34;,&#34;log&#34;,&#34;cog&#34;]] 解释：存在 2 种最短的转换序列： &#34;hit&#34; -&gt; &#34;hot&#34; -&gt; &#34;dot&#34; -&gt; &#34;dog&#34; -&gt; &#34;cog&#34; &#34;hit&#34; -&gt; &#34;hot&#34; -&gt; &#34;lot&#34; -&gt; &#34;log&#34; -&gt; &#34;cog&#34; 示例 2： 输入：beginWord = &#34;hit&#34;, endWord = &#34;cog&#34;, wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;] 输出：[] 解释：endWord &#34;cog&#34; 不在字典 wordList 中，所以不存在符合要求的转换序列。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_123._%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii/">123.买卖股票的最佳时机III</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/stock/" rel="tag">stock</a>
        </div>
</div>

        <p class="summary">题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 输入：prices = [1] 输出：0 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/">130.被围绕的区域</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个 m x n 的矩阵 board ，由若干字符 &lsquo;X&rsquo; 和 &lsquo;O&rsquo; ，找到所有被 &lsquo;X&rsquo; 围绕的区域，并将这些区域里所有的 &lsquo;O&rsquo; 用 &lsquo;X&rsquo; 填充。 示例 1： &#34;X&#34;,&#34;X&#34;,&#34;X&#34;,&#34;X&#34; &#34;X&#34;,&#34;O&#34;,&#34;O&#34;,&#34;X&#34; &#34;X&#34;,&#34;X&#34;,&#34;O&#34;,&#34;X&#34; &#34;X&#34;,&#34;O&#34;,&#34;X&#34;,&#34;X&#34; || &#34;X&#34;,&#34;X&#34;,&#34;X&#34;,&#34;X&#34; &#34;X&#34;,&#34;X&#34;,&#34;X&#34;,&#34;X&#34; &#34;X&#34;,&#34;X&#34;,&#34;X&#34;,&#34;X&#34; &#34;X&#34;,&#34;O&#34;,&#34;X&#34;,&#34;X&#34; 输入：board = [[&#34;X&#34;,&#34;X&#34;,&#34;X&#34;,&#34;X&#34;],[&#34;X&#34;,&#34;O&#34;,&#34;O&#34;,&#34;X&#34;],[&#34;X&#34;,&#34;X&#34;,&#34;O&#34;,&#34;X&#34;],[&#34;X&#34;,&#34;O&#34;,&#34;X&#34;,&#34;X&#34;]] 输出：[[&#34;X&#34;,&#34;X&#34;,&#34;X&#34;,&#34;X&#34;],[&#34;X&#34;,&#34;X&#34;,&#34;X&#34;,&#34;X&#34;],[&#34;X&#34;,&#34;X&#34;,&#34;X&#34;,&#34;X&#34;],[&#34;X&#34;,&#34;O&#34;,&#34;X&#34;,&#34;X&#34;]] 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#39;O&#39; 都不会被填充为 &#39;X&#39;。 任何不在边界上，或不与边界上的 &#39;O&#39; 相连的 &#39;O&#39; 最终都会被填充为 &#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 示例 2： 输入：board = [[&#34;X&#34;]] 输出：[[&#34;X&#34;]] 提示：
m == board.length n == board[i].length 1 &lt;= m, n &lt;= 200 board[i][j] 为 &lsquo;X&rsquo; 或 &lsquo;O&rsquo; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/surrounded-regions 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/">129.求根节点到叶节点数字之和</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。 每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。
示例 1： 1 / \	2 3 输入：root = [1,2,3] 输出：25 解释： 从根到叶子节点路径 1-&gt;2 代表数字 12 从根到叶子节点路径 1-&gt;3 代表数字 13 因此，数字总和 = 12 + 13 = 25 示例 2： 4 / \ 9 0	/ \ 5 1 输入：root = [4,9,0,5,1] 输出：1026 解释： 从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495 从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491 从根到叶子节点路径 4-&gt;0 代表数字 40 因此，数字总和 = 495 + 491 + 40 = 1026 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/">128.最长连续序列</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
示例 1： 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 提示：
0 &lt;= nums.length &lt;= 10^5 -10^9 &lt;= nums[i] &lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-consecutive-sequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var longestConsecutive = function(nums) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/">127.单词接龙</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：
序列中第一个单词是 beginWord 。 序列中最后一个单词是 endWord 。 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典 wordList 中的单词。 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。
示例 1： 输入：beginWord = &#34;hit&#34;, endWord = &#34;cog&#34;, wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;,&#34;cog&#34;] 输出：5 解释：一个最短转换序列是 &#34;hit&#34; -&gt; &#34;hot&#34; -&gt; &#34;dot&#34; -&gt; &#34;dog&#34; -&gt; &#34;cog&#34;, 返回它的长度 5。 示例 2： 输入：beginWord = &#34;hit&#34;, endWord = &#34;cog&#34;, wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;] 输出：0 解释：endWord &#34;cog&#34; 不在字典中，所以无法进行转换。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/194.%E8%BD%AC%E7%BD%AE%E6%96%87%E4%BB%B6/">194.转置文件</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/bash/" rel="tag">bash</a>
        </div>
</div>

        <p class="summary">题目 给定一个文件 file.txt，转置它的内容。
你可以假设每行列数相同，并且每个字段由 &rsquo; &rsquo; 分隔。
示例：
假设 file.txt 文件内容如下：
name age alice 21 ryan 30 应当输出：
name alice ryan age 21 30 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/transpose-file 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 COUNT=`head -1 file.txt | wc -w` for (( i = 1; i &lt;= $COUNT; i++ )); do awk -v arg=$i &#39;{print $arg}&#39; file.txt | xargs done </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/193.%E6%9C%89%E6%95%88%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/">193.有效电话号码</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/bash/" rel="tag">bash</a>
        </div>
</div>

        <p class="summary">题目 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。
你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）
你也可以假设每行前后没有多余的空格字符。
示例：
假设 file.txt 内容如下：
987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码：
987-123-4567 (123) 456-7890 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-phone-numbers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 awk &#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/&#39; file.txt or gawk &#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/&#39; file.txt </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/192.%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91/">192.统计词频</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/bash/" rel="tag">bash</a>
        </div>
</div>

        <p class="summary">题目 写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。
为了简单起见，你可以假设：
words.txt只包括小写字母和 &rsquo; &rsquo; 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。 示例:
假设 words.txt 内容如下：
the day is sunny the the the sunny is 你的脚本应当输出（以词频降序排列）：
the 4 is 3 sunny 2 day 1 说明:
不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。 你可以使用一行 Unix pipes 实现吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/word-frequency 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 cat words.txt | tr -s &#39; &#39; &#39;\n&#39; | sort | uniq -c | sort -r | awk &#39;{print $2,$1}&#39; or cat words.txt | xargs -n 1 | sort | uniq -c | sort -nr | awk &#39;{print $2&#34; &#34;$1}&#39; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/191._%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/">191.位1的个数</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &lsquo;1&rsquo; 的个数（也被称为汉明重量）。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。 示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。 示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。 提示：
输入必须是长度为 32 的 二进制串 。 进阶：
如果多次调用这个函数，你将如何优化你的算法？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-1-bits 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n - a positive integer * @return {number} */ var hammingWeight = function(n) { let ret = 0; for (let i = 0; i &lt; 32; i++) { if ((n &amp; (1 &lt;&lt; i)) !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_190.%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/">190.颠倒二进制位</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 颠倒给定的 32 位无符号整数的二进制位。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
进阶: 如果多次调用这个函数，你将如何优化你的算法？
示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 示例 1： 输入：n = 00000010100101000001111010011100 输出：964176192 (00111001011110000010100101000000) 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：n = 11111111111111111111111111111101 输出：3221225471 (10111111111111111111111111111111) 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_188._%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiv/">188.买卖股票的最佳时机IV</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/stock/" rel="tag">stock</a>
        </div>
</div>

        <p class="summary">题目 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_187.%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%BA%8F%E5%88%97/">187.重复的DNA序列</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 所有 DNA 都由一系列缩写为 &lsquo;A&rsquo;，&lsquo;C&rsquo;，&lsquo;G&rsquo; 和 &lsquo;T&rsquo; 的核苷酸组成，例如：&ldquo;ACGAATTCCG&rdquo;。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。
编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。 示例 1： 输入：s = &#34;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&#34; 输出：[&#34;AAAAACCCCC&#34;,&#34;CCCCCAAAAA&#34;] 示例 2： 输入：s = &#34;AAAAAAAAAAAAA&#34; 输出：[&#34;AAAAAAAAAA&#34;] 提示：
0 &lt;= s.length &lt;= 105 s[i] 为 &lsquo;A&rsquo;、&lsquo;C&rsquo;、&lsquo;G&rsquo; 或 &lsquo;T&rsquo; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/repeated-dna-sequences 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {string[]} */ var findRepeatedDnaSequences = function(s) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_186._%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8Dii/">186.翻转字符串里的单词II</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_185.%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5/">185.部门工资前三高的所有员工</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sql/" rel="tag">sql</a>
        </div>
</div>

        <p class="summary">题目 Employee 表包含所有员工信息，每个员工有其对应的工号 Id，姓名 Name，工资 Salary 和部门编号 DepartmentId 。
+----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 85000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | | 5 | Janet | 69000 | 1 | | 6 | Randy | 85000 | 1 | | 7 | Will | 70000 | 1 | +----+-------+--------+--------------+ Department 表包含公司所有部门的信息。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/184.%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/">184.部门工资最高的员工</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sql/" rel="tag">sql</a>
        </div>
</div>

        <p class="summary">题目 Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。
+----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Jim | 90000 | 1 | | 3 | Henry | 80000 | 2 | | 4 | Sam | 60000 | 2 | | 5 | Max | 90000 | 1 | +----+-------+--------+--------------+ Department 表包含公司所有部门的信息。
+----+----------+ | Id | Name | +----+----------+ | 1 | IT | | 2 | Sales | +----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/183.%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/">183.从不订购的客户</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sql/" rel="tag">sql</a>
        </div>
</div>

        <p class="summary">题目 某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。
Customers 表：
+----+-------+ | Id | Name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders 表：
+----+------------+ | Id | CustomerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ 例如给定上述表格，你的查询应返回：
+-----------+ | Customers | +-----------+ | Henry | | Max | +-----------+ 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/182.%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/">182.查找重复的电子邮箱</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sql/" rel="tag">sql</a>
        </div>
</div>

        <p class="summary">题目 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。
示例：
+----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ 根据以上输入，你的查询应返回以下结果：
+---------+ | Email | +---------+ | a@b.com | +---------+ 说明：所有电子邮箱都是小写字母。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/duplicate-emails 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 实现1：
select Email from ( select Email, count(Email) as num from Person group by Email ) as statistic where num &gt; 1; 实现2：
select Email from Person group by Email having count(Email) &gt; 1; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/181.%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/">181.超过经理收入的员工</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sql/" rel="tag">sql</a>
        </div>
</div>

        <p class="summary">题目 Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。
+----+-------+--------+-----------+ | Id | Name | Salary | ManagerId | +----+-------+--------+-----------+ | 1 | Joe | 70000 | 3 | | 2 | Henry | 80000 | 4 | | 3 | Sam | 60000 | NULL | | 4 | Max | 90000 | NULL | +----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。
+----------+ | Employee | +----------+ | Joe | +----------+ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/employees-earning-more-than-their-managers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/180.%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/">180.连续出现的数字</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sql/" rel="tag">sql</a>
        </div>
</div>

        <p class="summary">题目 表：Logs
+-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | num | varchar | +-------------+---------+ id 是这个表的主键。 编写一个 SQL 查询，查找所有至少连续出现三次的数字。
返回的结果表中的数据可以按 任意顺序 排列。
查询结果格式如下面的例子所示：
Logs 表： +----+-----+ | Id | Num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ Result 表：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_179.%E6%9C%80%E5%A4%A7%E6%95%B0/">179</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_178.%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/">178</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_177.%E7%AC%ACn%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/">177</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_176.%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/">176</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_175.%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/">175</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_174.%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/">174</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/">173</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_172.%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/">172.阶乘后的零</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个整数 n，返回 n! 结果尾数中零的数量。
示例 1: 输入: 3 输出: 0 解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5 输出: 1 解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var trailingZeroes = function(n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_171.excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/">171.Excel表列序号</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个Excel表格中的列名称，返回其相应的列序号。
例如，
A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... 示例 1: 输入: &#34;A&#34; 输出: 1 示例 2: 输入: &#34;AB&#34; 输出: 28 示例 3: 输入: &#34;ZY&#34; 输出: 701 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/excel-sheet-column-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} columnTitle * @return {number} */ var titleToNumber = function(columnTitle) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_168.excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/">168.Excel表列名称</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。
例如：
A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... 示例 1： 输入：columnNumber = 1 输出：&#34;A&#34; 示例 2： 输入：columnNumber = 28 输出：&#34;AB&#34; 示例 3： 输入：columnNumber = 701 输出：&#34;ZY&#34; 示例 4： 输入：columnNumber = 2147483647 输出：&#34;FXSHRXW&#34; 提示：
1 &lt;= columnNumber &lt;= 2^31 - 1
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/excel-sheet-column-title 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} columnNumber * @return {string} */ var convertToTitle = function(columnNumber) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_166.%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/">166.分数到小数</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。
如果小数部分为循环小数，则将循环的部分括在括号内。
如果存在多个答案，只需返回 任意一个 。
对于所有给定的输入，保证 答案字符串的长度小于 104 。
示例 1： 输入：numerator = 1, denominator = 2 输出：&#34;0.5&#34; 示例 2： 输入：numerator = 2, denominator = 1 输出：&#34;2&#34; 示例 3： 输入：numerator = 2, denominator = 3 输出：&#34;0.(6)&#34; 示例 4： 输入：numerator = 4, denominator = 333 输出：&#34;0.(012)&#34; 示例 5： 输入：numerator = 1, denominator = 5 输出：&#34;0.2&#34; 提示：
-2^31 &lt;= numerator, denominator &lt;= 2^31 - 1 denominator !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_165.%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/">165.比较版本号</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你两个版本号 version1 和 version2 ，请你比较它们。
版本号由一个或多个修订号组成，各修订号由一个 &lsquo;.&rsquo; 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。
返回规则如下：
如果 version1 &gt; version2 返回 1， 如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 示例 1： 输入：version1 = &#34;1.01&#34;, version2 = &#34;1.001&#34; 输出：0 解释：忽略前导零，&#34;01&#34; 和 &#34;001&#34; 都表示相同的整数 &#34;1&#34; 示例 2： 输入：version1 = &#34;1.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_164.%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D/">164.最大间距</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。
如果数组元素个数小于 2，则返回 0。
示例 1: 输入: [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 输入: [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 说明:
你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-gap 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var maximumGap = function(nums) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_162.%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/">162.寻找峰值</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 峰值元素是指其值大于左右相邻值的元素。
给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞ 。
示例 1： 输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2： 输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示：
1 &lt;= nums.length &lt;= 1000 -231 &lt;= nums[i] &lt;= 231 - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] 进阶：你可以实现时间复杂度为 O(logN) 的解决方案吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-peak-element 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var findPeakElement = function(nums) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/195.%E7%AC%AC%E5%8D%81%E8%A1%8C/">195.第十行</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/bash/" rel="tag">bash</a>
        </div>
</div>

        <p class="summary">题目 给定一个文本文件 file.txt，请只打印这个文件中的第十行。
示例:
假设 file.txt 有如下内容：
Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10 你的脚本应当显示第十行：
Line 10 说明:
如果文件少于十行，你应当输出什么？ 至少有三种不同的解法，请尝试尽可能多的方法来解题。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/tenth-line 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 sed -n &#34;10p&#34; file.txt or awk &#39;{if(NR==10){print $0}}&#39; file.txt or grep -n &#34;&#34; file.txt | grep -w &#39;10&#39; | cut -d: -f2 不足10行
row_num=$(cat file.txt | wc -l) echo $row_num if [ $row_num -lt 10 ];then echo &#34;The number of row is less than 10&#34; else awk &#39;{if(NR==10){print $0}}&#39; file.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/196.%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/">196</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sql/" rel="tag">sql</a>
        </div>
</div>

        <p class="summary">题目 编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。
+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:
+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+ 提示：
执行 SQL 之后，输出是整个 Person 表。 使用 delete 语句。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/delete-duplicate-emails 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 DELETE p1 FROM Person p1, Person p2 WHERE p1.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/197.%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6/">197.上升的温度</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sql/" rel="tag">sql</a>
        </div>
</div>

        <p class="summary">题目 表 Weather
+---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | recordDate | date | | temperature | int | +---------------+---------+ id 是这个表的主键 该表包含特定日期的温度信息 编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。
返回结果 不要求顺序 。
查询结果格式如下例：
Weather +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ Result table: +----+ | id | +----+ | 2 | | 4 | +----+ 2015-01-02 的温度比前一天高（10 -&gt; 25） 2015-01-04 的温度比前一天高（20 -&gt; 30） 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">200.岛屿数量</a>
    </div><div class="post-meta">
    <div class="date">2021-07-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个由 &lsquo;1&rsquo;（陆地）和 &lsquo;0&rsquo;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
示例 1： 输入：grid = [ [&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;0&#34;], [&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;], [&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;], [&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;] ] 输出：1 示例 2： 输入：grid = [ [&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;], [&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;], [&#34;0&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;], [&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;1&#34;,&#34;1&#34;] ] 输出：3 提示：
m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] 的值为 &lsquo;0&rsquo; 或 &lsquo;1&rsquo; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-islands 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。
为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。
最终岛屿的数量就是我们进行深度优先搜索的次数。
作者：LeetCode 链接：https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {character[][]} grid * @return {number} */ var dfs = (grid, r, c) =&gt; { const rows = grid.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/">120.三角形最小路径和</a>
    </div><div class="post-meta">
    <div class="date">2021-07-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
示例 1： 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 示例 2： 输入：triangle = [[-10]] 输出：-10 提示：
1 &lt;= triangle.length &lt;= 200 triangle[0].length == 1 triangle[i].length == triangle[i - 1].length + 1 -10^4 &lt;= triangle[i][j] &lt;= 10^4 进阶：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92ii/">119.杨辉三角II</a>
    </div><div class="post-meta">
    <div class="date">2021-07-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。
在杨辉三角中，每个数是它左上方和右上方的数的和。
示例:
输入: 3 输出: [1,3,3,1]
进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pascals-triangle-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} rowIndex * @return {number[]} */ var getRow = function (rowIndex) { //性质2：第 n 行（从 0 开始编号）的数字有 n+1 项 const C = new Array(rowIndex + 1).fill(0); for (let i = 0; i &lt;= rowIndex; i++) { C[i] = new Array(i + 1).fill(0); //性质1：每行数字左右对称，由 1 开始逐渐变大再变小，并最终回到 1 C[i][0] = C[i][i] = 1; //性质4：每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n−1 行的第 i−1 个数和第 i 个数之和。 for (let j = 1; j &lt; i; j++) { C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; } } return C[rowIndex]; }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/">118.杨辉三角</a>
    </div><div class="post-meta">
    <div class="date">2021-07-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
在杨辉三角中，每个数是它左上方和右上方的数的和。
示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ]
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pascals-triangle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 杨辉三角具有以下性质：
每行数字左右对称，由 1 开始逐渐变大再变小，并最终回到 1； 第 n 行（从 0 开始编号）的数字有 n+1 项，前 n 行共有 n(n+1)/2 个数； 第 n 行的第 m 个数（从 0 开始编号）可表示为可以被表示为组合数 C(n,m)，即为从 n 个不同元素中取 m 个元素的组合数； 每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n−1 行的第 i−1 个数和第 i 个数之和。 (a+b)^n的展开式（二项式展开）中的各项系数依次对应杨辉三角的第 n 行中的每一项。 依据性质 4，我们可以一行一行地计算杨辉三角。每当我们计算出第 i 行的值，我们就可以在线性时间复杂度内计算出第 i+1 行的值。
作者：LeetCode-Solution 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">109.有序链表转换二叉搜索树</a>
    </div><div class="post-meta">
    <div class="date">2021-07-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 将给定的有序链表转换为二叉搜索树的第一步是确定根节点。 如何找出这样的一个根节点呢？我们可以找出链表元素的中位数作为根节点的值。
这里对于中位数的定义为：如果链表中的元素个数为奇数，那么唯一的中间值为中位数；如果元素个数为偶数，那么唯二的中间值都可以作为中位数，而不是常规定义中二者的平均值。
根据中位数的性质，链表中小于中位数的元素个数与大于中位数的元素个数要么相等，要么相差 1。此时，小于中位数的元素组成了左子树，大于中位数的元素组成了右子树，它们分别对应着有序链表中连续的一段。
在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中位数作为根节点，以此类推。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * Definition for a binary tree node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">110.平衡二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
示例 1： 3 / \ 9 20 / \ 15 7 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 1 / \ 2 2 / \ 3 3 / \ 4 4 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 提示：
树中的节点数在范围 [0, 5000] 内 -10^4 &lt;= Node.val &lt;= 10^4
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/balanced-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1：自顶向下的递归
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_087.%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/">087.扰乱字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止； 如果字符串的长度 &gt; 1 ，执行下述步骤： 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。
示例 1： 输入：s1 = &#34;great&#34;, s2 = &#34;rgeat&#34; 输出：true 解释：s1 上可能发生的一种情形是： &#34;great&#34; --&gt; &#34;gr/eat&#34; // 在一个随机下标处分割得到两个子字符串 &#34;gr/eat&#34; --&gt; &#34;gr/eat&#34; // 随机决定：「保持这两个子字符串的顺序不变」 &#34;gr/eat&#34; --&gt; &#34;g/r / e/at&#34; // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割 &#34;g/r / e/at&#34; --&gt; &#34;r/g / e/at&#34; // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」 &#34;r/g / e/at&#34; --&gt; &#34;r/g / e/ a/t&#34; // 继续递归执行此算法，将 &#34;at&#34; 分割得到 &#34;a/t&#34; &#34;r/g / e/ a/t&#34; --&gt; &#34;r/g / e/ a/t&#34; // 随机决定：「保持这两个子字符串的顺序不变」 算法终止，结果字符串和 s2 相同，都是 &#34;rgeat&#34; 这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true 示例 2： 输入：s1 = &#34;abcde&#34;, s2 = &#34;caebd&#34; 输出：false 示例 3： 输入：s1 = &#34;a&#34;, s2 = &#34;a&#34; 输出：true 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/058.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/">058.最后一个单词的长度</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
示例 1： 输入：s = &#34;Hello World&#34; 输出：5 示例 2： 输入：s = &#34; &#34; 输出：0 提示：
1 &lt;= s.length &lt;= 10^4 s 仅有英文字母和空格 &rsquo; &rsquo; 组成
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/length-of-last-word 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {string} s * @return {number} */ var lengthOfLastWord = function (s) { //获取最后一个字符的下标 let endIndex = s.length - 1; //如果下标大于等于0，并且最后一个字符等于空字符串 while (endIndex &gt;= 0 &amp;&amp; s[endIndex] == &#34; &#34;) { endIndex--; } if (endIndex &lt; 0) { return 0; } let startIndex = endIndex; while (startIndex &gt;= 0 &amp;&amp; s[startIndex] !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/057.%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/">057.插入区间</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。
在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
示例 1： 输入：intervals = [[1,3],[6,9]], newInterval = [2,5] 输出：[[1,5],[6,9]] 示例 2： 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 输出：[[1,2],[3,10],[12,16]] 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 示例 3： 输入：intervals = [], newInterval = [5,7] 输出：[[5,7]] 示例 4： 输入：intervals = [[1,5]], newInterval = [2,3] 输出：[[1,5]] 示例 5： 输入：intervals = [[1,5]], newInterval = [2,7] 输出：[[1,7]] 提示：
0 &lt;= intervals.length &lt;= 10^4 intervals[i].length == 2 0 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 10^5 intervals 根据 intervals[i][0] 按 升序 排列 newInterval.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/">056.合并区间</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/merge/" rel="tag">merge</a>
        </div>
</div>

        <p class="summary">题目 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
示例 1： 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示：
1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= start(i) &lt;= end(i) &lt;= 104 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-intervals 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {number[][]} intervals * @return {number[][]} */ var merge = function (intervals) { const result = []; //对区间的左端点进行排序（升序） intervals.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_091.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/">091.解码方法</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
&#39;A&#39; -&gt; 1 &#39;B&#39; -&gt; 2 ... &#39;Z&#39; -&gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&ldquo;11106&rdquo; 可以映射为：
&#34;AAJF&#34; ，将消息分组为 (1 1 10 6) &#34;KJF&#34; ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 &ldquo;06&rdquo; 不能映射为 &ldquo;F&rdquo; ，这是由于 &ldquo;6&rdquo; 和 &ldquo;06&rdquo; 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
示例 1： 输入：s = &#34;12&#34; 输出：2 解释：它可以解码为 &#34;AB&#34;（1 2）或者 &#34;L&#34;（12）。 示例 2： 输入：s = &#34;226&#34; 输出：3 解释：它可以解码为 &#34;BZ&#34; (2 26), &#34;VF&#34; (22 6), 或者 &#34;BBF&#34; (2 2 6) 。 示例 3： 输入：s = &#34;0&#34; 输出：0 解释：没有字符映射到以 0 开头的数字。 含有 0 的有效映射是 &#39;J&#39; -&gt; &#34;10&#34; 和 &#39;T&#39;-&gt; &#34;20&#34; 。 由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。 示例 4： 输入：s = &#34;06&#34; 输出：0 解释：&#34;06&#34; 不能映射到 &#34;F&#34; ，因为字符串含有前导 0（&#34;6&#34; 和 &#34;06&#34; 在映射中并不等价）。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/093.%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/">093.复原IP地址</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/097.%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/">097.交错字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。
两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：
s = s1 + s2 + &hellip; + sn t = t1 + t2 + &hellip; + tm |n - m| &lt;= 1 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + &hellip; 或者 t1 + s1 + t2 + s2 + t3 + s3 + &hellip; 提示：a + b 意味着字符串 a 和 b 连接。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/099.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">099.恢复二叉搜索树</a>
    </div><div class="post-meta">
    <div class="date">2021-07-14</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？
示例 1： 1 / \ 3 null / \ null 2 3 / \ 1 null / \ null 2 输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： 3 / \ 1 4 / \ / null null 2 2 / \ 1 4 / \ / null null 3 输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/016.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">016.最接近的三数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-07-13</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sum/" rel="tag">sum</a>
        </div>
</div>

        <p class="summary">题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例：
输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 提示：
3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum-closest 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number} */ /** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function (nums, target) { if (nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/">189.旋转数组</a>
    </div><div class="post-meta">
    <div class="date">2021-05-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
        </div>
</div>

        <p class="summary">题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 提示：
1 &lt;= nums.length &lt;= 2 * 104 -2^31 &lt;= nums[i] &lt;= 2^31 - 1 0 &lt;= k &lt;= 10^5 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/350._%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86ii/">350.两个数组的交集II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明：
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 1、哈希表
由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。
首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersect = function (nums1, nums2) { const len1 = nums1.length; const len2 = nums2.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">217.存在重复元素</a>
    </div><div class="post-meta">
    <div class="date">2021-05-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {boolean} */ var containsDuplicate = function (nums) { const map = new Map(); for (let i = 0; i &lt; nums.length; i++) { //如果数不存在，设置默认出现次数为0 if (!map.has(nums[i])) { map.set(nums[i], 0); } //如果数已存在，出现次数+1 const number = map.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_007.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/">007.整数反转</a>
    </div><div class="post-meta">
    <div class="date">2021-05-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/math/" rel="tag">math</a>
        </div>
</div>

        <p class="summary">题目 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0 提示：
-2^31 &lt;= x &lt;= 2^31 - 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-integer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 以数字123为例：
1、将123 % 10 得到3，再将123 / 10 2、将12 % 10 得到2，再将12 / 10 3、将1 % 10 得到1，再将1 / 10</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">297.二叉树的序列化与反序列化</a>
    </div><div class="post-meta">
    <div class="date">2021-05-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <p class="summary">题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
示例 1： 输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[1,2] 提示：
树中结点数在范围 [0, 10^4] 内 -1000 &lt;= Node.val &lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。
众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。
1、广度优先搜索可以按照层次的顺序从上到下遍历所有的节点；
2、深度优先搜索可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将深度优先搜索策略区分为：
先序遍历 中序遍历 后序遍历 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/380.%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/">380.常数时间插入、删除和获取随机元素</a>
    </div><div class="post-meta">
    <div class="date">2021-05-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <p class="summary">题目 设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。
insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :
// 初始化一个空的集合。 RandomizedSet randomSet = new RandomizedSet(); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。 randomSet.insert(1); // 返回 false ，表示集合中不存在 2 。 randomSet.remove(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。 randomSet.insert(2); // getRandom 应随机返回 1 或 2 。 randomSet.getRandom(); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。 randomSet.remove(1); // 2 已在集合中，所以返回 false 。 randomSet.insert(2); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。 randomSet.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/">322.零钱兑换</a>
    </div><div class="post-meta">
    <div class="date">2021-05-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
你可以认为每种硬币的数量是无限的。
示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 输入：coins = [2], amount = 3 输出：-1 示例 3： 输入：coins = [1], amount = 0 输出：0 示例 4： 输入：coins = [1], amount = 1 输出：1 示例 5： 输入：coins = [1], amount = 2 输出：2 提示：
1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 2^31 - 1 0 &lt;= amount &lt;= 10^4 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/">300.最长递增子序列</a>
    </div><div class="post-meta">
    <div class="date">2021-05-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1 提示：
1 &lt;= nums.length &lt;= 2500 -10^4 &lt;= nums[i] &lt;= 10^4 进阶：
你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗? 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-increasing-subsequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 子序列和子串：
子序列（subsequence）：子序列并不要求连续，例如：序列 [4, 6, 5] 是 [1, 2, 4, 3, 7, 6, 5] 的一个子序列； 子串（substring、subarray）：子串一定是原始字符串的连续子串。 定义状态：
定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/">062.不同路径</a>
    </div><div class="post-meta">
    <div class="date">2021-05-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
解决： 示例 1： 输入：m = 3, n = 7 输出：28 示例 2： 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向下 示例 3： 输入：m = 7, n = 3 输出：28 示例 4： 输入：m = 3, n = 3 输出：6 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/">055.跳跃游戏</a>
    </div><div class="post-meta">
    <div class="date">2021-05-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
示例 1： 输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示：
1 &lt;= nums.length &lt;= 3 * 10^4 0 &lt;= nums[i] &lt;= 10^5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jump-game 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {number[]} nums * @return {boolean} */ var canJump = function (nums) { //数组的长度 const n = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_739._%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/">739.每日温度</a>
    </div><div class="post-meta">
    <div class="date">2021-05-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如， 给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]， 你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/daily-temperatures 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} T * @return {number[]} */ var dailyTemperatures = function(T) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/">018.四数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-05-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sum/" rel="tag">sum</a>
        </div>
</div>

        <p class="summary">题目 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
注意：答案中不可以包含重复的四元组。
示例 1： 输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 输入：nums = [], target = 0 输出：[] 提示：
0 &lt;= nums.length &lt;= 200 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/4sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number[][]} */ var fourSum = function (nums, target) { const result = [``]; //如果小于4个数，直接返回空数组 if (nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/690.%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/">690.员工的重要性</a>
    </div><div class="post-meta">
    <div class="date">2021-05-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。
比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。
示例：
输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 输出：11 解释： 员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/">199.二叉树的右视图</a>
    </div><div class="post-meta">
    <div class="date">2021-05-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
        </div>
</div>

        <p class="summary">题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例:
输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 &lt;--- / \ 2 3 &lt;--- \ \ 5 4 &lt;--- 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-right-side-view 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、BFS
利用BFS进行层次遍历，记录下每层的最后一个元素。
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var rightSideView = function (root) { const result = []; if (root === null) { return result; } //队列特点：先进先出 const q = []; //入队根节点 q.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/">279.完全平方数</a>
    </div><div class="post-meta">
    <div class="date">2021-05-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, &hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9 提示：
1 &lt;= n &lt;= 10^4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/perfect-squares 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 我们将问题重新表述成：
给定一个完全平方数列表和正整数 n，求出完全平方数组合成 n 的组合，要求组合中的解拥有完全平方数的最小个数。
注：可以重复使用列表中的完全平方数。
作者：LeetCode 链接：https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var numSquares = function(n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/771.%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/">771.宝石与石头</a>
    </div><div class="post-meta">
    <div class="date">2021-05-11</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 给定字符串 J 代表石头中宝石的类型，和字符串 S 代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J 中的字母不重复，J 和 S 中的所有字符都是字母。字母区分大小写，因此&quot;a&quot;和&quot;A&quot;是不同类型的石头。
示例 1: 输入: J = &#34;aA&#34;, S = &#34;aAAbbbb&#34; 输出: 3 示例 2: 输入: J = &#34;z&#34;, S = &#34;ZZ&#34; 输出: 0 注意:
S 和 J 最多含有50个字母。 J 中的字符不重复。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jewels-and-stones 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} jewels * @param {string} stones * @return {number} */ var numJewelsInStones = function (jewels, stones) { // 转换为Set const jewelsSet = new Set(jewels.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/535.tinyurl%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/">535.TinyURL的加密与解密</a>
    </div><div class="post-meta">
    <div class="date">2021-05-11</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 TinyURL是一种URL简化服务， 比如：当你输入一个URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk.
要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/encode-and-decode-tinyurl 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Encodes a URL to a shortened URL. * * @param {string} longUrl * @return {string} */ /** * Decodes a shortened URL to its original URL. * * @param {string} shortUrl * @return {string} */ var i = 0; var map = new Map(); var encode = function (longUrl) { map.set(i, longUrl); return &#34;http://tinyurl.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/463.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/">463.岛屿的周长</a>
    </div><div class="post-meta">
    <div class="date">2021-05-11</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。
网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
示例 1： 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] 输出：16 解释：它的周长是上面图片中的 16 个黄色的边 示例 2： 输入：grid = [[1]] 输出：4 示例 3： 输入：grid = [[1,0]] 输出：4 提示：
row == grid.length col == grid[i].length 1 &lt;= row, col &lt;= 100 grid[i][j] 为 0 或 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/island-perimeter 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 1）加入答案 ans 中即可。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/">617.合并二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-05-11</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
示例 1:
输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-binary-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/064.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/">064.最小路径和</a>
    </div><div class="post-meta">
    <div class="date">2021-05-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示：
m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 1、设置状态。
令dp[i][j]表示走到(i,j)点的最小路径和。
2、状态转移方程。
如何求出dp[i][j]？
由于每次只能往右走或者下走。换言之，当前单元格dp[i][j]的前继状态只有dp[i-1][j],dp[i][j-1]，所以我们在两者取最小，然后加上当前格子内的数即可。
走到当前单元格(i,j)的最小路径和 = 【从左方单元格 (i-1,j) 与 从上方单元格 (i,j−1) 走来的 两个最小路径和中较小的】 + 当前单元格值 grid[i][j]
dp(i,j) = grid(i,j) + min(dp(i-1,j),dp(i,j-1)) 具体分以下4种情况:
当左边和上边都不是矩阵边界时：即 i!</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_137.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97ii/">137.只出现一次的数字II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/bit/" rel="tag">bit</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
示例 1： 输入：nums = [2,2,3,2] 输出：3 示例 2： 输入：nums = [0,1,0,1,0,1,99] 输出：99 提示：
1 &lt;= nums.length &lt;= 3 * 10^4 -2^31 &lt;= nums[i] &lt;= 2^31 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-number-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/">125.验证回文串</a>
    </div><div class="post-meta">
    <div class="date">2021-05-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1: 输入: &#34;A man, a plan, a canal: Panama&#34; 输出: true 示例 2: 输入: &#34;race a car&#34; 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
知识点 charCodeAt()
charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
charAt()
方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。
&#39;a&#39;.charCodeAt(); //97 &#39;b&#39;.charCodeAt(); //98 ... &#39;z&#39;.charCodeAt(); //122 (97+26-1=122) &#39;A&#39;.charCodeAt(); //65 &#39;B&#39;.charCodeAt(); //66 ... &#39;Z&#39;.charCodeAt(); //90 (65+26-1=90) &#39;0&#39;.charCodeAt(); //48 &#39;1&#39;.charCodeAt(); //49 &#39;9&#39;.charCodeAt(); //57 (48+10-1=57) JS实现 /** * @param {string} s * @return {boolean} */ var isPalindrome = (str) =&gt; { // 字符串转为小写 str = str.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/">154.寻找旋转排序数组中的最小值II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], &hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], &hellip;, a[n-2]] 。
给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
示例 1： 输入：nums = [1,3,5] 输出：1 示例 2： 输入：nums = [2,2,2,0,1] 输出：0 提示：
n == nums.length 1 &lt;= n &lt;= 5000 -5000 &lt;= nums[i] &lt;= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/153.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/">153.寻找旋转排序数组中的最小值</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], &hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], &hellip;, a[n-2]] 。
给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
示例 1： 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2： 输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3： 输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">033.搜索旋转排序数组</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], &hellip;, nums[n-1], nums[0], nums[1], &hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2： 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3： 输入：nums = [1], target = 0 输出：-1 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/081.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/">081.搜索旋转排序数组II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], &hellip;, nums[n-1], nums[0], nums[1], &hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
示例 1： 输入：nums = [2,5,6,0,0,1,2], target = 0 输出：true 示例 2： 输入：nums = [2,5,6,0,0,1,2], target = 3 输出：false 提示：
1 &lt;= nums.length &lt;= 5000 -10^4 &lt;= nums[i] &lt;= 10^4 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -10^4 &lt;= target &lt;= 10^4 进阶：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/">034.在排序数组中查找元素的第一个和最后一个位置</a>
    </div><div class="post-meta">
    <div class="date">2021-05-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例：
示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示：
0 &lt;= nums.length &lt;= 10^5 -10^9 &lt;= nums[i] &lt;= 10^9 nums 是一个非递减数组 -10^9 &lt;= target &lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、
/** * @param {number[]} nums * @param {number} target * @return {number[]} */ // 查找第一个等于给定值的元素 const binarySearchFirst = (arr, target) =&gt; { let low = 0, high = arr.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_029.%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/">029.两数相除</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1: 输入: dividend = 10, divisor = 3 输出: 3 解释: 10/3 = truncate(3.33333..) = truncate(3) = 3 示例 2: 输入: dividend = 7, divisor = -3 输出: -2 解释: 7/-3 = truncate(-2.33333..) = -2 提示：
被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_413.%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/">413.等差数列划分</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。
例如
以下数列为等差数列: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 以下数列不是等差数列。 1, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。
如果满足以下条件，则称子数组(P, Q)为等差数组：
元素 A[P], A[p + 1], &hellip;, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。
函数要返回数组 A 中所有为等差数组的子数组个数。
示例:
A = [1, 2, 3, 4] 返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/">406.根据身高重建队列</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_665.%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/">665.非递减数列</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。
示例 1: 输入: nums = [4,2,3] 输出: true 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 输入: nums = [4,2,1] 输出: false 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 提示：
1 &lt;= n &lt;= 10 ^ 4 -10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-decreasing-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {boolean} */ var checkPossibility = function(nums) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/540.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/">540.有序数组中的单一元素</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
示例 1: 输入: [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2: 输入: [3,3,7,7,10,11,11] 输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、位运算
/** * @param {number[]} nums * @return {number} */ var singleNonDuplicate = function (nums) { let result = nums[0]; for (let i = 1; i &lt; nums.length; i++) { result = result ^ nums[i]; } return result; }; 2、二分搜索
我们的数组个数始终是奇数，因为有一个元素出现一次，其余元素出现两次。
var singleNonDuplicate = function (nums) { let low = 0, high = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_076.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/">076.最小覆盖子串</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sliding-window/" rel="tag">sliding-window</a>
        </div>
</div>

        <p class="summary">题目 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。
注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。
示例 1： 输入：s = &#34;ADOBECODEBANC&#34;, t = &#34;ABC&#34; 输出：&#34;BANC&#34; 示例 2： 输入：s = &#34;a&#34;, t = &#34;a&#34; 输出：&#34;a&#34; 提示：
1 &lt;= s.length, t.length &lt;= 10^5 s 和 t 由英文字母组成 进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-window-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/633.%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/">633.平方数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/math/" rel="tag">math</a>
        </div>
</div>

        <p class="summary">题目 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c 。
示例 1： 输入：c = 5 输出：true 解释：1 * 1 + 2 * 2 = 5 示例 2： 输入：c = 3 输出：false 示例 3： 输入：c = 4 输出：true 解释：0 * 0 + 2 * 2 = 4 示例 4： 输入：c = 2 输出：true 解释：1 * 1 + 1 * 1= 2 示例 5： 输入：c = 1 输出：true 解释：0 * 0 + 1 * 1 = 1 提示： 0 &lt;= c &lt;= 2^31 - 1</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/680.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/">680.验证回文字符串II</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
示例 1: 输入: &#34;aba&#34; 输出: True 示例 2: 输入: &#34;abca&#34; 输出: True 解释: 你可以删除c字符。 注意:
字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {boolean} */ var validPalindrome = function (s) { // 双指针，一个指向字符串开头，一个指向字符串末尾 let i = 0, j = s.length - 1; // 判断是否是回文串 const isPalindrome = (low, high) =&gt; { while (low &lt; high) { if (s.charAt(low) != s.charat(high)) { return false; } low++; high--; } return true; }; while (i &lt; j) { // 字符串开头与末尾不相等 if (s.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/524._%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/">524.通过删除字母匹配到字典里最长单词</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。
示例 1: 输入: s = &#34;abpcplea&#34;, d = [&#34;ale&#34;,&#34;apple&#34;,&#34;monkey&#34;,&#34;plea&#34;] 输出: &#34;apple&#34; 示例 2: 输入: s = &#34;abpcplea&#34;, d = [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;] 输出: &#34;a&#34; 说明:
所有输入的字符串只包含小写字母。 字典的大小不会超过 1000。 所有输入的字符串长度不会超过 1000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @param {string[]} dictionary * @return {string} */ var findLongestWord = function (s, dictionary) { let result = &#34;&#34;; // 遍历字典 for (let dstr of dictionary) { // 定义两个指针i,j，i用来指向整个字符串s，j用来指向字符串dstr for (let i = 0, j = 0; i &lt; s.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/004.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">004.寻找两个正序数组的中位数</a>
    </div><div class="post-meta">
    <div class="date">2021-04-29</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/mergesort/" rel="tag">mergesort</a>
        </div>
</div>

        <p class="summary">题目 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/451.%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/">451.根据字符出现频率排序</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
        </div>
</div>

        <p class="summary">题目 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1: 输入: &#34;tree&#34; 输出: &#34;eert&#34; 解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。 因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&#34;eetr&#34;也是一个有效的答案。 示例 2: 输入: &#34;cccaaa&#34; 输出: &#34;cccaaa&#34; 解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&#34;aaaccc&#34;也是有效的答案。 注意&#34;cacaca&#34;是不正确的，因为相同的字母必须放在一起。 示例 3: 输入: &#34;Aabb&#34; 输出: &#34;bbAa&#34; 解释: 此外，&#34;bbaA&#34;也是一个有效的答案，但&#34;Aabb&#34;是不正确的。 注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-characters-by-frequency 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、桶排序
/** * @param {string} s * @return {string} */ var frequencySort = function (s) { const result = []; // 使用hashmap统计每个字符出现的次数 const hashmap = new Map(); for (let ch of s) { if (!hashmap.has(ch)) { hashmap.set(ch, 0); } hashmap.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/">215.数组中的第K个最大元素</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
        </div>
</div>

        <p class="summary">题目 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 解释：排序后：1,2,3,4,5,6，第2大元素是5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 解释：排序后：1,2,2,3,3,4,5,5,6，第4大元素是4 说明:
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、暴力解法
使用内置函数sort函数实现；
把元素从大到小排序，然后返回下标为k-1的元素。
/** * @param {number[]} nums * @param {number} k * @return {number} */ var findKthLargest = function(nums, k) { nums = nums.sort((a,b) =&gt; b - a); return nums[k-1]; }; 2、快速选择</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_227.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8ii/">227.基本计算器II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/409.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/">409.最长回文串</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。
在构造过程中，请注意区分大小写。比如 &ldquo;Aa&rdquo; 不能当做一个回文字符串。
注意: 假设字符串的长度不会超过 1010。
示例 1:
输入: &#34;abccccdd&#34; 输出: 7 解释: 我们可以构造的最长的回文串是&#34;dccaccd&#34;, 它的长度是 7。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 回文串： 正读和反读都相同的字符序列为回文串。
奇数个字符的回文串： 除中间字符以外，其他字符镜面对称（即其他字符都出现偶数次）。
偶数个字符的回文串： 所有字符镜面对称（即所有字符都出现偶数次）。
回文串的本质： 可能除去一个字符以外)其他的字母都出现偶数次。
最长回文串的构成： 使所有字母尽可能多的出现偶数次 + 1次（如果此时还有字母没用完）。
JS实现 参考实现1：
/** * @param {string} s * @return {number} */ var longestPalindrome = function (s) { let result = 0; // 为奇数的标识 let odd_mark = false; // 创建长度为58的数组，默认填充0，存放每个字母出现的次数 // A-Z, 65-90; a-z, 97-122 // 长度为58（26个英文小写字母+26个英文大写字母+大写Z与小写a中间的6个字符） const numbers = new Array(58).</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_028.%E5%AE%9E%E7%8E%B0strstr/">028.实现strStr()</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 实现 strStr() 函数。
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。
说明：
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例：
示例 1： 输入：haystack = &#34;hello&#34;, needle = &#34;ll&#34; 输出：2 示例 2： 输入：haystack = &#34;aaaaa&#34;, needle = &#34;bba&#34; 输出：-1 示例 3： 输入：haystack = &#34;&#34;, needle = &#34;&#34; 输出：0 提示：
0 &lt;= haystack.length, needle.length &lt;= 5 * 10^4 haystack 和 needle 仅由小写英文字符组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">003.无重复字符的最长子串</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1: 输入: s = &#34;abcabcbb&#34; 输出: 3 解释: 因为无重复字符的最长子串是 &#34;abc&#34;，所以其长度为 3。 示例 2: 输入: s = &#34;bbbbb&#34; 输出: 1 解释: 因为无重复字符的最长子串是 &#34;b&#34;，所以其长度为 1。 示例 3: 输入: s = &#34;pwwkew&#34; 输出: 3 解释: 因为无重复字符的最长子串是 &#34;wke&#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&#34;pwke&#34; 是一个子序列，不是子串。 示例 4: 输入: s = &#34;&#34; 输出: 0 提示：
0 &lt;= s.length &lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function (s) { // hashmap，记录每个字符是否出现过 const map = new Map(); // 无重复字符最长子串的左边界 let left = 0; // 无重复字符最长子串的长度 let max = 0; // 遍历字符串 for (let i = 0; i &lt; s.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_696._%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/">696.计数二进制子串</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">647.回文子串</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/205.%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/">205.同构字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
示例 1: 输入：s = &#34;egg&#34;, t = &#34;add&#34; 输出：true 示例 2： 输入：s = &#34;foo&#34;, t = &#34;bar&#34; 输出：false 示例 3： 输入：s = &#34;paper&#34;, t = &#34;title&#34; 输出：true 提示：
可以假设 s 和 t 长度相同。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/isomorphic-strings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。
我们维护两张哈希表，第一张哈希表 s2t 以 s 中字符为键，映射至 t 的字符为值，第二张哈希表 t2s 以 t 中字符为键，映射至 s 的字符为值。从左至右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突（即当前下标 index 对应的字符 s[index] 已经存在映射且不为 t[index] 或当前下标 index 对应的字符 t[index] 已经存在映射且不为 s[index]）时说明两个字符串无法构成同构，返回 false。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/">242.有效的字母异位词</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
示例 1: 输入: s = &#34;anagram&#34;, t = &#34;nagaram&#34; 输出: true 示例 2: 输入: s = &#34;rat&#34;, t = &#34;car&#34; 输出: false 说明:
你可以假设字符串只包含小写字母。 进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-anagram 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 字母异位词是指由相同的字母按照不同的顺序组成的单词。
JS实现 1、排序
t 是 s 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 s 和 t 分别排序，看排序后的字符串是否相等即可判断。
/** * @param {string} s * @param {string} t * @return {boolean} */ var isAnagram = function (s, t) { if (s.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/">452.用最少数量的箭引爆气球</a>
    </div><div class="post-meta">
    <div class="date">2021-04-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 示例 3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 示例 4： 输入：points = [[1,2]] 输出：1 示例 5： 输入：points = [[2,3],[2,3]] 输出：1 提示：
0 &lt;= points.length &lt;= 10^4 points[i].length == 2 -2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/">763.划分字母区间</a>
    </div><div class="post-meta">
    <div class="date">2021-04-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
示例：
输入：S = &ldquo;ababcbacadefegdehijhklij&rdquo; 输出：[9,7,8] 解释： 划分结果为 &ldquo;ababcbaca&rdquo;, &ldquo;defegde&rdquo;, &ldquo;hijhklij&rdquo;。 每个字母最多出现在一个片段中。 像 &ldquo;ababcbacadefegde&rdquo;, &ldquo;hijhklij&rdquo; 的划分是错误的，因为划分的片段数较少。 提示：
S的长度在[1, 500]之间。 S只包含小写字母 &lsquo;a&rsquo; 到 &lsquo;z&rsquo; 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/partition-labels 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。
在得到每个字母最后一次出现的下标位置之后，可以使用贪心的方法将字符串划分为尽可能多的片段，具体做法如下。
从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start=end=0。 对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 end_c，则当前片段的结束下标一定不会小于 end_c，因此令 end=max(end,end_c)。 当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start,end]，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start=end+1，继续寻找下一个片段。 重复上述过程，直到遍历完字符串。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {string} S * @return {number[]} */ var partitionLabels = function (S) { const result = []; //使用hashmap记录每一个字符出现的最后位置 const map = new Map(); for (let i = 0; i &lt; S.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/">122.买卖股票的最佳时机II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/stock/" rel="tag">stock</a>
        </div>
</div>

        <p class="summary">题目 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1: 输入: prices = [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入， 在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入， 在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: prices = [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入， 在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: prices = [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_605.%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/">605.种花问题</a>
    </div><div class="post-meta">
    <div class="date">2021-04-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。
示例 1： 输入：flowerbed = [1,0,0,0,1], n = 1 输出：true 示例 2： 输入：flowerbed = [1,0,0,0,1], n = 2 输出：false 提示：
1 &lt;= flowerbed.length &lt;= 2 * 104 flowerbed[i] 为 0 或 1 flowerbed 中不存在相邻的两朵花 0 &lt;= n &lt;= flowerbed.length 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/can-place-flowers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} flowerbed * @param {number} n * @return {boolean} */ var canPlaceFlowers = function(flowerbed, n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/">167.两数之和II-输入有序数组.md</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。
numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 提示：
2 &lt;= numbers.length &lt;= 3 * 10^4 -1000 &lt;= numbers[i] &lt;= 1000 numbers 按 递增顺序 排列 -1000 &lt;= target &lt;= 1000 仅存在一个有效答˜ 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/">435.无重叠区间</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:
可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-overlapping-intervals 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间 就越大，就越能保留更多的区间。
因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。
具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选 择的区间不重叠的区间。
JS实现 /** * @param {number[][]} intervals * @return {number} */ var eraseOverlapIntervals = function (intervals) { const len = intervals.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/">135.分发糖果</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？
示例 1： 输入：[1,0,2] 输出：5 解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2： 输入：[1,2,2] 输出：4 解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/candy 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 两次遍历：
把所有孩子的糖果数初始化为 1； 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1； 再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数 不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。 通过这两次遍历，分配的糖果就可以满足题目要求了。 这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系
JS实现 /** * @param {number[]} ratings * @return {number} */ var candy = function (ratings) { const len = ratings.length; // 把所有孩子的糖果数初始化为1 const nums = new Array(len).fill(1); // 从左往右遍历（这里下标起始为1） for (let i = 1; i &lt; len; i++) { if (ratings[i] &gt; ratings[i - 1]) { nums[i] = nums[i - 1] + 1; } } // 从右往左遍历 for (let i = len - 1; i &gt; 0; i--) { if (ratings[i - 1] &gt; ratings[i]) { nums[i - 1] = Math.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/">455.分发饼干</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示：
1 &lt;= g.length &lt;= 3 * 10^4 0 &lt;= s.length &lt;= 3 * 10^4 1 &lt;= g[i], s[j] &lt;= 2^31 - 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/assign-cookies 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_022.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/">022.括号生成</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例 1： 输入：n = 3 输出：[&#34;((()))&#34;,&#34;(()())&#34;,&#34;(())()&#34;,&#34;()(())&#34;,&#34;()()()&#34;] 示例 2： 输入：n = 1 输出：[&#34;()&#34;] 提示：
1 &lt;= n &lt;= 8
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/generate-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_005.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">005.最长回文子串</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个字符串 s，找到 s 中最长的回文子串。
示例 1： 输入：s = &#34;babad&#34; 输出：&#34;bab&#34; 解释：&#34;aba&#34; 同样是符合题意的答案。 示例 2： 输入：s = &#34;cbbd&#34; 输出：&#34;bb&#34; 示例 3： 输入：s = &#34;a&#34; 输出：&#34;a&#34; 示例 4： 输入：s = &#34;ac&#34; 输出：&#34;a&#34; 提示：
1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母（大写和/或小写）组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindromic-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 回文串：是从左到右读，从右到左读都一样的字符串。具有轴对称的特点。 子串：是原始字符串的一个连续子集。 子序列：是原始字符串的一个子集。 JS实现 /** * @param {string} s * @return {string} */ var longestPalindrome = function(s) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/067.%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/">067.二进制求和</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = &#34;11&#34;, b = &#34;1&#34; 输出: &#34;100&#34; 示例 2: 输入: a = &#34;1010&#34;, b = &#34;1011&#34; 输出: &#34;10101&#34; 提示：
每个字符串仅由字符 &lsquo;0&rsquo; 或 &lsquo;1&rsquo; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &ldquo;0&rdquo; ，就都不含前导零。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-binary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} a * @param {string} b * @return {string} */ var addBinary = function (a, b) { let result = &#34;&#34;; let carry = 0; for (let i = a.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/014.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/">014.最长公共前缀</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &ldquo;&quot;。
示例 1： 输入：strs = [&#34;flower&#34;,&#34;flow&#34;,&#34;flight&#34;] 输出：&#34;fl&#34; 示例 2： 输入：strs = [&#34;dog&#34;,&#34;racecar&#34;,&#34;car&#34;] 输出：&#34;&#34; 解释：输入不存在公共前缀。 提示：
0 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] 仅由小写英文字母组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-common-prefix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、横向扫描法
/** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function (strs) { if (strs.length === 0) { return &#34;&#34;; } // 获取两个字符串的最长公共前缀 const lcp = (str1, str2) =&gt; { const length = Math.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/090.%E5%AD%90%E9%9B%86ii/">090.子集II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
                <a class="tags_link" href="/tags/backtracking/" rel="tag">backtracking</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
示例 1： 输入：nums = [1,2,2] 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 提示：
1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subsets-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var subsetsWithDup = function(nums) { const result = []; const len = nums.length; if (len === 0) { return result; } // 排序 nums = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/078.%E5%AD%90%E9%9B%86/">078.子集</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
                <a class="tags_link" href="/tags/backtracking/" rel="tag">backtracking</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
示例 1： 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 提示：
1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subsets 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
补充 子集：2^n 真子集：2^n - 1 非空子集：2^n - 1 非空真子集：2^n - 2
JS实现 1、递归
/** * @param {number[]} nums * @return {number[][]} */ var subsets = function (nums) { const result = []; const len = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/">017.电话号码的字母组合</a>
    </div><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
                <a class="tags_link" href="/tags/backtracking/" rel="tag">backtracking</a>
        </div>
</div>

        <p class="summary">题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
1(!@#) 2(abc) 3(def) 4(ghi) 5(jkl) 6(mno) 7(pqrs) 8(tuv) 9(wxyz) *(+) 0(-) # 示例 1： 输入：digits = &#34;23&#34; 输出：[&#34;ad&#34;,&#34;ae&#34;,&#34;af&#34;,&#34;bd&#34;,&#34;be&#34;,&#34;bf&#34;,&#34;cd&#34;,&#34;ce&#34;,&#34;cf&#34;] 示例 2： 输入：digits = &#34;&#34; 输出：[] 示例 3： 输入：digits = &#34;2&#34; 输出：[&#34;a&#34;,&#34;b&#34;,&#34;c&#34;] 提示：
0 &lt;= digits.length &lt;= 4 digits[i] 是范围 [&lsquo;2&rsquo;, &lsquo;9&rsquo;] 的一个数字。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
补充 String.prototype.slice()
slice() 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。
str.slice(beginIndex[, endIndex]) beginIndex 从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 strLength + beginIndex 看待，这里的strLength 是字符串的长度（例如， 如果 beginIndex 是 -3 则看作是：strLength - 3）</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/047.%E5%85%A8%E6%8E%92%E5%88%97ii/">047.全排列II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示：
1 &lt;= nums.length &lt;= 8 -10 &lt;= nums[i] &lt;= 10 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/permutations-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var permuteUnique = function(nums) { // 返回结果数组 const result = []; const len = nums.length; // 如果数组长度等于0，直接返回 if (len === 0) { return result; } // 排序是剪枝的前提 nums = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/046.%E5%85%A8%E6%8E%92%E5%88%97/">046.全排列</a>
    </div><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
示例:
输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/permutations 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 排列是讲究顺序的，不同的顺序产生不同的排列；
[1,2,3]
以1开头的排列，[1,2,3],[1,3,2]；
以2开头的排列，[2,1,3],[2,3,1]；
以3开头的排列，[3,1,2],[3,2,1]；
按顺序枚举每一个位置可能出现的数字； 之前已经出现的数字在接下来要选择的数字中不能出现； [] / | \ [1] [2] [3] / \ / \ / \ [1,2] [1,3] [2,1] [2,3] [3,1] [3,2] | | | | | | [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1] JS实现 /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { // 返回结果数组 const result = []; const len = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/">377.组合总和Ⅳ</a>
    </div><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。
示例 1： 输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2： 输入：nums = [9], target = 3 输出：0 提示：
1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 1000 nums 中的所有元素 互不相同 1 &lt;= target &lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Ciii/">216.组合总和III</a>
    </div><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
说明：
所有数字都是正整数。 解集不能包含重复的组合。 示例：
示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combination-sum-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} k * @param {number} n * @return {number[][]} */ var combinationSum3 = function (k, n) { // 结果数组 const result = []; //路径数组 const path = []; const dfs = (curr, end, k, sum, path, result) =&gt; { // 递归终止条件 ?</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/077.%E7%BB%84%E5%90%88/">077.组合</a>
    </div><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定两个整数 n 和 k，返回 1 &hellip; n 中所有可能的 k 个数的组合。
示例:
输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combinations 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 n = 4, k = 2, [1,2,3,4]
1,2 1,3 1,4 2,3 2,4 3,4
JS实现 1、深度优先搜索（未剪枝）
/** * @param {number} n * @param {number} k * @return {number[][]} */ var combine = function (n, k) { const result = []; if (k &lt;= 0 || n &lt; k) { return result; } // 路径数组 const path = []; // 深度优先遍历 const dfs = (begin, n, k, path, result) =&gt; { //递归终止 if (path.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii/">040.组合总和II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
说明：
所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例：
示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combination-sum-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum2 = function(candidates, target) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/">039.组合总和</a>
    </div><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例：
示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ] 示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ] 提示：
1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都是独一无二的。 1 &lt;= target &lt;= 500 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combination-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、未剪枝
/** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum = function (candidates, target) { const result = []; const len = candidates.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/061.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/">061.旋转链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
示例 1： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
rotate 1: 5 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 rotate 2: 4 -&gt; 5 -&gt; 1 -&gt; 2 -&gt; 3
输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3]
示例 2： 0 -&gt; 1 -&gt; 2
rotate 1: 2 -&gt; 1 -&gt; 0 rotate 2: 1 -&gt; 2 -&gt; 0 rotate 3: 0 -&gt; 1 -&gt; 2 rotate 4: 2 -&gt; 0 -&gt; 1</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">024.两两交换链表中的节点</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示：
链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 链表： 1-&gt;2-&gt;3-&gt;4 头节点： head = 1, 结节点： dummy = 0, dummy.next = head; 0-&gt;1-&gt;2-&gt;3-&gt;4 临时节点： temp = dummy 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 | | dummy head temp temp.next，就是head，就是1 temp.next.next，就是head.next，就是2 node1 = temp.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/">019.删除链表的倒数第N个结点</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
示例 1： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 //删除倒数第2个后： 1 -&gt; 2 -&gt; 3 -&gt; 5 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示：
链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/">002.两数相加</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例 1： 2 -&gt; 4 -&gt; 3 + 5 -&gt; 6 -&gt; 4 ------------- = 7 -&gt; 0 -&gt; 8 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示：
每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/082.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/">082.删除排序链表中的重复元素II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。
返回同样按升序排列的结果链表。
示例 1： 输入：head = [1,2,3,3,4,4,5] 输出：[1,2,5] 示例 2： 输入：head = [1,1,1,2,3] 输出：[2,3] 提示：
链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function (head) { //设置哑节点，方便删除 let dummy = new ListNode(0); dummy.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/">142.环形链表II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
进阶：
你是否可以使用 O(1) 空间解决此题？ 示例：
示例 1： 3 -&gt; 2 -&gt; 0 -&gt; -4 -&gt; 2 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 1 -&gt; 2 -&gt; 1 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 1 -&gt; null 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">141.环形链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
进阶：
你能用 O(1)（即，常量）内存解决此问题吗？ 示例：
示例 1： 3 -&gt; 2 -&gt; 0 -&gt; -4 [-&gt; 2] 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 1 -&gt; 2 [-&gt; 1] 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 1 -&gt; null 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/">143.重排链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1: 给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reorder-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、使用数组存储，然后重新构建链表
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {void} Do not return anything, modify head in-place instead. */ var reorderList = function (head) { const list = []; while (head !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">234.回文链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 请判断一个链表是否为回文链表。
示例 1: 输入: 1-&gt;2 输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、将值复制到数组中后用双指针法
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {boolean} */ var isPalindrome = function (head) { const values = []; // 将链表的值保存到数组中 while (head !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/">328.奇偶链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明:
应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/odd-even-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var oddEvenList = function (head) { if (head === null) { return head; } // 偶节点的头节点 let evenHead = head.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">237.删除链表中的节点</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。
现有一个链表 &ndash;head = [4,5,1,9]，它可以表示为:
示例 1： 4 -&gt; 5 -&gt; 1 -&gt; 9 输入：head = [4,5,1,9], node = 5 输出：[4,1,9] 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2： 输入：head = [4,5,1,9], node = 1 输出：[4,5,9] 解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 提示：
链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/092.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/">092.反转链表II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 翻转后： 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] 示例 2： 输入：head = [5], left = 1, right = 1 输出：[5] 提示：
链表中节点数目为 n 1 &lt;= n &lt;= 500 -500 &lt;= Node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">206.反转链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 反转一个单链表。
示例:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、迭代
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { // 前一个节点 let prev = null; // 当前节点 let curr = head; while(curr !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/">203.移除链表元素</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
示例 1： 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 移除6： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2： 输入：head = [], val = 1 输出：[] 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[] 提示：
列表中的节点在范围 [0, 10^4] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= k &lt;= 50 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">160.相交链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 编写一个程序，找到两个单链表相交的起始节点。
如下面的两个链表： A: a1 -&gt; a2 -&gt; c1 -&gt; c2 -&gt; c3 B: b1 -&gt; b2 -&gt; b3 -&gt; c1 -&gt; c2 -&gt; c3
在节点 c1 开始相交。
示例 1： A: 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5 B: 5 -&gt; 0 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： A: 0 -&gt; 9 -&gt; 1 -&gt; 2 -&gt; 4 B: 3 -&gt; 2 -&gt; 4 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： A: 2 -&gt; 6 -&gt; 4 B: 1 -&gt; 5 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">148.排序链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
进阶： 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例 1： 4 -&gt; 2 -&gt; 1 -&gt; 3 排序后： 1 -&gt; 2 -&gt; 3 -&gt; 4 输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2： -1 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; 0 排序后： 1 -&gt; 0 -&gt; 3 -&gt; 4 -&gt; 5 输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5] 示例 3： 输入：head = [] 输出：[] 提示：
链表中节点的数目在范围 [0, 5 * 10^4] 内 -10^5 &lt;= Node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/095.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/">095.不同的二叉搜索树II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给定一个整数 n，生成所有由 1 &hellip; n 为节点所组成的 二叉搜索树 。
示例：
输入：3 输出： [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释： 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 提示：
0 &lt;= n &lt;= 8 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、回溯
/** * Definition for a binary tree node. * function TreeNode(val) { * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">096.不同的二叉搜索树</a>
    </div><div class="post-meta">
    <div class="date">2021-04-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 给定一个整数 n，求以 1 &hellip; n 为节点组成的二叉搜索树有多少种？
示例:
输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 假设 n 个节点存在二叉排序树的个数是 G (n)，令 f(i) 为以 i 为根的二叉搜索树的个数，则 G(n) = f(1) + f(2) + f(3) + f(4) + &hellip; + f(n)</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/">111.二叉树的最小深度</a>
    </div><div class="post-meta">
    <div class="date">2021-04-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明：叶子节点是指没有子节点的节点。
示例 1： 3 / \ 9 20 / \ 15 7 输入：root = [3,9,20,null,null,15,7] 输出：2 (节点3，9) 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 2 \ 3 \ 4 \ 5 \ 6 输出：5 (节点2，3，4，5，6) 提示：
树中节点数的范围在 [0, 10^5] 内 -1000 &lt;= Node.val &lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、深度优先搜索
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/">257.二叉树的所有路径</a>
    </div><div class="post-meta">
    <div class="date">2021-04-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。
示例:
输入: 1 / \ 2 3 \ 5 输出: [&#34;1-&gt;2-&gt;5&#34;, &#34;1-&gt;3&#34;] 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-paths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、深度优先搜索
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {string[]} */ var binaryTreePaths = function (root) { const result = []; if (root === null) { return result; } const dfs = (root, path) =&gt; { if (root) { path.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/">124.二叉树中的最大路径和</a>
    </div><div class="post-meta">
    <div class="date">2021-04-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。
示例 1： 1 / 2 3 输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6
示例 2： -10 / 9 20 / 15 7 输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42
提示：
树中节点数目范围是 [1, 3 * 10^4] -1000 &lt;= Node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciii/">437.路径总和III</a>
    </div><div class="post-meta">
    <div class="date">2021-04-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，它的每个结点都存放着一个整数值。
找出路径和等于给定数值的路径总数。
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
示例：
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -&gt; 3 2. 5 -&gt; 2 -&gt; 1 3. -3 -&gt; 11 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/path-sum-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ?</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Cii/">113.路径总和II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
示例 1： 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 （5 - 4 - 11 - 2） 输出：[[5,4,11,2],[5,8,4,5]] 示例 2： 1 / \ 2 3 输入：root = [1,2,3], targetSum = 5 输出：[] 示例 3： 输入：root = [1,2], targetSum = 0 输出：[] 提示：
树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/">112.路径总和</a>
    </div><div class="post-meta">
    <div class="date">2021-04-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
叶子节点 是指没有子节点的节点。
示例 1： 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 ，（5 - 4 - 11 - 2） 输出：true 示例 2： 1 / \ 2 3 输入：root = [1,2,3], targetSum = 5 输出：false 示例 3： 输入：root = [1,2], targetSum = 0 输出：false 提示：
树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">106.从中序与后序遍历序列构造二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 根据一棵树的中序遍历与后序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
例如，给出
中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \ 9 20 / \ 15 7 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {number[]} inorder * @param {number[]} postorder * @return {TreeNode} */ var buildTree = function (inorder, postorder) { if (postorder.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">105.从前序与中序遍历序列构造二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 根据一棵树的前序遍历与中序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
例如，
给出： 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \ 9 20 / \ 15 7 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 前序：根 -&gt; 左 -&gt; 右（根在最前边） 中序：左 -&gt; 根 -&gt; 右（根在中间） 后序：左 -&gt; 右 -&gt; 根（根在最后边） 由前序序列，我们可以确定根节点； 由后序序列，我们也可以确定根节点； 由中序序列，我们可以确定左右节点；
前序 + 中序，可以确定二叉树； 后序 + 中序，可以确定二叉树；
举例：
4 / \ 1 3 / / \ 2 5 8 tree: [4,1,3,2,null,5,8] 前序：[4,1,2,3,5,8] 中序：[2,1,4,5,3,8] 后序：[2,1,5,8,3,4] 前序+中序： 由前序：我们确定根节点为4； 由中序：我们确定根节点4左边的为左子树[2,1]，右边的为右子树[5,3,8]； 后序+中序： 由后序：我们确定根节点为4； 由中序：我们确定根节点4左边的为左子树[2,1]，右边的为右子树[5,3,8]； 前序+后序： 由前序：我们确定根节点为4； 由后序：我们确定根节点为4； JS实现 /** * Definition for a binary tree node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/">100.相同的树</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
示例 1： tree1： 1 / \ 2 3 tree2： 1 / \ 2 3 输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2： tree1： 1 / 2 tree2： 1 \ 2 输入：p = [1,2], q = [1,null,2] 输出：false 示例 3： tree1： 1 / \ 2 1 tree2： 1 / \ 1 2 输入：p = [1,2,1], q = [1,1,2] 输出：false 提示：
两棵树上的节点数目都在范围 [0, 100] 内 -10^4 &lt;= Node.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/">226.翻转二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
        </div>
</div>

        <p class="summary">题目 翻转一棵二叉树。
示例：
输入： 4 / \ 2 7 / \ / \ 1 3 6 9 输出： 4 / \ 7 2 / \ / \ 9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ：
谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/invert-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ?</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii/">107.二叉树的层序遍历II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回其自底向上的层序遍历为： [ [15,7], [9,20], [3] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、反转其返回结果（102.二叉树的层序遍历）
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrderBottom = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">145.二叉树的后序遍历</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，返回它的 后序 遍历。
示例:
输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 后序遍历：左 -&gt; 右 -&gt; 根
JS实现 1、递归实现
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var helper = function (root, result) { if (root !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/">144.二叉树的前序遍历</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
        </div>
</div>

        <p class="summary">题目 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
示例 1： 1 \ 2 / 3 输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 1 / 2 输入：root = [1,2] 输出：[1,2] 示例 5： 1 \ 2 输入：root = [1,null,2] 输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 前序遍历：根 -&gt; 左 -&gt; 右
JS实现 1、 递归实现</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">103.二叉树的锯齿形层序遍历</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回锯齿形层序遍历如下： [ [3], [20,9], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var zigzagLevelOrder = function (root) { // write code here const result = []; if (root === null) { return result; } const q = []; q.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">094.二叉树的中序遍历</a>
    </div><div class="post-meta">
    <div class="date">2021-04-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树的根节点 root ，返回它的 中序 遍历。
示例 1： 1 \ 2 / 3 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 1 / 2 输入：root = [1,2] 输出：[2,1] 示例 5： 1 \ 2 输入：root = [1,null,2] 输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶:
递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 中序遍历：左 -&gt; 根 -&gt; 右
JS实现 1、递归实现</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/">922.按奇偶排序数组II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
        </div>
</div>

        <p class="summary">题目 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
你可以返回任何满足上述条件的数组作为答案。
示例：
输入：[4,2,5,7] 输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示：
2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[]} */ var sortArrayByParityII = function (nums) { const result = new Array(nums.length); let i = 0; // 第1次遍历，在偶数位上设置偶数 for (const num of nums) { if (num % 2 === 0) { result[i] = num; i += 2; } } i = 1; // 第2次遍历，在奇数位上设置奇数 for (const num of nums) { if (num % 2 === 1) { result[i] = num; i += 2; } } return result; }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/905.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">905.按奇偶排序数组</a>
    </div><div class="post-meta">
    <div class="date">2021-04-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
        </div>
</div>

        <p class="summary">题目 给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。
你可以返回满足此条件的任何数组作为答案。
示例：
输入：[3,1,2,4] 输出：[2,4,3,1] 输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示：
1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-array-by-parity 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} A * @return {number[]} */ var sortArrayByParity = function(A) { const result = []; // 第1次遍历，添加所有偶数 for(let item of A) { if(item % 2 === 0){ result.push(item); } } // 第2次遍历，添加所有奇数 for(let item of A) { if(item % 2 === 1){ result.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/">349.两个数组的交集</a>
    </div><div class="post-meta">
    <div class="date">2021-04-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 说明：
输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、排序 + 双指针
/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function (nums1, nums2) { const result = []; //分别对两个数组排序（从小到大） nums1.sort((a, b) =&gt; a - b); nums2.sort((a, b) =&gt; a - b); const len1 = nums1.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_371.%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/">371.两整数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-04-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
示例 1: 输入: a = 1, b = 2 输出: 3 示例 2: 输入: a = -2, b = 3 输出: 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sum-of-two-integers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} a * @param {number} b * @return {number} */ var getSum = function(a, b) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">015.三数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-04-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/sum/" rel="tag">sum</a>
        </div>
</div>

        <p class="summary">题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2： 输入：nums = [] 输出：[] 示例 3： 输入：nums = [0] 输出：[] 提示：
0 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function (nums) { let result = []; // 传入数组为null直接返回result if (nums === null) { return result; } const len = nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/">075.颜色分类</a>
    </div><div class="post-meta">
    <div class="date">2021-04-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
                <a class="tags_link" href="/tags/quicksort/" rel="tag">quicksort</a>
                <a class="tags_link" href="/tags/pointers/" rel="tag">pointers</a>
        </div>
</div>

        <p class="summary">题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 示例 3： 输入：nums = [0] 输出：[0] 示例 4： 输入：nums = [1] 输出：[1] 提示：
n == nums.length 1 &lt;= n &lt;= 300 nums[i] 为 0、1 或 2 进阶：
你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-colors 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、单指针
在第一次遍历中，我们将数组中所有的 0 交换到数组的头部。
在第二次遍历中，我们将数组中所有的 1 交换到头部的 0 之后。 此时，所有的 2 都出现在数组的尾部，这样我们就完成了排序。
/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/">347.前K个高频元素</a>
    </div><div class="post-meta">
    <div class="date">2021-04-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 提示：
1 &lt;= nums.length &lt;= 10^5 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/top-k-frequent-elements 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function (nums, k) { const result = []; // 使用hashmap统计每个数字出现的次数 const hashmap = new Map(); for (let num of nums) { if (!</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/252.%E4%BC%9A%E8%AE%AE%E5%AE%A4/">252.会议室</a>
    </div><div class="post-meta">
    <div class="date">2021-04-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[ s1 , e1 ] ，[ s2 , e2 ]，…] (si &lt; ei) ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。
示例 1: 输入: [[0, 30],[5, 10],[15, 20]] 输出: 2
示例 2: 输入: [[7,10],[2,4]] 输出: 1
JS实现 var minMeetingRooms = (meetings) =&gt; { if (meetings === null || meetings.length === 0) { return 0; } // 需要的会议室个数 let number = 1; // 会议按结束时间排序 meetings.sort((a, b) =&gt; a[1] - b[1]); // 上一次会议结束时间（这里是第一次） let end = meetings[0][1]; for (let i = 1; i &lt; meetings.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/043.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/">043.字符串相乘</a>
    </div><div class="post-meta">
    <div class="date">2021-04-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
示例 1:
输入: num1 = &#34;2&#34;, num2 = &#34;3&#34; 输出: &#34;6&#34; 示例 2:
输入: num1 = &#34;123&#34;, num2 = &#34;456&#34; 输出: &#34;56088&#34; 说明：
num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/multiply-strings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 如果 num1 和 num2 之一是 0，则直接将 0 作为结果返回即可。
如果 num1和 num2都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。这道题中，被乘数是 num1，乘数是 num2 。
需要注意的是，num2 除了最低位以外，其余的每一位的运算结果都需要补 0。</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/">415.字符串相加</a>
    </div><div class="post-meta">
    <div class="date">2021-04-08</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
提示：
num1 和num2 的长度都小于 5100 num1 和num2 都只包含数字 0-9 num1 和num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-strings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} num1 * @param {string} num2 * @return {string} */ var addStrings = function (num1, num2) { let i = num1.length - 1, j = num2.length - 1, add = 0; const result = []; while (i &gt;= 0 || j &gt;= 0 || add !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/238.%E7%A7%BB%E5%8A%A8%E9%9B%B6/">238.移动零</a>
    </div><div class="post-meta">
    <div class="date">2021-03-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明:
必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/move-zeroes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。
右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
注意到以下性质：
左指针左边均为非零数； 右指针左边直到左指针处均为零。 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var moveZeroes = function (nums) { let n = nums.length, left = 0, right = 0; while (right &lt; n) { if (nums[right] != 0) { const temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; } right++; } }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/387.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/">387.字符串中的第一个唯一字符</a>
    </div><div class="post-meta">
    <div class="date">2021-03-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
        </div>
</div>

        <p class="summary">题目 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
示例：
s = &#34;leetcode&#34; 返回 0 s = &#34;loveleetcode&#34; 返回 2 提示：你可以假定该字符串只包含小写字母。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {string} s * @return {number} */ var firstUniqChar = function (s) { const map = {}; for (let i = 0; i &lt; s.length; i++) { const ch = s[i]; map[ch] = (map[ch] || 0) + 1; } for (let i = 0; i &lt; s.length; i++) { if (map[s[i]] === 1) { return i; } } return -1; }; 参考代码2：hashmap实现</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">344.反转字符串</a>
    </div><div class="post-meta">
    <div class="date">2021-03-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/string/" rel="tag">string</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&#34;h&#34;,&#34;e&#34;,&#34;l&#34;,&#34;l&#34;,&#34;o&#34;] 输出：[&#34;o&#34;,&#34;l&#34;,&#34;l&#34;,&#34;e&#34;,&#34;h&#34;] 示例 2：
输入：[&#34;H&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;h&#34;] 输出：[&#34;h&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;H&#34;] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 双指针的解法：
1、将 left 指向字符数组首元素，right 指向字符数组尾元素。
2、当 left &lt; right：
交换 s[left] 和 s[right]； left 指针右移一位，即 left = left + 1； right 指针左移一位，即 right = right - 1。 3、当 left &gt;= right，反转结束，返回字符数组即可。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/reverse-string/solution/fan-zhuan-zi-fu-chuan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">198.打家劫舍</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
示例 1：
输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2：
输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示：
0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/">053.最大子序和</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [0] 输出：0 示例 4： 输入：nums = [-1] 输出：-1 示例 5： 输入：nums = [-100000] 输出：-100000 提示：
1 &lt;= nums.length &lt;= 3 * 10^4 -10^5 &lt;= nums[i] &lt;= 10^5 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-subarray 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {number[]} nums * @return {number} */ var maxSubArray = function (nums) { // 当前和 let cur_sum = nums[0]; // 最大和 let max_sum = nums[0]; // 遍历数组 for (let i = 1; i &lt; nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">121.买卖股票的最佳时机</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
                <a class="tags_link" href="/tags/stock/" rel="tag">stock</a>
        </div>
</div>

        <p class="summary">题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1：
输入：[7,1,5,3,6,4] 输出：5 解释： 在第 2 天（股票价格 = 1）的时候买入， 在第 5 天（股票价格 = 6）的时候卖出， 最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：
输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：
1 &lt;= prices.length &lt;= 10^5 0 &lt;= prices[i] &lt;= 10^4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1：一次遍历</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/070.%E7%88%AC%E6%A5%BC%E6%A2%AF/">070.爬楼梯</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/dp/" rel="tag">dp</a>
        </div>
</div>

        <p class="summary">题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/climbing-stairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归（执行超时了）
找规律：
第1级台阶，1种方法（爬1级） 第2级台阶，2种方法（爬1级 或 爬2级） 第3级台阶，3种方法（从第2级台阶爬1级 或 从第1级台阶爬2级） &hellip; 第n级台阶，从第n-1级台阶爬1级 或 从第n-2级台阶爬2级 递推公式：F(n) = F(n-1) + F(n-2)</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">108.将有序数组转换为二叉搜索树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
示例 1：
0 / \ -3 9 / / -10 5 输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 0 / \ -10 5 \ \ -3 9 示例 2：
3 1 / \ 1 3 输入：nums = [1,3] 输出：[3,1] 解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示：
1 &lt;= nums.length &lt;= 10^4 -10^4 &lt;= nums[i] &lt;= 10^4 nums 按 严格递增 顺序排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">098.验证二叉搜索树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:
输入:
2 / \ 1 3 输出: true
示例 2:
输入:
5 / \ 1 4 / \ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/validate-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 var valid = function (node, lower, upper) { if (node === null) { return true; } let val = node.val; if (lower != null &amp;&amp; val &lt;= lower) { return false; } if (upper !</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">102.二叉树的层序遍历</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
</div>

        <p class="summary">题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例： 二叉树：[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层序遍历结果：
[ [3], [9,20], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">101.对称二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
                <a class="tags_link" href="/tags/queue/" rel="tag">queue</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
1 / \ 2 2 \ \ 3 3 进阶：
你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归实现
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ?</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">104.二叉树的最大深度</a>
    </div><div class="post-meta">
    <div class="date">2021-03-20</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binarytree/" rel="tag">binarytree</a>
                <a class="tags_link" href="/tags/bfs/" rel="tag">bfs</a>
                <a class="tags_link" href="/tags/dfs/" rel="tag">dfs</a>
        </div>
</div>

        <p class="summary">题目 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例： 给定二叉树 [3,9,20,null,null,15,7]，
3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
补充 高度：从下往上。从最底层开始计数，计数起点是0；
深度：从上往下。从根节点开始计数，计数起点是0；
层次：与深度类似。计数起点是1；根节点在第1层；
节点的高度 = 节点到叶子节点的最长路径（边数）； 节点的深度 = 根节点到这个节点所经历的边的个数； 节点的层数 = 节点的深度 + 1；
树的高度 = 根节点的高度；
JS实现 1、递归实现
参考1：
/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function (root) { if (!</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_278.%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/">278.第一个错误的版本</a>
    </div><div class="post-meta">
    <div class="date">2021-03-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, &hellip;, n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
示例:
给定 n = 5，并且 version = 4 是第一个错误的版本。
调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true
所以，4 是第一个错误的版本。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/first-bad-version 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for isBadVersion() * * @param {integer} version number * @return {boolean} whether the version is bad * isBadVersion = function(version) { * ... * }; */ /** * @param {function} isBadVersion() * @return {function} */ var solution = function(isBadVersion) { /** * @param {integer} n Total versions * @return {integer} The first bad version */ return function(n) { }; }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/088.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/">088.合并两个有序数组</a>
    </div><div class="post-meta">
    <div class="date">2021-03-19</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/merge/" rel="tag">merge</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
        </div>
</div>

        <p class="summary">题目 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 提示：
nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/384._%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/">384.打乱数组</a>
    </div><div class="post-meta">
    <div class="date">2021-03-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 示例：
输入 [&#34;Solution&#34;, &#34;shuffle&#34;, &#34;reset&#34;, &#34;shuffle&#34;] [[[1, 2, 3]], [], [], []] 输出 [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] 解释 Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2] 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/169.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/">169.多数元素</a>
    </div><div class="post-meta">
    <div class="date">2021-03-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1： 输入：[3,2,3] 输出：3
示例 2： 输入：[2,2,1,1,1,2,2] 输出：2
进阶：
尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/majority-element 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var majorityElement = function (nums) { let half = nums.length / 2; let obj = {}; for (let num of nums) { obj[num] = (obj[num] || 0) + 1; if (obj[num] &gt; half) { return num; } } }; ES6 Map</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/">136.只出现一次的数字</a>
    </div><div class="post-meta">
    <div class="date">2021-03-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/bit/" rel="tag">bit</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
        </div>
</div>

        <p class="summary">题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
位运算 异或运算：
任何数和 0 做异或运算，结果仍是原来的数； 任何数和其自身做异或运算，结果是0； 异或运算满足交换律和结合律； 位运算 XOR：当对一对数位进行位运算 XOR 时，如果数位是不同的则返回 1。
示例：
console.log(0 ^ 0); //0，规则1，规则2 console.log(0 ^ 1); //1，规则1 console.log(1 ^ 0); //1，规则1 console.log(1 ^ 1); //0，规则2 console.log(0 ^ 1); //1，规则1 console.log(0 ^ 10); //10，规则1 console.log(1 ^ 1); //0，规则2 console.log(2 ^ 2); //0，规则2 console.log(1 ^ 1 ^ 2); //2，规则1，2，3 console.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/054.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/">054.螺旋矩阵</a>
    </div><div class="post-meta">
    <div class="date">2021-03-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 1 2 3 4 5 6 7 8 9 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 1 2 3 4 5 6 7 8 9 10 11 12 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 10 -100 &lt;= matrix[i][j] &lt;= 100 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/spiral-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 JS实现 /** * @param {number[][]} matrix * @return {number[]} */ var spiralOrder = function (matrix) { let result = []; let left = 0, right = matrix[0].</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/">059.螺旋矩阵II</a>
    </div><div class="post-meta">
    <div class="date">2021-03-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
示例 1： 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]]
示例 2： 输入：n = 1 输出：[[1]] 提示：
1 &lt;= n &lt;= 20
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/spiral-matrix-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number[][]} */ var generateMatrix = function (n) { let num = 1; const matrix = new Array(n).fill(0).map(() =&gt; new Array(n).fill(0)); let left = 0, right = n - 1, top = 0, bottom = n - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) { //从左到右 for (let column = left; column &lt;= right; column++) { matrix[top][column] = num; num++; } //从上到下 for (let row = top + 1; row &lt;= bottom; row++) { matrix[row][right] = num; num++; } // 从右到左 for (let column = right - 1; column &gt; left; column--) { matrix[bottom][column] = num; num++; } // 从下到上 for (let row = bottom; row &gt; top; row--) { matrix[row][left] = num; num++; } left++; right--; top++; bottom--; } return matrix; }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/026.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">026.删除有序数组中的重复项</a>
    </div><div class="post-meta">
    <div class="date">2021-03-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <p class="summary">题目 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 示例 1：
输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">001.两数之和</a>
    </div><div class="post-meta">
    <div class="date">2021-03-16</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/sum/" rel="tag">sum</a>
        </div>
</div>

        <p class="summary">题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
你可以按任意顺序返回答案。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示：
2 &lt;= nums.length &lt;= 10^3 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 只会存在一个有效答案 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { // 创建一个hashmap const map = new Map(); // 遍历数组 for (let i = 0; i &lt; nums.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/155.%E6%9C%80%E5%B0%8F%E6%A0%88/">155.最小栈</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
                <a class="tags_link" href="/tags/design/" rel="tag">design</a>
        </div>
</div>

        <p class="summary">题目 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例:
输入： [&#34;MinStack&#34;,&#34;push&#34;,&#34;push&#34;,&#34;push&#34;,&#34;getMin&#34;,&#34;pop&#34;,&#34;top&#34;,&#34;getMin&#34;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&gt; 返回 -3. minStack.pop(); minStack.top(); --&gt; 返回 0. minStack.getMin(); --&gt; 返回 -2. 提示：
pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-stack 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 栈特点：先进后出。
使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。
当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中； 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出； 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/min-stack/solution/zui-xiao-zhan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * initialize your data structure here.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/">020.有效的括号</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/stack/" rel="tag">stack</a>
        </div>
</div>

        <p class="summary">题目 给定一个只包括 &lsquo;(&rsquo;，&rsquo;)&rsquo;，&rsquo;{&rsquo;，&rsquo;}&rsquo;，&rsquo;[&rsquo;，&rsquo;]&rsquo; 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = &#34;()&#34; 输出：true 示例 2： 输入：s = &#34;()[]{}&#34; 输出：true 示例 3： 输入：s = &#34;(]&#34; 输出：false 示例 4： 输入：s = &#34;([)]&#34; 输出：false 示例 5： 输入：s = &#34;{[]}&#34; 输出：true 提示：
1 &lt;= s.length &lt;= 10^4； s 仅由括号 &lsquo;()[]{}&rsquo; 组成； 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 我们遍历字符串中的所有字符：
1、如果遇到了左括号，就把对应的右括号压栈（比如遇到了字符&rsquo;(&rsquo;，就把字符&rsquo;)&lsquo;压栈）。
2、如果遇到了右括号
查看栈是否为空，如果为空，说明不能构成有效的括号，直接返回false。 如果栈不为空，栈顶元素出栈，然后判断出栈的这个元素是否等于这个右括号，如果不等于，说明不匹配，直接返回false。如果匹配，就继续判断字符串的下一个字符。 3、最后如果栈为空，说明是完全匹配，是有效的括号，否则如果栈不为空，说明不完全匹配，不是有效的括号。
作者：数据结构和算法 链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnbcaj/?discussion=rj6XSA 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考1:
/** * @param {string} s * @return {boolean} */ var isValid = function (s) { const stack = []; const map = { &#34;(&#34;: &#34;)&#34;, &#34;[&#34;: &#34;]&#34;, &#34;{&#34;: &#34;}&#34;, }; //遍历字符串 for (let char of s) { //如果map结构中存在左括号，把左括号入栈 if (char in map) { stack.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/083.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">083.删除排序链表中的重复元素</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <p class="summary">题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例 1: 输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function (head) { let current = head; while (current != null &amp;&amp; current.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">021.合并两个有序链表</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="tags_link" href="/tags/merge/" rel="tag">merge</a>
        </div>
</div>

        <p class="summary">题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示：
两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/069.x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/">069.x的平方根</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/binary-search/" rel="tag">binary-search</a>
        </div>
</div>

        <p class="summary">题目 实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sqrtx 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于 x 平方根的整数部分ans 是满足 k^2 &lt;= x 的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。
二分查找的下界为 0，上界可以粗略地设定为 x。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number} x * @return {number} */ var mySqrt = function (x) { if (x &lt; 2) { return x; } let low = 1, high = Math.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/">035.搜索插入位置</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>

        <p class="summary">题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
示例 1: 输入: [1,3,5,6], 5 输出: 2
示例 2: 输入: [1,3,5,6], 2 输出: 1
示例 3: 输入: [1,3,5,6], 7 输出: 4
示例 4: 输入: [1,3,5,6], 0 输出: 0
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-insert-position 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number} */ var searchInsert = function (nums, target) { let low = 0, high = nums.length - 1; while (low &lt;= high) { let mid = parseInt(low + (high - low) / 2); if (nums[mid] === target) { return mid; } else if (nums[mid] &lt; target) { low = mid + 1; } else { high = mid - 1; } } return low; }; </p>
    
</div>

        </section>
    </div>
    
    <div class="pagination">
            <a class="pagination__item pagination__item--prev btn" href="/tags/leetcode/page/11/">Prev</a>
        <span class="pagination__item pagination__item--current">12/21</span>
            <a class="pagination__item pagination__item--next btn" href="/tags/leetcode/page/13/">Next</a>
    </div>


        </div></body>
</html>
