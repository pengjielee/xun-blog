<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body><div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="page-title">greedy</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/draft/leetcode/_406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/">406.根据身高重建队列</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 JS实现 </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_665.%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/">665.非递减数列</a>
    </div><div class="post-meta">
    <div class="date">2021-05-06</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。
示例 1: 输入: nums = [4,2,3] 输出: true 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 输入: nums = [4,2,1] 输出: false 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 提示：
1 &lt;= n &lt;= 10 ^ 4 -10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-decreasing-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {boolean} */ var checkPossibility = function(nums) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/">452.用最少数量的箭引爆气球</a>
    </div><div class="post-meta">
    <div class="date">2021-04-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 示例 3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 示例 4： 输入：points = [[1,2]] 输出：1 示例 5： 输入：points = [[2,3],[2,3]] 输出：1 提示：
0 &lt;= points.length &lt;= 10^4 points[i].length == 2 -2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/">763.划分字母区间</a>
    </div><div class="post-meta">
    <div class="date">2021-04-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
示例：
输入：S = &ldquo;ababcbacadefegdehijhklij&rdquo; 输出：[9,7,8] 解释： 划分结果为 &ldquo;ababcbaca&rdquo;, &ldquo;defegde&rdquo;, &ldquo;hijhklij&rdquo;。 每个字母最多出现在一个片段中。 像 &ldquo;ababcbacadefegde&rdquo;, &ldquo;hijhklij&rdquo; 的划分是错误的，因为划分的片段数较少。 提示：
S的长度在[1, 500]之间。 S只包含小写字母 &lsquo;a&rsquo; 到 &lsquo;z&rsquo; 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/partition-labels 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。
在得到每个字母最后一次出现的下标位置之后，可以使用贪心的方法将字符串划分为尽可能多的片段，具体做法如下。
从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start=end=0。 对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 end_c，则当前片段的结束下标一定不会小于 end_c，因此令 end=max(end,end_c)。 当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start,end]，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start=end+1，继续寻找下一个片段。 重复上述过程，直到遍历完字符串。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {string} S * @return {number[]} */ var partitionLabels = function (S) { const result = []; //使用hashmap记录每一个字符出现的最后位置 const map = new Map(); for (let i = 0; i &lt; S.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/">122.买卖股票的最佳时机II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/stock/" rel="tag">stock</a>
        </div>
</div>

        <p class="summary">题目 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1: 输入: prices = [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入， 在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入， 在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: prices = [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入， 在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: prices = [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_605.%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/">605.种花问题</a>
    </div><div class="post-meta">
    <div class="date">2021-04-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。
示例 1： 输入：flowerbed = [1,0,0,0,1], n = 1 输出：true 示例 2： 输入：flowerbed = [1,0,0,0,1], n = 2 输出：false 提示：
1 &lt;= flowerbed.length &lt;= 2 * 104 flowerbed[i] 为 0 或 1 flowerbed 中不存在相邻的两朵花 0 &lt;= n &lt;= flowerbed.length 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/can-place-flowers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} flowerbed * @param {number} n * @return {boolean} */ var canPlaceFlowers = function(flowerbed, n) { }; </p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/">435.无重叠区间</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:
可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-overlapping-intervals 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间 就越大，就越能保留更多的区间。
因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。
具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选 择的区间不重叠的区间。
JS实现 /** * @param {number[][]} intervals * @return {number} */ var eraseOverlapIntervals = function (intervals) { const len = intervals.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/">135.分发糖果</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？
示例 1： 输入：[1,0,2] 输出：5 解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2： 输入：[1,2,2] 输出：4 解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/candy 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 两次遍历：
把所有孩子的糖果数初始化为 1； 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1； 再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数 不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。 通过这两次遍历，分配的糖果就可以满足题目要求了。 这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系
JS实现 /** * @param {number[]} ratings * @return {number} */ var candy = function (ratings) { const len = ratings.length; // 把所有孩子的糖果数初始化为1 const nums = new Array(len).fill(1); // 从左往右遍历（这里下标起始为1） for (let i = 1; i &lt; len; i++) { if (ratings[i] &gt; ratings[i - 1]) { nums[i] = nums[i - 1] + 1; } } // 从右往左遍历 for (let i = len - 1; i &gt; 0; i--) { if (ratings[i - 1] &gt; ratings[i]) { nums[i - 1] = Math.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/">455.分发饼干</a>
    </div><div class="post-meta">
    <div class="date">2021-04-25</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/greedy/" rel="tag">greedy</a>
        </div>
</div>

        <p class="summary">题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示：
1 &lt;= g.length &lt;= 3 * 10^4 0 &lt;= s.length &lt;= 3 * 10^4 1 &lt;= g[i], s[j] &lt;= 2^31 - 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/assign-cookies 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
    
</div>

        </section>
    </div>
    


        </div></body>
</html>
