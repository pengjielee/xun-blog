<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>greedy on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/greedy/</link>
    <description>Recent content in greedy on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 26 Apr 2021 14:46:22 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/greedy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>763.划分字母区间</title>
      <link>https://www.pengjielee.cn/post/leetcode/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</link>
      <pubDate>Mon, 26 Apr 2021 14:46:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</guid>
      <description>题目 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
示例：
输入：S = &amp;ldquo;ababcbacadefegdehijhklij&amp;rdquo; 输出：[9,7,8] 解释： 划分结果为 &amp;ldquo;ababcbaca&amp;rdquo;, &amp;ldquo;defegde&amp;rdquo;, &amp;ldquo;hijhklij&amp;rdquo;。 每个字母最多出现在一个片段中。 像 &amp;ldquo;ababcbacadefegde&amp;rdquo;, &amp;ldquo;hijhklij&amp;rdquo; 的划分是错误的，因为划分的片段数较少。 提示：
S的长度在[1, 500]之间。 S只包含小写字母 &amp;lsquo;a&amp;rsquo; 到 &amp;lsquo;z&amp;rsquo; 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/partition-labels 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。
在得到每个字母最后一次出现的下标位置之后，可以使用贪心的方法将字符串划分为尽可能多的片段，具体做法如下。
从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start=end=0。 对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 end_c，则当前片段的结束下标一定不会小于 end_c，因此令 end=max(end,end_c)。 当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start,end]，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start=end+1，继续寻找下一个片段。 重复上述过程，直到遍历完字符串。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {string} S * @return {number[]} */ var partitionLabels = function (S) { const result = []; //使用hashmap记录每一个字符出现的最后位置 const map = new Map(); for (let i = 0; i &amp;lt; S.</description>
    </item>
    
    <item>
      <title>122.买卖股票的最佳时机II</title>
      <link>https://www.pengjielee.cn/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</link>
      <pubDate>Mon, 26 Apr 2021 14:42:08 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</guid>
      <description>题目 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1: 输入: prices = [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入， 在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入， 在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: prices = [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入， 在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: prices = [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：</description>
    </item>
    
    <item>
      <title>435.无重叠区间</title>
      <link>https://www.pengjielee.cn/post/leetcode/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</link>
      <pubDate>Sun, 25 Apr 2021 15:12:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</guid>
      <description>题目 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:
可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-overlapping-intervals 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间 就越大，就越能保留更多的区间。
因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。
具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选 择的区间不重叠的区间。
JS实现 /** * @param {number[][]} intervals * @return {number} */ var eraseOverlapIntervals = function (intervals) { const len = intervals.</description>
    </item>
    
    <item>
      <title>135.分发糖果</title>
      <link>https://www.pengjielee.cn/post/leetcode/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</link>
      <pubDate>Sun, 25 Apr 2021 14:20:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</guid>
      <description>题目 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？
示例 1： 输入：[1,0,2] 输出：5 解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2： 输入：[1,2,2] 输出：4 解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/candy 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 两次遍历：
把所有孩子的糖果数初始化为 1； 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1； 再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数 不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。 通过这两次遍历，分配的糖果就可以满足题目要求了。 这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系
JS实现 /** * @param {number[]} ratings * @return {number} */ var candy = function (ratings) { const len = ratings.length; // 把所有孩子的糖果数初始化为1 const nums = new Array(len).fill(1); // 从左往右遍历（这里下标起始为1） for (let i = 1; i &amp;lt; len; i++) { if (ratings[i] &amp;gt; ratings[i - 1]) { nums[i] = nums[i - 1] + 1; } } // 从右往左遍历 for (let i = len - 1; i &amp;gt; 0; i--) { if (ratings[i - 1] &amp;gt; ratings[i]) { nums[i - 1] = Math.</description>
    </item>
    
    <item>
      <title>455.分发饼干</title>
      <link>https://www.pengjielee.cn/post/leetcode/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</link>
      <pubDate>Sun, 25 Apr 2021 13:48:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</guid>
      <description>题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &amp;gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示：
1 &amp;lt;= g.length &amp;lt;= 3 * 10^4 0 &amp;lt;= s.length &amp;lt;= 3 * 10^4 1 &amp;lt;= g[i], s[j] &amp;lt;= 2^31 - 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/assign-cookies 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</description>
    </item>
    
  </channel>
</rss>
