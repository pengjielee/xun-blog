<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/monokai-sublime.min.css" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
        <div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="title">linkedlist</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/sword2/22.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/">22.链表中倒数第k个节点</a>
    </div><div class="post-meta">
    <div class="date">2021-08-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof 著作权归领扣网络所有。商 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/18.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/">18.删除链表的节点</a>
    </div><div class="post-meta">
    <div class="date">2021-08-26</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意：此题对比原题有改动
示例 1: 输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明：
题目保证链表中节点的值互不 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/sword2/_35.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/">35.复杂链表的复制</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="link" href="/tags/hashtable/" rel="tag">hashtable</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：
输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]]
示例 3：
输入：head = [[3,null],[3,0],[3,null]] 输 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/24.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">24.反转链表</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="link" href="/tags/recursion/" rel="tag">recursion</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制：
0 &lt;= 节点个数 &lt;= 5000
注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof 著作 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">06.从尾到头打印链表</a>
    </div><div class="post-meta">
    <div class="date">2021-08-24</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/sword2/" rel="tag">sword2</a>
                <a class="link" href="/tags/stack/" rel="tag">stack</a>
                <a class="link" href="/tags/recursion/" rel="tag">recursion</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制：
0 &lt;= 链表长度 &lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、reverse()方法，反转数组
/** * Definition for singly-linked list. * …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/138.%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/">138.复制带随机指针的链表</a>
    </div><div class="post-meta">
    <div class="date">2021-07-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random &ndash;&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/061.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/">061.旋转链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
示例 1： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
rotate 1: 5 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 rotate 2: 4 -&gt; 5 -&gt; 1 -&gt; 2 -&gt; 3
输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3]
示例 2： 0 -&gt; 1 -&gt; 2
rotate 1: 2 -&gt; 1 -&gt; 0 rotate 2: 1 -&gt; 2 -&gt; 0 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">024.两两交换链表中的节点</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示：
链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）
来源：力扣（LeetCode） 链 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/">019.删除链表的倒数第N个结点</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <div class="summary">题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
示例 1： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 //删除倒数第2个后： 1 -&gt; 2 -&gt; 3 -&gt; 5 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示：
链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/">002.两数相加</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例 1： 2 -&gt; 4 -&gt; 3 + 5 -&gt; 6 -&gt; 4 ------------- = 7 -&gt; 0 -&gt; 8 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/082.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/">082.删除排序链表中的重复元素II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。
返回同样按升序排列的结果链表。
示例 1： 输入：head = [1,2,3,3,4,4,5] 输出：[1,2,5] 示例 2： 输入：head = [1,1,1,2,3] 输出：[2,3] 提示：
链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序排列 来源：力扣（LeetCode） 链 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/">142.环形链表II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <div class="summary">题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
进阶：
你是否可以使用 O(1) 空间解决此题？ 示例：
示例 1： 3 -&gt; 2 -&gt; 0 -&gt; -4 -&gt; 2 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">141.环形链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <div class="summary">题目 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
进阶：
你能用 O(1)（即，常量）内存解决此问题吗？ 示例：
示例 1： 3 -&gt; 2 -&gt; 0 -&gt; -4 [-&gt; 2] 输入：head = [3,2,0,-4], …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/">143.重排链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1: 给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reorder-list 著作权归领扣网 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">234.回文链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
        </div>
</div>

        <div class="summary">题目 请判断一个链表是否为回文链表。
示例 1: 输入: 1-&gt;2 输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、将值复制到数组中后用双指针法
/** * Definition for singly-linked list. * …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/">328.奇偶链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">237.删除链表中的节点</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。
现有一个链表 &ndash;head = [4,5,1,9]，它可以表示为:
示例 1： 4 -&gt; 5 -&gt; 1 -&gt; 9 输入：head = [4,5,1,9], node = 5 输出：[4,1,9] 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2： 输入：head = [4,5,1,9], node = 1 输出：[4,5,9] 解释：给定你链表中值为 1 的第三个节点，那么在调用了 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/092.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/">092.反转链表II</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 翻转后： 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] 示例 2： 输入：head = [5], left = 1, right = 1 输出：[5] 提示：
链表中节点数目为 n …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">206.反转链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 反转一个单链表。
示例:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、迭代
/** * Definition for singly-linked list. * function …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/">203.移除链表元素</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
示例 1： 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 移除6： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2： 输入：head = [], val = 1 输出：[] 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[] 提示：
列表 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">160.相交链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <div class="summary">题目 编写一个程序，找到两个单链表相交的起始节点。
如下面的两个链表： A: a1 -&gt; a2 -&gt; c1 -&gt; c2 -&gt; c3 B: b1 -&gt; b2 -&gt; b3 -&gt; c1 -&gt; c2 -&gt; c3
在节点 c1 开始相交。
示例 1： A: 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5 B: 5 -&gt; 0 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/draft/leetcode/_148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">148.排序链表</a>
    </div><div class="post-meta">
    <div class="date">2021-04-21</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
进阶： 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例 1： 4 -&gt; 2 -&gt; 1 -&gt; 3 排序后： 1 -&gt; 2 -&gt; 3 -&gt; 4 输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2： -1 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; 0 排序后： 1 -&gt; 0 -&gt; 3 -&gt; 4 -&gt; 5 输入：head = [-1,5,3,4,0] 输 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/083.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">083.删除排序链表中的重复元素</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例 1: 输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">021.合并两个有序链表</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="link" href="/tags/merge/" rel="tag">merge</a>
        </div>
</div>

        <div class="summary">题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示：
两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode） 链 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/print-the-linked-list-from-tail-to-head/">03.从尾到头打印链表</a>
    </div><div class="post-meta">
    <div class="date">2021-02-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
思路 利用JS数组的unshift()方法，在数组开头插入数据。
var nums = [1,2,3]; var temp = nums.unshift(4); console.log(temp); //4 console.log(nums); //[4,1,2,3] var nums = [1,2,3]; var temp = nums.shift(); console.log(temp); //1 console.log(nums); //[2,3] JS实现 /*function ListNode(x){ …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-last-k-node-in-the-linked-list/">14.链表中倒数第k个结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，输出该链表中倒数第k个结点。
思路 利用快慢指针，快指针先走k步，然后快慢指针一起走，当快指针走到末尾，那么慢指针就到了倒数第k个节点了。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function FindKthToTail(head, k) { // write code here let fast = head, slow = head; for (let i = 0; i &lt; k; i++) { if (fast === null) return; fast = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/reverse-a-linked-list/">15.反转链表.md</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，反转链表后，输出新链表的表头。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function ReverseList(pHead) { // write code here if (pHead === null || pHead.next === null) { return pHead; } let prev = null; //记录节点的前一个节点 let next = null; //记录节点的后一个节点 while (pHead != null) { next = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/merges-two-sorted-linked-lists/">16.合并两个排序的链表</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
JS实现 1、递归实现
/*function ListNode(x){ this.val = x; this.next = null; }*/ function Merge(pHead1, pHead2) { if (pHead1 === null) { return pHead2; } if (pHead2 === null) { return pHead1; } if (pHead1.val &lt; pHead2.val) { pHead1.next = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-first-common-node-of-two-linked-lists/">36.两个链表的第一个公共结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
思路 什么是公共节点，并不是两个节点的值相同就是公共节点。 而是在第一链表和第二链表中都存在一个节点，该节点往后的子链表在两个链表中是相同的。
如下图中链表6-7就是两个链表的公共链表，而节点6就是第一个公共节点。
1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; 7 4 -&gt; 5 -&gt; 6 -&gt; 7 如果两个链表存在公共节点，那么公共节点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，那么最后一个相同的节点就是我 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-entry-node-of-the-linked-list-loop/">55.链表中环的入口结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
思路 1、设置快慢指针，假如有环，他们一定相遇在环中；
2、两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口；
JS实现 参考1
/*function ListNode(x){ this.val = x; this.next = null; }*/ function EntryNodeOfLoop(pHead) { // write code here //至少3个节点才能成环 if (!pHead || !pHead.next || !pHead.next.next) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/delete-duplicate-nodes-in-the-linked-list/">56.删除链表中重复的结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-09</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5
思路 非递归的代码：
1、首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况；
2、设置 pre ，last 指针， pre指针指向当前确定不重复的那个节点，而last指针相当于工作指针，一直往后面搜索。
JS实现 // 非递归法 function deleteDuplication(pHead) { if (!pHead || !pHead.next) { …</div>
    
</div>

        </section>
        
    <div class="pagination">
            <a class="pagination__item pagination__item--prev" href="/tags/linkedlist/page/3/">Prev</a>
        <span class="pagination__item pagination__item--current">4/4</span>
    </div>

    </div>

        </div><script src="/js/highlight.min.js" />
<script>
    document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre").forEach((block) => {
            hljs.highlightBlock(block);
        });
    });
</script>
</body>
</html>
