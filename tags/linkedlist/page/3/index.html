<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/monokai-sublime.min.css" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
        <div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="title">Linkedlist</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/leetcode/083.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">083.删除排序链表中的重复元素</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
        </div>
</div>

        <div class="summary">题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例 1: 输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">021.合并两个有序链表</a>
    </div><div class="post-meta">
    <div class="date">2021-03-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="link" href="/tags/linkedlist/" rel="tag">linkedlist</a>
                <a class="link" href="/tags/merge/" rel="tag">merge</a>
        </div>
</div>

        <div class="summary">题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示：
两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode） 链 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/print-the-linked-list-from-tail-to-head/">03.从尾到头打印链表</a>
    </div><div class="post-meta">
    <div class="date">2021-02-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
思路 利用JS数组的unshift()方法，在数组开头插入数据。
var nums = [1,2,3]; var temp = nums.unshift(4); console.log(temp); //4 console.log(nums); //[4,1,2,3] var nums = [1,2,3]; var temp = nums.shift(); console.log(temp); //1 console.log(nums); //[2,3] JS实现 /*function ListNode(x){ …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-last-k-node-in-the-linked-list/">14.链表中倒数第k个结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，输出该链表中倒数第k个结点。
思路 利用快慢指针，快指针先走k步，然后快慢指针一起走，当快指针走到末尾，那么慢指针就到了倒数第k个节点了。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function FindKthToTail(head, k) { // write code here let fast = head, slow = head; for (let i = 0; i &lt; k; i++) { if (fast === null) return; fast = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/reverse-a-linked-list/">15.反转链表.md</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，反转链表后，输出新链表的表头。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function ReverseList(pHead) { // write code here if (pHead === null || pHead.next === null) { return pHead; } let prev = null; //记录节点的前一个节点 let next = null; //记录节点的后一个节点 while (pHead != null) { next = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/merges-two-sorted-linked-lists/">16.合并两个排序的链表</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
JS实现 1、递归实现
/*function ListNode(x){ this.val = x; this.next = null; }*/ function Merge(pHead1, pHead2) { if (pHead1 === null) { return pHead2; } if (pHead2 === null) { return pHead1; } if (pHead1.val &lt; pHead2.val) { pHead1.next = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-first-common-node-of-two-linked-lists/">36.两个链表的第一个公共结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
思路 什么是公共节点，并不是两个节点的值相同就是公共节点。 而是在第一链表和第二链表中都存在一个节点，该节点往后的子链表在两个链表中是相同的。
如下图中链表6-7就是两个链表的公共链表，而节点6就是第一个公共节点。
1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; 7 4 -&gt; 5 -&gt; 6 -&gt; 7 如果两个链表存在公共节点，那么公共节点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，那么最后一个相同的节点就是我 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-entry-node-of-the-linked-list-loop/">55.链表中环的入口结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
思路 1、设置快慢指针，假如有环，他们一定相遇在环中；
2、两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口；
JS实现 参考1
/*function ListNode(x){ this.val = x; this.next = null; }*/ function EntryNodeOfLoop(pHead) { // write code here //至少3个节点才能成环 if (!pHead || !pHead.next || !pHead.next.next) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/delete-duplicate-nodes-in-the-linked-list/">56.删除链表中重复的结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-09</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5
思路 非递归的代码：
1、首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况；
2、设置 pre ，last 指针， pre指针指向当前确定不重复的那个节点，而last指针相当于工作指针，一直往后面搜索。
JS实现 // 非递归法 function deleteDuplication(pHead) { if (!pHead || !pHead.next) { …</div>
    
</div>

        </section>
        
    <div class="pagination">
            <a class="pagination__item pagination__item--prev" href="/tags/linkedlist/page/2/">Prev</a>
        <span class="pagination__item pagination__item--current">3/3</span>
    </div>

    </div>

        </div><script src="/js/highlight.min.js"></script>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre").forEach((block) => {
            hljs.highlightBlock(block);
        });
        
        
        
        
        
        
        
        
        
        
    });
</script>
</body>
</html>
