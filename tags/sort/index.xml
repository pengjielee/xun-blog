<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sort on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/sort/</link>
    <description>Recent content in sort on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 27 Apr 2021 17:32:06 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/sort/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>451.根据字符出现频率排序</title>
      <link>https://www.pengjielee.cn/post/leetcode/451.%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 27 Apr 2021 17:32:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/451.%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</guid>
      <description>题目 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1: 输入: &amp;#34;tree&amp;#34; 输出: &amp;#34;eert&amp;#34; 解释: &amp;#39;e&amp;#39;出现两次，&amp;#39;r&amp;#39;和&amp;#39;t&amp;#39;都只出现一次。 因此&amp;#39;e&amp;#39;必须出现在&amp;#39;r&amp;#39;和&amp;#39;t&amp;#39;之前。此外，&amp;#34;eetr&amp;#34;也是一个有效的答案。 示例 2: 输入: &amp;#34;cccaaa&amp;#34; 输出: &amp;#34;cccaaa&amp;#34; 解释: &amp;#39;c&amp;#39;和&amp;#39;a&amp;#39;都出现三次。此外，&amp;#34;aaaccc&amp;#34;也是有效的答案。 注意&amp;#34;cacaca&amp;#34;是不正确的，因为相同的字母必须放在一起。 示例 3: 输入: &amp;#34;Aabb&amp;#34; 输出: &amp;#34;bbAa&amp;#34; 解释: 此外，&amp;#34;bbaA&amp;#34;也是一个有效的答案，但&amp;#34;Aabb&amp;#34;是不正确的。 注意&amp;#39;A&amp;#39;和&amp;#39;a&amp;#39;被认为是两种不同的字符。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-characters-by-frequency 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、桶排序
/** * @param {string} s * @return {string} */ var frequencySort = function (s) { const result = []; // 使用hashmap统计每个字符出现的次数 const hashmap = new Map(); for (let ch of s) { if (!hashmap.has(ch)) { hashmap.set(ch, 0); } hashmap.</description>
    </item>
    
    <item>
      <title>215.数组中的第K个最大元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Tue, 27 Apr 2021 16:38:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>题目 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 解释：排序后：1,2,3,4,5,6，第2大元素是5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 解释：排序后：1,2,2,3,3,4,5,5,6，第4大元素是4 说明:
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、暴力解法
使用内置函数sort函数实现；
把元素从大到小排序，然后返回下标为k-1的元素。
/** * @param {number[]} nums * @param {number} k * @return {number} */ var findKthLargest = function(nums, k) { nums = nums.sort((a,b) =&amp;gt; b - a); return nums[k-1]; }; 2、快速选择</description>
    </item>
    
    <item>
      <title>349.两个数组的交集</title>
      <link>https://www.pengjielee.cn/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Sat, 17 Apr 2021 16:14:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 说明：
输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、排序 + 双指针
/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function (nums1, nums2) { const result = []; //分别对两个数组排序（从小到大） nums1.sort((a, b) =&amp;gt; a - b); nums2.sort((a, b) =&amp;gt; a - b); const len1 = nums1.</description>
    </item>
    
    <item>
      <title>075.颜色分类</title>
      <link>https://www.pengjielee.cn/post/leetcode/075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</link>
      <pubDate>Thu, 15 Apr 2021 10:25:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</guid>
      <description>题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 示例 3： 输入：nums = [0] 输出：[0] 示例 4： 输入：nums = [1] 输出：[1] 提示：
n == nums.length 1 &amp;lt;= n &amp;lt;= 300 nums[i] 为 0、1 或 2 进阶：
你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-colors 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、单指针
在第一次遍历中，我们将数组中所有的 0 交换到数组的头部。
在第二次遍历中，我们将数组中所有的 1 交换到头部的 0 之后。 此时，所有的 2 都出现在数组的尾部，这样我们就完成了排序。
/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead.</description>
    </item>
    
    <item>
      <title>347.前K个高频元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 15 Apr 2021 10:25:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</guid>
      <description>题目 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 提示：
1 &amp;lt;= nums.length &amp;lt;= 10^5 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/top-k-frequent-elements 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function (nums, k) { const result = []; // 使用hashmap统计每个数字出现的次数 const hashmap = new Map(); for (let num of nums) { if (!</description>
    </item>
    
  </channel>
</rss>
