<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body><div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page-list">
        <h1 class="page-title">sort</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/leetcode/451.%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/">451.根据字符出现频率排序</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
        </div>
</div>

        <p class="summary">题目 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1: 输入: &#34;tree&#34; 输出: &#34;eert&#34; 解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。 因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&#34;eetr&#34;也是一个有效的答案。 示例 2: 输入: &#34;cccaaa&#34; 输出: &#34;cccaaa&#34; 解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&#34;aaaccc&#34;也是有效的答案。 注意&#34;cacaca&#34;是不正确的，因为相同的字母必须放在一起。 示例 3: 输入: &#34;Aabb&#34; 输出: &#34;bbAa&#34; 解释: 此外，&#34;bbaA&#34;也是一个有效的答案，但&#34;Aabb&#34;是不正确的。 注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-characters-by-frequency 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、桶排序
/** * @param {string} s * @return {string} */ var frequencySort = function (s) { const result = []; // 使用hashmap统计每个字符出现的次数 const hashmap = new Map(); for (let ch of s) { if (!hashmap.has(ch)) { hashmap.set(ch, 0); } hashmap.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/">215.数组中的第K个最大元素</a>
    </div><div class="post-meta">
    <div class="date">2021-04-27</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
        </div>
</div>

        <p class="summary">题目 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 解释：排序后：1,2,3,4,5,6，第2大元素是5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 解释：排序后：1,2,2,3,3,4,5,5,6，第4大元素是4 说明:
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、暴力解法
使用内置函数sort函数实现；
把元素从大到小排序，然后返回下标为k-1的元素。
/** * @param {number[]} nums * @param {number} k * @return {number} */ var findKthLargest = function(nums, k) { nums = nums.sort((a,b) =&gt; b - a); return nums[k-1]; }; 2、快速选择</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/">349.两个数组的交集</a>
    </div><div class="post-meta">
    <div class="date">2021-04-17</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/array/" rel="tag">array</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
                <a class="tags_link" href="/tags/two-pointers/" rel="tag">two-pointers</a>
                <a class="tags_link" href="/tags/hashtable/" rel="tag">hashtable</a>
        </div>
</div>

        <p class="summary">题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 说明：
输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、排序 + 双指针
/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function (nums1, nums2) { const result = []; //分别对两个数组排序（从小到大） nums1.sort((a, b) =&gt; a - b); nums2.sort((a, b) =&gt; a - b); const len1 = nums1.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/">075.颜色分类</a>
    </div><div class="post-meta">
    <div class="date">2021-04-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
                <a class="tags_link" href="/tags/quicksort/" rel="tag">quicksort</a>
                <a class="tags_link" href="/tags/pointers/" rel="tag">pointers</a>
        </div>
</div>

        <p class="summary">题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 示例 3： 输入：nums = [0] 输出：[0] 示例 4： 输入：nums = [1] 输出：[1] 提示：
n == nums.length 1 &lt;= n &lt;= 300 nums[i] 为 0、1 或 2 进阶：
你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-colors 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、单指针
在第一次遍历中，我们将数组中所有的 0 交换到数组的头部。
在第二次遍历中，我们将数组中所有的 1 交换到头部的 0 之后。 此时，所有的 2 都出现在数组的尾部，这样我们就完成了排序。
/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead.</p>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/leetcode/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/">347.前K个高频元素</a>
    </div><div class="post-meta">
    <div class="date">2021-04-15</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
                <a class="tags_link" href="/tags/sort/" rel="tag">sort</a>
        </div>
</div>

        <p class="summary">题目 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 提示：
1 &lt;= nums.length &lt;= 10^5 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/top-k-frequent-elements 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function (nums, k) { const result = []; // 使用hashmap统计每个数字出现的次数 const hashmap = new Map(); for (let num of nums) { if (!</p>
    
</div>

        </section>
    </div>
    


        </div></body>
</html>
