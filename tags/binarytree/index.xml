<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>binarytree on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/tags/binarytree/</link>
    <description>Recent content in binarytree on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 27 Aug 2021 13:17:32 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/tags/binarytree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>28.对称的二叉树</title>
      <link>https://www.pengjielee.cn/post/sword2/28.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 27 Aug 2021 13:17:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/28.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.</description>
    </item>
    
    <item>
      <title>27.二叉树的镜像</title>
      <link>https://www.pengjielee.cn/post/sword2/27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Fri, 27 Aug 2021 13:17:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>题目 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入： 4 / \ 2 7 / \ / \ 1 3 6 9 镜像输出： 4 / \ 7 2 / \ / \ 9 6 3 1 示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var mirrorTree = function(root) { if(root === null){ return null; } const temp = root.</description>
    </item>
    
    <item>
      <title>109.有序链表转换二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Fri, 16 Jul 2021 10:47:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 将给定的有序链表转换为二叉搜索树的第一步是确定根节点。 如何找出这样的一个根节点呢？我们可以找出链表元素的中位数作为根节点的值。
这里对于中位数的定义为：如果链表中的元素个数为奇数，那么唯一的中间值为中位数；如果元素个数为偶数，那么唯二的中间值都可以作为中位数，而不是常规定义中二者的平均值。
根据中位数的性质，链表中小于中位数的元素个数与大于中位数的元素个数要么相等，要么相差 1。此时，小于中位数的元素组成了左子树，大于中位数的元素组成了右子树，它们分别对应着有序链表中连续的一段。
在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中位数作为根节点，以此类推。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>110.平衡二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 14 Jul 2021 16:51:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
示例 1： 3 / \ 9 20 / \ 15 7 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 1 / \ 2 2 / \ 3 3 / \ 4 4 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 提示：
树中的节点数在范围 [0, 5000] 内 -10^4 &amp;lt;= Node.val &amp;lt;= 10^4
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/balanced-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1：自顶向下的递归
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.</description>
    </item>
    
    <item>
      <title>099.恢复二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/099.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Wed, 14 Jul 2021 11:18:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/099.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？
示例 1： 1 / \ 3 null / \ null 2 3 / \ 1 null / \ null 2 输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 左孩子，因为 3 &amp;gt; 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： 3 / \ 1 4 / \ / null null 2 2 / \ 1 4 / \ / null null 3 输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 &amp;lt; 3 。交换 2 和 3 使二叉搜索树有效。 提示：</description>
    </item>
    
    <item>
      <title>297.二叉树的序列化与反序列化</title>
      <link>https://www.pengjielee.cn/post/leetcode/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 19 May 2021 13:22:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
示例 1： 输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[1,2] 提示：
树中结点数在范围 [0, 10^4] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。
众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。
1、广度优先搜索可以按照层次的顺序从上到下遍历所有的节点；
2、深度优先搜索可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将深度优先搜索策略区分为：
先序遍历 中序遍历 后序遍历 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.</description>
    </item>
    
    <item>
      <title>199.二叉树的右视图</title>
      <link>https://www.pengjielee.cn/post/leetcode/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Wed, 12 May 2021 09:50:56 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例:
输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-right-side-view 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、BFS
利用BFS进行层次遍历，记录下每层的最后一个元素。
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var rightSideView = function (root) { const result = []; if (root === null) { return result; } //队列特点：先进先出 const q = []; //入队根节点 q.</description>
    </item>
    
    <item>
      <title>617.合并二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 11 May 2021 10:26:10 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
示例 1:
输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-binary-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.</description>
    </item>
    
    <item>
      <title>095.不同的二叉搜索树II</title>
      <link>https://www.pengjielee.cn/post/leetcode/095.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</link>
      <pubDate>Tue, 20 Apr 2021 17:41:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/095.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</guid>
      <description>题目 给定一个整数 n，生成所有由 1 &amp;hellip; n 为节点所组成的 二叉搜索树 。
示例：
输入：3 输出： [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释： 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 提示：
0 &amp;lt;= n &amp;lt;= 8 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、回溯
/** * Definition for a binary tree node. * function TreeNode(val) { * this.</description>
    </item>
    
    <item>
      <title>096.不同的二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Tue, 20 Apr 2021 17:41:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给定一个整数 n，求以 1 &amp;hellip; n 为节点组成的二叉搜索树有多少种？
示例:
输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 假设 n 个节点存在二叉排序树的个数是 G (n)，令 f(i) 为以 i 为根的二叉搜索树的个数，则 G(n) = f(1) + f(2) + f(3) + f(4) + &amp;hellip; + f(n)</description>
    </item>
    
    <item>
      <title>111.二叉树的最小深度</title>
      <link>https://www.pengjielee.cn/post/leetcode/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 20 Apr 2021 16:37:33 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明：叶子节点是指没有子节点的节点。
示例 1： 3 / \ 9 20 / \ 15 7 输入：root = [3,9,20,null,null,15,7] 输出：2 (节点3，9) 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 2 \ 3 \ 4 \ 5 \ 6 输出：5 (节点2，3，4，5，6) 提示：
树中节点数的范围在 [0, 10^5] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、深度优先搜索
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.</description>
    </item>
    
    <item>
      <title>257.二叉树的所有路径</title>
      <link>https://www.pengjielee.cn/post/leetcode/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 20 Apr 2021 16:05:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。
示例:
输入: 1 / \ 2 3 \ 5 输出: [&amp;#34;1-&amp;gt;2-&amp;gt;5&amp;#34;, &amp;#34;1-&amp;gt;3&amp;#34;] 解释: 所有根节点到叶子节点的路径为: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-paths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、深度优先搜索
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {string[]} */ var binaryTreePaths = function (root) { const result = []; if (root === null) { return result; } const dfs = (root, path) =&amp;gt; { if (root) { path.</description>
    </item>
    
    <item>
      <title>106.从中序与后序遍历序列构造二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 19 Apr 2021 16:30:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 根据一棵树的中序遍历与后序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
例如，给出
中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \ 9 20 / \ 15 7 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {number[]} inorder * @param {number[]} postorder * @return {TreeNode} */ var buildTree = function (inorder, postorder) { if (postorder.</description>
    </item>
    
    <item>
      <title>105.从前序与中序遍历序列构造二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 19 Apr 2021 16:29:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 根据一棵树的前序遍历与中序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
例如，
给出： 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \ 9 20 / \ 15 7 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 前序：根 -&amp;gt; 左 -&amp;gt; 右（根在最前边） 中序：左 -&amp;gt; 根 -&amp;gt; 右（根在中间） 后序：左 -&amp;gt; 右 -&amp;gt; 根（根在最后边） 由前序序列，我们可以确定根节点； 由后序序列，我们也可以确定根节点； 由中序序列，我们可以确定左右节点；
前序 + 中序，可以确定二叉树； 后序 + 中序，可以确定二叉树；
举例：
4 / \ 1 3 / / \ 2 5 8 tree: [4,1,3,2,null,5,8] 前序：[4,1,2,3,5,8] 中序：[2,1,4,5,3,8] 后序：[2,1,5,8,3,4] 前序+中序： 由前序：我们确定根节点为4； 由中序：我们确定根节点4左边的为左子树[2,1]，右边的为右子树[5,3,8]； 后序+中序： 由后序：我们确定根节点为4； 由中序：我们确定根节点4左边的为左子树[2,1]，右边的为右子树[5,3,8]； 前序+后序： 由前序：我们确定根节点为4； 由后序：我们确定根节点为4； JS实现 /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>100.相同的树</title>
      <link>https://www.pengjielee.cn/post/leetcode/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link>
      <pubDate>Mon, 19 Apr 2021 16:25:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid>
      <description>题目 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
示例 1： tree1： 1 / \ 2 3 tree2： 1 / \ 2 3 输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2： tree1： 1 / 2 tree2： 1 \ 2 输入：p = [1,2], q = [1,null,2] 输出：false 示例 3： tree1： 1 / \ 2 1 tree2： 1 / \ 1 2 输入：p = [1,2,1], q = [1,1,2] 输出：false 提示：
两棵树上的节点数目都在范围 [0, 100] 内 -10^4 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>226.翻转二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 19 Apr 2021 14:59:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 翻转一棵二叉树。
示例：
输入： 4 / \ 2 7 / \ / \ 1 3 6 9 输出： 4 / \ 7 2 / \ / \ 9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ：
谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/invert-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ?</description>
    </item>
    
    <item>
      <title>107.二叉树的层序遍历II</title>
      <link>https://www.pengjielee.cn/post/leetcode/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii/</link>
      <pubDate>Mon, 19 Apr 2021 14:06:42 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii/</guid>
      <description>题目 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回其自底向上的层序遍历为： [ [15,7], [9,20], [3] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、反转其返回结果（102.二叉树的层序遍历）
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrderBottom = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</description>
    </item>
    
    <item>
      <title>145.二叉树的后序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:14:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树，返回它的 后序 遍历。
示例:
输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 后序遍历：左 -&amp;gt; 右 -&amp;gt; 根
JS实现 1、递归实现
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var helper = function (root, result) { if (root !</description>
    </item>
    
    <item>
      <title>144.二叉树的前序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:13:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
示例 1： 1 \ 2 / 3 输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 1 / 2 输入：root = [1,2] 输出：[1,2] 示例 5： 1 \ 2 输入：root = [1,null,2] 输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 前序遍历：根 -&amp;gt; 左 -&amp;gt; 右
JS实现 1、 递归实现</description>
    </item>
    
    <item>
      <title>103.二叉树的锯齿形层序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:12:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回锯齿形层序遍历如下： [ [3], [20,9], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var zigzagLevelOrder = function (root) { // write code here const result = []; if (root === null) { return result; } const q = []; q.</description>
    </item>
    
    <item>
      <title>094.二叉树的中序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:05:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树的根节点 root ，返回它的 中序 遍历。
示例 1： 1 \ 2 / 3 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 1 / 2 输入：root = [1,2] 输出：[2,1] 示例 5： 1 \ 2 输入：root = [1,null,2] 输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 进阶:
递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 中序遍历：左 -&amp;gt; 根 -&amp;gt; 右
JS实现 1、递归实现</description>
    </item>
    
    <item>
      <title>108.将有序数组转换为二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 20 Mar 2021 11:15:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
示例 1：
0 / \ -3 9 / / -10 5 输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 0 / \ -10 5 \ \ -3 9 示例 2：
3 1 / \ 1 3 输入：nums = [1,3] 输出：[3,1] 解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示：
1 &amp;lt;= nums.length &amp;lt;= 10^4 -10^4 &amp;lt;= nums[i] &amp;lt;= 10^4 nums 按 严格递增 顺序排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>098.验证二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 20 Mar 2021 11:15:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:
输入:
2 / \ 1 3 输出: true
示例 2:
输入:
5 / \ 1 4 / \ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/validate-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 var valid = function (node, lower, upper) { if (node === null) { return true; } let val = node.val; if (lower != null &amp;amp;&amp;amp; val &amp;lt;= lower) { return false; } if (upper !</description>
    </item>
    
    <item>
      <title>102.二叉树的层序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 20 Mar 2021 11:05:11 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例： 二叉树：[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层序遍历结果：
[ [3], [9,20], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</description>
    </item>
    
    <item>
      <title>101.对称二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 20 Mar 2021 09:52:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
1 / \ 2 2 \ \ 3 3 进阶：
你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归实现
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ?</description>
    </item>
    
    <item>
      <title>104.二叉树的最大深度</title>
      <link>https://www.pengjielee.cn/post/leetcode/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sat, 20 Mar 2021 09:46:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例： 给定二叉树 [3,9,20,null,null,15,7]，
3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
补充 高度：从下往上。从最底层开始计数，计数起点是0；
深度：从上往下。从根节点开始计数，计数起点是0；
层次：与深度类似。计数起点是1；根节点在第1层；
节点的高度 = 节点到叶子节点的最长路径（边数）； 节点的深度 = 根节点到这个节点所经历的边的个数； 节点的层数 = 节点的深度 + 1；
树的高度 = 根节点的高度；
JS实现 1、递归实现
参考1：
/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function (root) { if (!</description>
    </item>
    
    <item>
      <title>04.重建二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 10 Mar 2021 11:33:30 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
详解 前序：根-&amp;gt;左-&amp;gt;右 {1,2,4,7,3,5,6,8} 中序：左-&amp;gt;根-&amp;gt;右 {4,7,2,1,5,3,8,6}
根据中序遍历和前序遍历可以确定二叉树，具体过程为：
根据前序序列第一个结点确定根结点； 根据根结点在中序序列中的位置分割出左右两个子序列； 对左子树和右子树分别递归使用同样的方法继续分解； 例如： 前序序列{1,2,4,7,3,5,6,8} = pre 中序序列{4,7,2,1,5,3,8,6} = in
根据当前前序序列的第一个结点确定根结点，为 1 找到 1 在中序遍历序列中的位置，为 in[3] 切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树 则切割后的左子树前序序列为：{2,4,7}，切割后的左子树中序序列为：{4,7,2}；切割后的右子树前序序列为：{3,5,6,8}，切割后的右子树中序序列为：{5,3,8,6} 对子树分别使用同样的方法分解 链接：https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6?answerType=1&amp;amp;f=discussion 来源：牛客网
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function reConstructBinaryTree(pre, vin) { // write code here if (pre.length === 0 || vin.length === 0) { return null; } //前序的第一个节点为根节点 let root = new TreeNode(pre[0]); //在中序中找到根节点 for (let i = 0; i &amp;lt; vin.</description>
    </item>
    
    <item>
      <title>17.树的子结构</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 10 Mar 2021 10:29:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>题目 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function HasSubtree(root1, root2) { // write code here if (root1 === null || root2 === null) { return false; } let result = false; if (root1.val === root2.val) { result = helper(root1, root2); } if (!result) { result = helper(root1.left, root2); } if (!result) { result = helper(root1.right, root2); } return result; } function helper(r1, r2) { if (r2 === null) return true; if (r1 === null) return false; if (r1.</description>
    </item>
    
    <item>
      <title>59.按之字形顺序打印二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_59.%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 07 Mar 2021 20:40:42 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_59.%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 按之字形顺序打印二叉树
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function Print(pRoot) { // write code here let result = []; if (pRoot === null) { return result; } let q = []; q.push(pRoot); let rev = true; while (q.length != 0) { let level = []; let len = q.length; for (let i = 0; i &amp;lt; len; i++) { const node = q.</description>
    </item>
    
    <item>
      <title>58.对称的二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_58.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 07 Mar 2021 20:40:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_58.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function isSymmetrical(pRoot) { // write code here return isSymmetricalTree(pRoot, pRoot); } function isSymmetricalTree(node1, node2) { //判断两个节点都是否为空 if (!node1 &amp;amp;&amp;amp; !node2) { return true; } //判断两个节点是否存在一个为空 if (!node1 || !node2) { return false; } //判断两个节点是否相同 if (node1.val != node2.val) { return false; } return ( isSymmetricalTree(node1.left, node2.right) &amp;amp;&amp;amp; isSymmetricalTree(node1.right, node2.left) ); } </description>
    </item>
    
    <item>
      <title>39.平衡二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_39.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 07 Mar 2021 20:39:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_39.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
平衡二叉树一般指平衡树。
平衡树(Balance Tree，BT) 指的是，任意节点的子树的高度差都小于等于1。
详解 /* * 链接：https://www.nowcoder.com/questionTerminal/8b3b95850edb4115918ecebdf1b4d222?f=discussion * 来源：牛客网 */ public class Solution { public boolean IsBalanced_Solution(TreeNode root) { return getDepth(root) != -1; } private int getDepth(TreeNode root) { if (root == null) return 0; int left = getDepth(root.left); if (left == -1) return -1; int right = getDepth(root.right); if (right == -1) return -1; return Math.abs(left - right) &amp;gt; 1 ? -1 : 1 + Math.max(left, right); } } JS实现 /* function TreeNode(x) { this.</description>
    </item>
    
    <item>
      <title>38.二叉树的深度</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_38.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 07 Mar 2021 20:39:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_38.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function TreeDepth(pRoot) { // write code here if (pRoot == null) { return 0; } const left = TreeDepth(pRoot.left); const right = TreeDepth(pRoot.right); return Math.max(left, right) + 1; } More 牛客网题解
https://www.nowcoder.com/questionTerminal/435fb86331474282a3499955f0a41e8b?f=discussion</description>
    </item>
    
    <item>
      <title>22.从上往下打印二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_22.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 07 Mar 2021 20:38:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_22.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 从上往下打印出二叉树的每个节点，同层节点从左至右打印。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function PrintFromTopToBottom(root) { // write code here let result = []; if (root === null) { return result; } let q = []; q.push(root); while (q.length != 0) { let len = q.length; for (let i = 0; i &amp;lt; len; i++) { const node = q.shift(); result.push(node.val); if (node.left != null) { q.</description>
    </item>
    
    <item>
      <title>18.二叉树的镜像</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sun, 07 Mar 2021 20:36:23 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>题目 操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述: 二叉树的镜像定义
//源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 //镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function Mirror(root) { // write code here if (root === null) { return; } if (root.left === null &amp;amp;&amp;amp; root.right === null) { return; } let temp = root.</description>
    </item>
    
  </channel>
</rss>
