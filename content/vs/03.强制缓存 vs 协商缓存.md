---
title: "强制缓存 vs 协商缓存"
url: "vs/web-cache"
date: 2021-03-30T09:58:54+08:00
tags: ['vs']
draft: true
---

## 强制缓存

在第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求。

1、http1.0

在 `http 1.0` 版本中，强制缓存通过 `Expires` 响应头来实现。 `expires` 表示未来资源会过期的时间。也就是说，当发起请求的时间超过了 `expires` 设定的时间，即表示资源缓存时间到期，会发送请求到服务器重新获取资源。而如果发起请求的时间在 `expires` 限定的时间之内，浏览器会直接读取本地缓存数据库中的信息（from memory or from disk），两种方式根据浏览器的策略随机获取。

2、http1.1

在 `http 1.1` 版本中，强制缓存通过 `Cache-Control` 响应头来实现。`Cache-Control` 拥有多个值：

- private：客户端可以缓存；
- public：客户端和代理服务器均可缓存；
- max-age=xxx：缓存的资源将在 xxx 秒后过期；
- no-cache：需要使用协商缓存来验证是否过期；
- no-store：不可缓存；

最常用的字段就是 max-age=xxx ，表示缓存的资源将在 xxx 秒后过期。一般来说，为了兼容，两个版本的强制缓存都会被实现。

3、小结

强制缓存只有首次请求才会跟服务器通信，读取缓存资源时不会发出任何请求，资源的 `Status` 状态码为 `200`，资源的 `Size` 为 `from memory` 或者 `from disk` ，http 1.1 版本的实现优先级会高于 http 1.0 版本的实现。


## 协商缓存

协商缓存与强制缓存的不同之处在于，协商缓存每次读取数据时都需要跟服务器通信，并且会增加缓存标识。在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 304 状态码，浏览器就读取本地缓存服务器中的数据。


1、http1.0

在 http 1.0 版本中，第一次请求资源时服务器通过 Last-Modified 来设置响应头的缓存标识，并且把资源最后修改的时间作为值填入，然后将资源返回给浏览器。在第二次请求时，浏览器会首先带上 If-Modified-Since 请求头去访问服务器，服务器会将 If-Modified-Since 中携带的时间与资源修改的时间匹配，如果时间不一致，服务器会返回新的资源，并且将 Last-Modified 值更新，作为响应头返回给浏览器。如果时间一致，表示资源没有更新，服务器返回 304 状态码，浏览器拿到响应状态码后从本地缓存数据库中读取缓存资源。

这种方式有一个弊端，就是当服务器中的资源增加了一个字符，后来又把这个字符删掉，本身资源文件并没有发生变化，但修改时间发生了变化。当下次请求过来时，服务器也会把这个本来没有变化的资源重新返回给浏览器。

2、http1.1

在 `http 1.1` 版本中，服务器通过 `Etag` 来设置响应头缓存标识。`Etag` 的值由服务端生成。在第一次请求时，服务器会将资源和 `Etag` 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。在第二次请求时，浏览器会将 `Etag` 信息放到 `If-None-Match` 请求头去访问服务器，服务器收到请求后，会将服务器中的文件标识与浏览器发来的标识进行对比，如果不相同，服务器返回更新的资源和新的 `Etag` ，如果相同，服务器返回 `304` 状态码，浏览器读取缓存。

3、小结 

协商缓存每次请求都会与服务器交互，第一次是拿数据和标识的过程，第二次开始，就是浏览器询问服务器资源是否有更新的过程。每次请求都会传输数据，如果命中缓存，则资源的 `Status` 状态码为 `304` 而不是 `200` 。同样的，一般来讲为了兼容，两个版本的协商缓存都会被实现，`http 1.1` 版本的实现优先级会高于 `http 1.0` 版本的实现。

## 协商缓存实例

1、server.js

```javascript
const express = require('express');
const fs = require('fs');
const path = require('path');
const md5 = require('md5');

const app = express();
const port = 3000;

app.get('/', (req, res) => res.send('Hello World!'));

app.get('/blog', function(req, res) {
  const filePath = path.join(__dirname, 'htmls/blog.html');
  fs.stat(filePath, function(err, result){
    if (req.headers['if-modified-since'] === result.mtime.toUTCString()) {
      res.writeHead(304, 'Not Modified');
      res.end();
    } else {
      fs.readFile(filePath, function (err, data) {
        let lastModified = result.mtime.toUTCString();
        res.setHeader('Last-Modified', lastModified);
        res.writeHead(200, 'OK');
        res.end(data);
      })
    }
  })
});

app.get('/about', function(req, res) {
  const filePath = path.join(__dirname, 'htmls/about.html');
  fs.readFile(filePath, function (err, buff) {
    const etag = md5(buff);
    if (req.headers['if-none-match'] === etag) {
      res.writeHead(304, 'Not Modified');
      res.end();
    } else {
      res.setHeader('Etag', etag);
      res.writeHead(200, 'OK');
      res.end(buff);
    }
  })
});

app.listen(port, () => console.log(`Example app listening on port ${port}!`))
```

2、htmls 

```html
//about.html
<h1>about</h1>

//blog.html
<h1>blog</h1>
```

3、安装依赖启动服务 

```bash
$ npm install express
$ npm install md5

# 启动服务
$ node server.js
```

4、 If-Modified-Since 与 Last-Modified

4.1. 请求路由blog
```bash
$ curl -I -G http://localhost:3000/blog
```

输出：
```bash
HTTP/1.1 200 OK
X-Powered-By: Express
Last-Modified: Wed, 23 Dec 2020 07:46:14 GMT
Date: Wed, 23 Dec 2020 07:55:32 GMT
Connection: keep-alive
Keep-Alive: timeout=5
```

4.2. 请求路由blog
```bash
$ curl -I -G -H "If-Modified-Since: Wed, 23 Dec 2020 07:46:14 GMT" http://localhost:3000/blog
```

```bash
HTTP/1.1 304 Not Modified
X-Powered-By: Express
Date: Wed, 23 Dec 2020 07:57:04 GMT
Connection: keep-alive
Keep-Alive: timeout=5
```

5、If-None-Match 与 Etag

5.1. 请求路由about
```bash
$ curl -I -G http://localhost:3000/about
```

输出：
```bash
HTTP/1.1 200 OK
X-Powered-By: Express
Etag: a7de0fedebb9ecc8e95af6faa7ace3d3
Date: Wed, 23 Dec 2020 07:34:14 GMT
Connection: keep-alive
Keep-Alive: timeout=5
```

5.2. 请求路由about
```bash
$ curl -I -G -H "If-None-Match: a7de0fedebb9ecc8e95af6faa7ace3d3" http://localhost:3000/about
```

输出：
```bash
HTTP/1.1 304 Not Modified
X-Powered-By: Express
Date: Wed, 23 Dec 2020 07:39:05 GMT
Connection: keep-alive
Keep-Alive: timeout=5
```

## More 

10分钟彻底搞懂Http的强制缓存和协商缓存  
https://segmentfault.com/a/1190000016199807