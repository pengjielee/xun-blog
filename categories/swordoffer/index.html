<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/monokai-sublime.min.css" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
        <div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="title">Swordoffer</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/sword/array_50.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">50.数组中重复的数字</a>
    </div><div class="post-meta">
    <div class="date">2021-03-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/array/" rel="tag">array</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
详解 排序：将输入数组排序，再判断相邻位置是否存在相同数字，如果存在，对 duplication 赋值返回，否则继续比较
JS实现 function duplicate(numbers, duplication) { // write code here if (numbers.length &lt;= 0) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/47.%E6%B1%821&#43;2&#43;3&#43;...&#43;n/">47.求1&#43;2&#43;3&#43;...&#43;n</a>
    </div><div class="post-meta">
    <div class="date">2021-03-12</div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 求1+2+3+&hellip;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
详解 短路原理
JS实现 function Sum_Solution(n) { // write code here let result = n; result &amp;&amp; (result += Sum_Solution(n - 1)); return result; } </div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/45.%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/">45.扑克牌顺子</a>
    </div><div class="post-meta">
    <div class="date">2021-03-12</div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 LL今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王(一副牌原本是54张^ _ ^)&hellip;他随机从中抽出了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！&ldquo;红心A，黑桃3，小王，大王，方片5&rdquo;，&ldquo;Oh My God!&ldquo;不是顺子&hellip;..
LL不高兴了，他想了想，决定大小 王可以看成任何数字，并且A看作1，J为11，Q为12，K为13。上面的5张牌就可以变成&quot;1，2，3，4，5&rdquo;(大小王分别看作2和4)，&ldquo;So …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/67.%E5%89%AA%E7%BB%B3%E5%AD%90/">67.剪绳子.md</a>
    </div><div class="post-meta">
    <div class="date">2021-03-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/dp/" rel="tag">dp</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],&hellip;,k[m]。 请问k[0] x k[1] x &hellip; x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
输入描述: 输入一个数n，意义见题面。（2 &lt;= n &lt;= 60） 输出描述: 输出答案。 示例1 输入 8 输出 18 详解 动态规划（自底向上）
使用动态规划，从已知值 F(2) 逐步迭代到目标值 F(n)，它是一种自底向上的方法。
 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/array_06.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/">06.旋转数组的最小数字</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/array/" rel="tag">array</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组 {3,4,5,1,2} 为 {1,2,3,4,5} 的一个旋转，该数组的最小值为1。
原来的：{1,2,3,4,5}
旋转后：{3,4,5,1,2}
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
详解 旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的值 都大于 后面子数组中的元素。
注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。
思路：
我们用 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/string_02.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">02.替换空格</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/string/" rel="tag">string</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy。则经过替换之后的字符串为We%20Are%20Happy。
JS实现 //实现1：调用自带函数 function replaceSpace(str) { // write code here return str.replace(/\s{1}/g, &#34;%20&#34;); } //实现2：用新的变量存，当遇到 &#34; &#34;，就追加 &#34;%20&#34;，否则遇到什么追加什么 function replaceSpace(str) { // write code …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">04.重建二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
详解 前序：根-&gt;左-&gt;右 {1,2,4,7,3,5,6,8} 中序：左-&gt;根-&gt;右 {4,7,2,1,5,3,8,6}
根据中序遍历和前序遍历可以确定二叉树，具体过程为：
根据前序序列第一个结点确定根结点； 根据根结点在中序序列中的位置分割出左右两个子序列； 对左子树和右子树分别递归使用同样的方法继续分解； 例如： 前序序 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/array_01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">01.二维数组中的查找</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/array/" rel="tag">array</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] 详解 暴力法 挨个遍历数组，如果找到就返回 true
时间复杂度：O(n^2) 空间复杂度：O(1)
从左下找 利用该二维数组的性质：
每一行都按照从左到右递增的顺序排序， 每一列都按照从上到下递增的顺序排序 换个说法，即对于左下角的值 m，m 是该行最小的数，是该列最大的数
每次将 m 和目标值 target 比较：
当 m …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">17.树的子结构</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function HasSubtree(root1, root2) { // write code here if (root1 === null || root2 === null) { return false; } let result = false; if (root1.val === root2.val) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/19.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/">19.顺时针打印矩阵</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字， 例如，
如果输入如下4 X 4矩阵：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10.
详解 简单来说，就是不断地收缩矩阵的边界。
定义四个变量代表范围，up、down、left、right
向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 向下走存入整列的值，当存入后，该列再也不会被遍历， …</div>
    
</div>

        </section>
        
    <div class="pagination">
        <span class="pagination__item pagination__item--current">1/3</span>
            <a class="pagination__item pagination__item--next" href="/categories/swordoffer/page/2/">Next</a>
    </div>

    </div>

        </div><script src="/js/highlight.min.js"></script>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre").forEach((block) => {
            hljs.highlightBlock(block);
        });
        
        
        
        
        
        
        
        
        
        
    });
</script>
</body>
</html>
