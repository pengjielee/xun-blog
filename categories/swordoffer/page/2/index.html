<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/monokai-sublime.min.css" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
        <div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page page-list">
        <h1 class="title">swordoffer</h1>
        <section class="list">
            <div class="item">
    <div class="title">
        <a href="/post/sword/array_50.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">50.数组中重复的数字</a>
    </div><div class="post-meta">
    <div class="date">2021-03-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/array/" rel="tag">array</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
详解 排序：将输入数组排序，再判断相邻位置是否存在相同数字，如果存在，对 duplication 赋值返回，否则继续比较
JS实现 function duplicate(numbers, duplication) { // write code here if (numbers.length &lt;= 0) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/47.%E6%B1%821&#43;2&#43;3&#43;...&#43;n/">47.求1&#43;2&#43;3&#43;...&#43;n</a>
    </div><div class="post-meta">
    <div class="date">2021-03-12</div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 求1+2+3+&hellip;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
详解 短路原理
JS实现 function Sum_Solution(n) { // write code here let result = n; result &amp;&amp; (result += Sum_Solution(n - 1)); return result; } </div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/45.%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/">45.扑克牌顺子</a>
    </div><div class="post-meta">
    <div class="date">2021-03-12</div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 LL今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王(一副牌原本是54张^ _ ^)&hellip;他随机从中抽出了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！&ldquo;红心A，黑桃3，小王，大王，方片5&rdquo;，&ldquo;Oh My God!&ldquo;不是顺子&hellip;..
LL不高兴了，他想了想，决定大小 王可以看成任何数字，并且A看作1，J为11，Q为12，K为13。上面的5张牌就可以变成&quot;1，2，3，4，5&rdquo;(大小王分别看作2和4)，&ldquo;So …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/67.%E5%89%AA%E7%BB%B3%E5%AD%90/">67.剪绳子.md</a>
    </div><div class="post-meta">
    <div class="date">2021-03-12</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/dp/" rel="tag">dp</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],&hellip;,k[m]。 请问k[0] x k[1] x &hellip; x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
输入描述: 输入一个数n，意义见题面。（2 &lt;= n &lt;= 60） 输出描述: 输出答案。 示例1 输入 8 输出 18 详解 动态规划（自底向上）
使用动态规划，从已知值 F(2) 逐步迭代到目标值 F(n)，它是一种自底向上的方法。
 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/array_06.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/">06.旋转数组的最小数字</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/array/" rel="tag">array</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组 {3,4,5,1,2} 为 {1,2,3,4,5} 的一个旋转，该数组的最小值为1。
原来的：{1,2,3,4,5}
旋转后：{3,4,5,1,2}
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
详解 旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的值 都大于 后面子数组中的元素。
注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。
思路：
我们用 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/string_02.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">02.替换空格</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/string/" rel="tag">string</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy。则经过替换之后的字符串为We%20Are%20Happy。
JS实现 //实现1：调用自带函数 function replaceSpace(str) { // write code here return str.replace(/\s{1}/g, &#34;%20&#34;); } //实现2：用新的变量存，当遇到 &#34; &#34;，就追加 &#34;%20&#34;，否则遇到什么追加什么 function replaceSpace(str) { // write code …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">04.重建二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
详解 前序：根-&gt;左-&gt;右 {1,2,4,7,3,5,6,8} 中序：左-&gt;根-&gt;右 {4,7,2,1,5,3,8,6}
根据中序遍历和前序遍历可以确定二叉树，具体过程为：
根据前序序列第一个结点确定根结点； 根据根结点在中序序列中的位置分割出左右两个子序列； 对左子树和右子树分别递归使用同样的方法继续分解； 例如： 前序序 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/array_01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">01.二维数组中的查找</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/array/" rel="tag">array</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] 详解 暴力法 挨个遍历数组，如果找到就返回 true
时间复杂度：O(n^2) 空间复杂度：O(1)
从左下找 利用该二维数组的性质：
每一行都按照从左到右递增的顺序排序， 每一列都按照从上到下递增的顺序排序 换个说法，即对于左下角的值 m，m 是该行最小的数，是该列最大的数
每次将 m 和目标值 target 比较：
当 m …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">17.树的子结构</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function HasSubtree(root1, root2) { // write code here if (root1 === null || root2 === null) { return false; } let result = false; if (root1.val === root2.val) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/19.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/">19.顺时针打印矩阵</a>
    </div><div class="post-meta">
    <div class="date">2021-03-10</div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字， 例如，
如果输入如下4 X 4矩阵：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10.
详解 简单来说，就是不断地收缩矩阵的边界。
定义四个变量代表范围，up、down、left、right
向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 向下走存入整列的值，当存入后，该列再也不会被遍历， …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_59.%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">59.按之字形顺序打印二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 按之字形顺序打印二叉树
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function Print(pRoot) { // write code here let result = []; if (pRoot === null) { return result; } let q = []; q.push(pRoot); …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_58.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/">58.对称的二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function isSymmetrical(pRoot) { // write code here return isSymmetricalTree(pRoot, pRoot); } function isSymmetricalTree(node1, node2) { //判断两个节点都是否为空 if …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_39.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">39.平衡二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
平衡二叉树一般指平衡树。
平衡树(Balance Tree，BT) 指的是，任意节点的子树的高度差都小于等于1。
详解 /* * 链接：https://www.nowcoder.com/questionTerminal/8b3b95850edb4115918ecebdf1b4d222?f=discussion * 来源：牛客网 */ public class Solution { public boolean IsBalanced_Solution(TreeNode root) { return getDepth(root) != -1; …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_38.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/">38.二叉树的深度</a>
    </div><div class="post-meta">
    <div class="date">2021-03-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function TreeDepth(pRoot) { // write code here if (pRoot == null) { return 0; } const left = TreeDepth(pRoot.left); const right = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_22.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">22.从上往下打印二叉树</a>
    </div><div class="post-meta">
    <div class="date">2021-03-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 从上往下打印出二叉树的每个节点，同层节点从左至右打印。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function PrintFromTopToBottom(root) { // write code here let result = []; if (root === null) { return result; } let q = []; q.push(root); while (q.length != 0) { let len = q.length; …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/sword/binarytree_18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/">18.二叉树的镜像</a>
    </div><div class="post-meta">
    <div class="date">2021-03-07</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/binarytree/" rel="tag">BinaryTree</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述: 二叉树的镜像定义
//源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 //镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function Mirror(root) { // write code here if (root === null) { return; } if (root.left === null …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-rectangle-cover/">10.矩形覆盖</a>
    </div><div class="post-meta">
    <div class="date">2021-03-03</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/fibonacci/" rel="tag">Fibonacci</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？
比如n=3时，2 * 3的矩形块有3种覆盖方法： ()[../images/offer10.png]
详解 每次使用两个变量a，b来计算下一个数的值sum，然后a，b，sum分别是斐波那契数列中的三个数，那么就令a=b，b=sum，这样a和b就往下移动了一个位置，再计算sum就是第4个数了，重复这个过程即可。
target = 1时，1种
target = 2时，2种
target = 3时，3种
target = 4时，5种
target = n …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/jump-the-floor2/">09.变态跳台阶</a>
    </div><div class="post-meta">
    <div class="date">2021-03-03</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/fibonacci/" rel="tag">Fibonacci</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
详解 关于本题，前提是n个台阶会有一次n阶的跳法。分析如下：
f(1) = 1
f(2) = f(2-1) + f(2-2) //f(2-2)表示2阶一次跳2阶的次数。
f(3) = f(3-1) + f(3-2) + f(3-3)
&hellip;
f(n) = f(n-1) + f(n-2) + f(n-3) + &hellip; + f(n-(n-1)) + f(n-n)
说明：
这里的f(n)代表的是n个台阶有一次1,2,&hellip;,n阶的跳法数。
n=1时，只 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/jump-the-floor/">08.跳台阶</a>
    </div><div class="post-meta">
    <div class="date">2021-03-03</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/fibonacci/" rel="tag">Fibonacci</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
详解 一次1阶或者2阶的跳法： a. 如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1); b. 假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2) c. 由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2) d. 然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2 e. 可以发现最终得出的是一个斐波那契数列： | 1, (n=1) …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/fibonacci-sequence/">07.斐波那契数列</a>
    </div><div class="post-meta">
    <div class="date">2021-03-03</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/fibonacci/" rel="tag">Fibonacci</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39
斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144&hellip; , 这个数列从第3项开始，每一项都等于前两项之和。
JS实现 //递归实现 const Fibonacci = (n) =&gt; { if (n &lt;= 0) { return 0; } if (n === 1) { return 1; } return Fibonacci(n - 1) + Fibonacci(n - 2); }; // …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/use-two-stacks-to-implement-the-queue/">05.用两个栈实现队列</a>
    </div><div class="post-meta">
    <div class="date">2021-03-01</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/stack/" rel="tag">Stack</a>
                <a class="link" href="/tags/queue/" rel="tag">queue</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
详解 队列的特性是：“先进先出”，栈的特性是：“先进后出”。
当我们向模拟的队列插入数 a,b,c 时，假设插入的是 stack1，此时的栈情况为： 栈 stack1：{a,b,c} 栈 stack2：{} 当需要弹出一个数，根据队列的&#34;先进先出&#34;原则，a 先进入，则 a 应该先弹出。但是此时 a 在 stack1 的最下面，将 stack1 中全部元素逐个弹出压入 stack2，现在可以正确的从 stack2 中弹出 a，此时的栈情况为： 栈 stack1：{} …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-stack-containing-the-min-function/">20.包含min函数的栈</a>
    </div><div class="post-meta">
    <div class="date">2021-03-01</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/stack/" rel="tag">Stack</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。
详解 利用一个辅助栈来存放最小值；
每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶；
当出栈时，辅助栈也要出栈；
JS实现 var stack1 = []; var stack2 = []; // 辅助栈，存最小值 function push(node) { // write code here stack1.push(node); if (stack2.length …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-sequence-of-stack-pushin-and-popout/">21.栈的压入、弹出序列</a>
    </div><div class="post-meta">
    <div class="date">2021-03-01</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/stack/" rel="tag">Stack</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
假设压入栈的所有数字均不相等。
例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
示例1: 输入： [1,2,3,4,5],[4,5,3,2,1] 返回： true 可以通 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/print-the-linked-list-from-tail-to-head/">03.从尾到头打印链表</a>
    </div><div class="post-meta">
    <div class="date">2021-02-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
思路 利用JS数组的unshift()方法，在数组开头插入数据。
var nums = [1,2,3]; var temp = nums.unshift(4); console.log(temp); //4 console.log(nums); //[4,1,2,3] var nums = [1,2,3]; var temp = nums.shift(); console.log(temp); //1 console.log(nums); //[2,3] JS实现 /*function ListNode(x){ …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-last-k-node-in-the-linked-list/">14.链表中倒数第k个结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-22</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，输出该链表中倒数第k个结点。
思路 利用快慢指针，快指针先走k步，然后快慢指针一起走，当快指针走到末尾，那么慢指针就到了倒数第k个节点了。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function FindKthToTail(head, k) { // write code here let fast = head, slow = head; for (let i = 0; i &lt; k; i++) { if (fast === null) return; fast = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/reverse-a-linked-list/">15.反转链表.md</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入一个链表，反转链表后，输出新链表的表头。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function ReverseList(pHead) { // write code here if (pHead === null || pHead.next === null) { return pHead; } let prev = null; //记录节点的前一个节点 let next = null; //记录节点的后一个节点 while (pHead != null) { next = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/merges-two-sorted-linked-lists/">16.合并两个排序的链表</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
JS实现 1、递归实现
/*function ListNode(x){ this.val = x; this.next = null; }*/ function Merge(pHead1, pHead2) { if (pHead1 === null) { return pHead2; } if (pHead2 === null) { return pHead1; } if (pHead1.val &lt; pHead2.val) { pHead1.next = …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-first-common-node-of-two-linked-lists/">36.两个链表的第一个公共结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-18</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
思路 什么是公共节点，并不是两个节点的值相同就是公共节点。 而是在第一链表和第二链表中都存在一个节点，该节点往后的子链表在两个链表中是相同的。
如下图中链表6-7就是两个链表的公共链表，而节点6就是第一个公共节点。
1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; 7 4 -&gt; 5 -&gt; 6 -&gt; 7 如果两个链表存在公共节点，那么公共节点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，那么最后一个相同的节点就是我 …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/the-entry-node-of-the-linked-list-loop/">55.链表中环的入口结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-10</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
思路 1、设置快慢指针，假如有环，他们一定相遇在环中；
2、两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口；
JS实现 参考1
/*function ListNode(x){ this.val = x; this.next = null; }*/ function EntryNodeOfLoop(pHead) { // write code here //至少3个节点才能成环 if (!pHead || !pHead.next || !pHead.next.next) { …</div>
    
</div>
<div class="item">
    <div class="title">
        <a href="/post/delete-duplicate-nodes-in-the-linked-list/">56.删除链表中重复的结点</a>
    </div><div class="post-meta">
    <div class="date">2021-02-09</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="link" href="/tags/linkedlist/" rel="tag">LinkedList</a>
        </div>
        <div class="category">
            <label class="label">Category：</label>
            <a class="link" href="/categories/swordoffer/" rel="category">swordoffer</a>
        </div>
</div>

        <div class="summary">题目 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5
思路 非递归的代码：
1、首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况；
2、设置 pre ，last 指针， pre指针指向当前确定不重复的那个节点，而last指针相当于工作指针，一直往后面搜索。
JS实现 // 非递归法 function deleteDuplication(pHead) { if (!pHead || !pHead.next) { …</div>
    
</div>

        </section>
        
    <div class="pagination">
            <a class="pagination__item pagination__item--prev" href="/categories/swordoffer/">Prev</a>
        <span class="pagination__item pagination__item--current">2/3</span>
            <a class="pagination__item pagination__item--next" href="/categories/swordoffer/page/3/">Next</a>
    </div>

    </div>

        </div><script src="/js/highlight.min.js" />
<script>
    document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre").forEach((block) => {
            hljs.highlightBlock(block);
        });
    });
</script>
</body>
</html>
