<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
        name="viewport"
        content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="keywords" content="pengjielee,个人博客" />
    <meta name="description" content="Pengjielee的个人博客" />
    <title>Pengjielee&#39;s blog</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700" />
    <link rel="stylesheet" href="/css/style.css" />
</head>
<body><div id="main">
            <nav class="nav">
    <a href="/">首页</a> <span class="divide">|</span>
    <a href="/categories">分类</a>
    <span class="divide">|</span> <a href="/tags">标签</a>
    <span class="divide">|</span>
    <a href="/post">归档</a>
</nav>

    <div class="page-single">
        <header class="header">
            <h1 class="title">077.组合</h1><div class="post-meta">
    <div class="date">2021-04-23</div>
        <div class="tags">
            <label class="label">Tags：</label>
                <a class="tags_link" href="/tags/leetcode/" rel="tag">leetcode</a>
        </div>
</div>
</header>
        <div class="content"><h2 id="题目">题目</h2>
<p>给定两个整数 n 和 k，返回 1 &hellip; n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<pre tabindex="0"><code>输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre><p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/combinations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="思路">思路</h2>
<p>n = 4, k = 2,
[1,2,3,4]</p>
<p>1,2
1,3
1,4
2,3
2,4
3,4</p>
<h2 id="js实现">JS实现</h2>
<p>1、深度优先搜索（未剪枝）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param {number} n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param {number} k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return {number[][]}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">combine</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">k</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">k</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">k</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 路径数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">path</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 深度优先遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">dfs</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">begin</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">result</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//递归终止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">k</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">slice</span>());
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">begin</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//向路径数组添加当前元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 考查下一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">result</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 从1开始考查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">dfs</span>(<span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">result</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>2、优化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">combine</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">k</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">k</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">k</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 路径数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">path</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 深度优先遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">dfs</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">begin</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">result</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//递归终止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">k</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">slice</span>());
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 搜索起点的上界（做剪枝处理）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">max</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> (<span style="color:#a6e22e">k</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">length</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">begin</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">max</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//向路径数组添加当前元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 考查下一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">result</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 从1开始考查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">dfs</span>(<span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">result</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>如果 n = 7, k = 4，从 5 开始搜索就已经没有意义了，这是因为：即使把 5 选上，后面的数只有 6 和 7，一共就 3 个候选数，凑不出 4 个数的组合。因此，搜索起点有上界。</p>
<p>如：n = 6 ，k = 4。
path.size() == 1 的时候，接下来要选择 3 个数，搜索起点最大是 4，最后一个被选的组合是 [4, 5, 6]；
path.size() == 2 的时候，接下来要选择 2 个数，搜索起点最大是 5，最后一个被选的组合是 [5, 6]；
path.size() == 3 的时候，接下来要选择 1 个数，搜索起点最大是 6，最后一个被选的组合是 [6]；</p>
<p>再如：n = 15 ，k = 4。
path.size() == 1 的时候，接下来要选择 3 个数，搜索起点最大是 13，最后一个被选的是 [13, 14, 15]；
path.size() == 2 的时候，接下来要选择 2 个数，搜索起点最大是 14，最后一个被选的是 [14, 15]；
path.size() == 3 的时候，接下来要选择 1 个数，搜索起点最大是 15，最后一个被选的是 [15]；</p>
<p>归纳出：</p>
<ul>
<li>接下来要选择的元素个数 = k - path.size()</li>
<li>搜索起点的上界 = n - (k - path.size()) + 1</li>
</ul>
<p>作者：liweiwei1419
链接：https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div>
    </div>

        </div></body>
</html>
