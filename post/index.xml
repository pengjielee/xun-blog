<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/post/</link>
    <description>Recent content in Posts on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 24 Mar 2023 10:34:51 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>redis基础</title>
      <link>https://www.pengjielee.cn/post/redis/redis%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 24 Mar 2023 10:34:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/redis/redis%E5%9F%BA%E7%A1%80/</guid>
      <description>Redis Redis（remote dictionary server）是一个基于KEY-VALUE的高性能的存储系统
Docker安装redis $ docker pull redis $ docker run --name myredis -d -p 6379:6379 redis $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c92daf4edbfe redis &amp;#34;docker-entrypoint.s…&amp;#34; 32 seconds ago Up 32 seconds 0.0.0.0:6379-&amp;gt;6379/tcp myredis 连接redis $ redis-cli -v redis-cli 7.0.9 $ redis-cli 127.0.0.1:6379&amp;gt; 字符串 1、设置和获取键值对：get / set
127.0.0.1:6379&amp;gt; set name jim OK 127.0.0.1:6379&amp;gt; get name &amp;#34;jim&amp;#34; 2、查询是否存在和查询所有键： exists / keys
127.0.0.1:6379&amp;gt; exists name (integer) 1 127.</description>
    </item>
    
    <item>
      <title>Go合并数组和链表</title>
      <link>https://www.pengjielee.cn/post/golang/go%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 20 Mar 2023 17:46:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/go%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</guid>
      <description>合并两个有序数组 /* nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 */ func mergeArr(nums1 []int, m int, nums2 []int, n int) { p := m - 1 q := n - 1 k := len(nums1) - 1 for p &amp;gt;= 0 &amp;amp;&amp;amp; q &amp;gt;= 0 { if nums1[p] &amp;gt; nums2[q] { nums1[k] = nums1[p] p -= 1 } else { nums1[k] = nums2[q] q -= 1 } k -= 1 } for q &amp;gt;= 0 { nums1[k] = nums2[q] q -= 1 k -= 1 } } 合并两个有序链表 type Node struct { data interface{} next *Node } func mergeList(l1 *Node, l2 *Node) *Node { if l1 == nil { return l2 } if l2 == nil { return l1 } var l3 = &amp;amp;Node{} var current = l3 for l1 !</description>
    </item>
    
    <item>
      <title>Go递归遍历二叉树</title>
      <link>https://www.pengjielee.cn/post/golang/go%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 20 Mar 2023 17:31:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/go%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 前序遍历 func preorderTraversal(root *TreeNode) []int { var result []int preorder(root, &amp;amp;result) return result } func preorder(root *TreeNode, output *[]int) { if root != nil { *output = append(*output, root.Val) preorder(root.Left, output) preorder(root.Right, output) } } 中序遍历 func inorderTraversal(root *TreeNode) []int { var result []int inorder(root, &amp;amp;result) return result } func inorder(root *TreeNode, output *[]int) { if root != nil { inorder(root.</description>
    </item>
    
    <item>
      <title>Go判断回文数</title>
      <link>https://www.pengjielee.cn/post/golang/go%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Mon, 20 Mar 2023 17:07:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/go%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>解法一
func isPalindrome(x int) bool { //负数不是回文数 if x &amp;lt; 0 { return false } if x%10 == 0 &amp;amp;&amp;amp; x != 0 { return false } arr := make([]int, 0, 32) for x &amp;gt; 0 { arr = append(arr, x%10) x = x / 10 } for i, j := 0, len(arr)-1; i &amp;lt;= j; i, j = i+1, j-1 { if arr[i] != arr[j] { return false } } return true } 解法二</description>
    </item>
    
    <item>
      <title>Go实现二分查找</title>
      <link>https://www.pengjielee.cn/post/golang/go%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 20 Mar 2023 13:15:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/go%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>二分查找 需要注意的三点：
循环退出条件，注意是 low &amp;lt;= high，而不是 low &amp;lt; high。 mid 的取值，mid := low + (high-low)/2 low 和 high 的更新。low = mid + 1，high = mid - 1。 package main import ( &amp;#34;fmt&amp;#34; ) func main() { s1 := []int{1, 3, 4, 6, 9} fmt.Println(binarySearch(s1, 6)) //3 } func binarySearch(nums []int, target int) int { low, high := 0, len(nums)-1 for low &amp;lt;= high { mid := low + (high-low)/2 if nums[mid] == target { return mid } else if nums[mid] &amp;gt; target { high = mid - 1 } else { low = mid + 1 } } return -1 } 查找第一个与 target 相等的元素 package main import ( &amp;#34;fmt&amp;#34; ) func main() { s1 := []int{1, 3, 4, 4, 6, 9} fmt.</description>
    </item>
    
    <item>
      <title>Weekly-2023.03.20</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2023.03.20/</link>
      <pubDate>Mon, 20 Mar 2023 10:14:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2023.03.20/</guid>
      <description>2022大前端总结和2023就业分析 - 掘金 (juejin.cn) https://juejin.cn/post/7196110128038690876
Go方式的字符串反转 https://zhuanlan.zhihu.com/p/78550943
shell 获取当前日期，当前时间 https://blog.csdn.net/kl28978113/article/details/78845198
三分钟学会使用 Docker 部署前端 https://cloud.tencent.com/developer/article/1906560
什么是 DevOps？ https://azure.microsoft.com/zh-cn/resources/cloud-computing-dictionary/what-is-devops/
DevOps到底是什么意思？ https://zhuanlan.zhihu.com/p/91371659</description>
    </item>
    
    <item>
      <title>008.Go语言switch语句</title>
      <link>https://www.pengjielee.cn/post/golang/008.go%E8%AF%AD%E8%A8%80switch%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sun, 04 Dec 2022 14:12:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/008.go%E8%AF%AD%E8%A8%80switch%E8%AF%AD%E5%8F%A5/</guid>
      <description>问好 package main import ( &amp;#34;fmt&amp;#34; ) func main() { var name string fmt.Printf(&amp;#34;请输入姓名：&amp;#34;) fmt.Scanln(&amp;amp;name) switch name { case &amp;#34;jim&amp;#34;: fmt.Println(&amp;#34;你好 &amp;#34; + name) case &amp;#34;tom&amp;#34;: fmt.Println(&amp;#34;hello &amp;#34; + name) case &amp;#34;mike&amp;#34;: fmt.Println(&amp;#34;hi &amp;#34; + name) case &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;: fmt.Println(&amp;#34;输入错误&amp;#34;) default: fmt.Println(&amp;#34;您好 &amp;#34; + name) } } </description>
    </item>
    
    <item>
      <title>007.Go语言循环语句</title>
      <link>https://www.pengjielee.cn/post/golang/007.go%E8%AF%AD%E8%A8%80%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sun, 04 Dec 2022 13:43:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/007.go%E8%AF%AD%E8%A8%80%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</guid>
      <description>计算 1 到 10 的数字之和 package main import ( &amp;#34;fmt&amp;#34; ) func main() { var sum = 0 for i := 0; i &amp;lt;= 10; i++ { sum += i } fmt.Println(sum) } sum 小于 10 的时候计算 sum 自相加后的值 package main import &amp;#34;fmt&amp;#34; func main() { //sum 小于 10 的时候计算 sum 自相加后的值 sum := 1 for sum &amp;lt;= 10 { sum += sum } fmt.Println(sum) // 这样写也可以，更像 While 语句形式 for sum &amp;lt;= 10 { sum += sum } fmt.</description>
    </item>
    
    <item>
      <title>006.Go语言条件语句</title>
      <link>https://www.pengjielee.cn/post/golang/006.go%E8%AF%AD%E8%A8%80%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sun, 04 Dec 2022 13:39:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/006.go%E8%AF%AD%E8%A8%80%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</guid>
      <description>判断用户年龄 package main import ( &amp;#34;fmt&amp;#34; ) func main() { var age int fmt.Printf(&amp;#34;请输入年龄：&amp;#34;) fmt.Scanln(&amp;amp;age) if age &amp;gt;= 18 { fmt.Println(&amp;#34;您已成年，可以上网。&amp;#34;) } else { fmt.Println(&amp;#34;未成人不能上网！&amp;#34;) } } </description>
    </item>
    
    <item>
      <title>005.Go获取用户输入</title>
      <link>https://www.pengjielee.cn/post/golang/005.go%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</link>
      <pubDate>Sun, 04 Dec 2022 13:01:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/005.go%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</guid>
      <description>从控制台读取输入 方式1：
package main import ( &amp;#34;fmt&amp;#34; ) func main() { var name string var age int fmt.Printf(&amp;#34;请输入姓名：&amp;#34;) fmt.Scanln(&amp;amp;name) fmt.Printf(&amp;#34;请输入年龄：&amp;#34;) fmt.Scanln(&amp;amp;age) fmt.Printf(&amp;#34;输入的姓名：%v, 年龄:%v \n&amp;#34;, name, age) } 方式2：
package main import ( &amp;#34;fmt&amp;#34; ) func main() { var name string var age int fmt.Scanf(&amp;#34;%s %d&amp;#34;, &amp;amp;name, &amp;amp;age) fmt.Printf(&amp;#34;姓名:%v,年龄:%v&amp;#34;, name, age) } 从缓冲读取输入 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;bufio&amp;#34; ) func main() { //创建一个读取器，并将其与标准输入绑定。 reader := bufio.NewReader(os.Stdin) //读取器对象提供一个方法 ReadString(delim byte) ，该方法从输入中读取内容，直到碰到 delim 指定的字符，然后将读取到的内容连同 delim 字符一起放到缓冲区。 input, err := reader.</description>
    </item>
    
    <item>
      <title>004.Go语言变量声明</title>
      <link>https://www.pengjielee.cn/post/golang/004.go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sun, 04 Dec 2022 12:22:52 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/004.go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</guid>
      <description>使用var关键字，后跟所需的名称以及变量将保存的值的类型。 var 变量名称 变量类型 //声明字符串变量 var message string //声明int变量 var number int //声明bool变量 var flag bool 声明变量并赋值 var message string = &amp;#34;hello world&amp;#34; 同一语句中为多个变量赋值 var width, height, name = 10, 20, &amp;#34;jack&amp;#34; 如果在声明变量的同时为其赋值，通常可以在声明中省略变量类型。 var width = 10 var height = 30 var name = &amp;#34;Jack&amp;#34; 短变量声明 你不必很明确地声明变量的类型并在之后使用=为其赋值，而是同时使用:=
package main import &amp;#34;fmt&amp;#34; func main() { customerName := &amp;#34;Jack&amp;#34; number := 4 width,height := 3, 4 fmt.Println(customerName) fmt.Println(&amp;#34;has ordered&amp;#34;, number) fmt.Println(width*height, &amp;#34;square meters&amp;#34;) } </description>
    </item>
    
    <item>
      <title>003.Go语言数据类型</title>
      <link>https://www.pengjielee.cn/post/golang/003.go%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 04 Dec 2022 11:32:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/003.go%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>字符串 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { //定义字符串变量 var message string //打印变量类型 fmt.Println(reflect.TypeOf(message)) //string //打印变量 fmt.Println(message) //&amp;#34;&amp;#34;，默认为空字符串 message = &amp;#34;Hello World&amp;#34; fmt.Println(message) //Hello World } int类型 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { //定义变量 var age int //打印变量类型 fmt.Println(reflect.TypeOf(age)) //int //打印变量 fmt.Println(age) //0，未赋值时默认为0 age = 20 fmt.Println(age) //20 age = &amp;#39;hello&amp;#39; //报错: 20:8: more than one character in rune literal } float类型 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { var price float32 //打印变量类型 fmt.</description>
    </item>
    
    <item>
      <title>002.第一个Go程序.md</title>
      <link>https://www.pengjielee.cn/post/golang/002.%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 04 Dec 2022 10:55:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/002.%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E7%A8%8B%E5%BA%8F/</guid>
      <description>第一个Go程序，打印Hello World 创建文件hello.go，内容如下：
// package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 package main //导入 fmt 包 import &amp;#34;fmt&amp;#34; // 这是单行注释 /* 这是多行注释 这是多行注释 */ //程序开始执行的函数 func main() { /* 打印Hello World， 并换行 */ fmt.Println(&amp;#34;Hello World&amp;#34;) } 格式化代码 $ go fmt hello.go 执行Go程序 $ go run hello.go Hello World 生成二进制文件 $ go build hello.go $ ls hello	hello.go $ ./hello Hello World </description>
    </item>
    
    <item>
      <title>001.安装Go</title>
      <link>https://www.pengjielee.cn/post/golang/001.%E5%AE%89%E8%A3%85go/</link>
      <pubDate>Sun, 04 Dec 2022 10:34:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/golang/001.%E5%AE%89%E8%A3%85go/</guid>
      <description>下载Go https://golang.org/dl/
如打不开，使用下面这个地址：
https://golang.google.cn/dl/
查看是否安装成功 $ go version go version go1.19.3 darwin/amd64 查看Go的环境变量 $ go env Go Playground https://go.dev/play/
or
https://goplay.tools/
Go语言教程 https://www.runoob.com/go/go-tutorial.html
http://c.biancheng.net/golang/
https://golang.google.cn/
https://www.w3cschool.cn/yqbmht/7rcvwcqm.html</description>
    </item>
    
    <item>
      <title>极权主义的20个特征</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9E%81%E6%9D%83%E4%B8%BB%E4%B9%89%E7%9A%8420%E4%B8%AA%E7%89%B9%E5%BE%81/</link>
      <pubDate>Fri, 11 Nov 2022 17:43:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9E%81%E6%9D%83%E4%B8%BB%E4%B9%89%E7%9A%8420%E4%B8%AA%E7%89%B9%E5%BE%81/</guid>
      <description>胡适介绍的极权主义的二十个特征：
1、 狭义的国家主义情绪，提高至宗教狂的程度。
2、 由一个军队般严格约束的政党，来执掌国家的政权。
3、 严厉取缔一切反对政府的意见。
4、 把超然的宗教信仰，降低到国家主义的宗教之下。
5、 “领袖”是—般信仰的中心，实际上，他也就等于一个神。
6、 提倡反理智反知识，谄媚无知的民众，严惩诚实的思想。
7、 毁灭书籍，曲解历史及科学上的真理。
8、 废除纯粹寻求真理的科学与学问。
9、 以武断代替辩论，由政党控制新闻。
10、 使人民陷于文化的孤立，对外界的真实情况，无从知晓。
11、 由政党统制一切艺术文化。
12、 破坏政治上的信义，使用虚妄伪善的手段。
13、 政府有计划地实施罪恶行为。
14、 鼓励人民陷害及虐待所谓“公共敌人”。
15、 恢复野蛮的家族连坐办法，对待这种“公共敌人”。
16、 准备永久的战争，把人民军事化。
17、 不择手段的鼓励人口增加。
18、 把“劳工阶级对资本主义革命”的口号，到处滥用。
19、 禁止工人罢工和抗议，摧毁一切劳工运动。
20、 工业、农业、商业，皆受执政党及领袖的统制。</description>
    </item>
    
    <item>
      <title>黄河边的中国</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E9%BB%84%E6%B2%B3%E8%BE%B9%E7%9A%84%E4%B8%AD%E5%9B%BD/</link>
      <pubDate>Mon, 24 Oct 2022 16:42:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E9%BB%84%E6%B2%B3%E8%BE%B9%E7%9A%84%E4%B8%AD%E5%9B%BD/</guid>
      <description>曹锦清
前言 观察转型过程中的中国社会，可以有两个不同的“视点”（或说“立场”），每一个“视点”可以有两个不同的“视角”。第一个“视点”的两个“视角”是：“从外向内看”与“从上往下看”；第二个“视点”的两个“视角”是：“从内向外看”与“从下往上看”。
所谓“外”，就是西方社会科学理论与范畴。
所谓“内”，即中国自身的历史与现实尤其指依然活跃在人们头脑中的习惯观念与行为方式中的强大传统；所谓“上”，是指中央，指传递、贯彻中央各项现代化政策的整个行政系统。
所谓“下”，意指与公共领域相对应的社会领域，尤其是指广大的农民、农业与农村社会。
中国现代化的目标、实现途径及速率，归根到底是受中国农民、农业与农村现代化的目标、途径与速度所制约的。
对于乡村社会调查来说，第一个大问题是如何“入场”，第二个大问题是如何保存“现场”。
正式的“入场”方式只有一途，那就是通过官方的许可与支持，自上而下地逐级深入。这一“入场方式”的缺陷是，“入场”环节太多，应酬耗时太多，且官员陪同入场本身极易“破坏”现场，从而使调查失实。
实际状况是日益庞大、逐渐凌驾社会之上的地方政府到处在与农民争食那块很难做大的老蛋糕，地方财政用于“吃饭”、“办公”尚且拮据，遑论“办事”。
穷有穷病，富有富病，与穷病、富病相比，穷而急富之病更为可怕，因为此病可能使自我迷失，结果便是“邯郸学步”或“东施效颦”。
曹锦清1998年12月1日
上编 初入中原（1996年5月12日—6月26日） 凡官方色彩过浓的调查，往往有两个弊端，其一是大量的时间耗在各种官场的应酬上，其二是上级官吏的陪同本身会干扰调查现场，从而收集不到客观真实的调查资料。
中国人习惯的交往方式是：“亲戚的亲戚，也是我的亲戚；朋友的朋友，便是我的朋友。”
这场由政治家自觉发动的改革，如今似乎走上了自发的道路。由改革引发出来的社会自发力量，如今已形成一股汹涌澎湃的潮流，冲击着社会各阶层的生活秩序与观念。政治家们试图将各种盲目的、自发的社会力量纳入政策法令的预设轨道，思想家们则试图从理论上去认识它们。
理论必须源于这些普遍的感受、情绪与意见，同时又必须高于它们。
社会调查的目的是收集社会事实。但社会事实不同于物理事实，因为所有社会事实都是由有感受、有思虑、有欲求、有激情的人参与的。当我们分析任何一个社会事实时，应将其区分为社会事件与社会心理两个方面。
5月13日 认识汤小平 对河南农民、农业、农村与基层政权作广泛的社会调查，必须采用点面结合的办法。有点无面，失在狭窄；有面无点，失在空泛。以点为主，以面为辅，点面结合，方能完成本次调查的预设目标。
我说，“学而优则仕”是孔老夫子的训示。“书中自有黄金屋，书中自有颜如玉”是宋明的官谣，用金钱与女色来奖掖知识分子，实非当代的发明。如今知识分子用文凭、学历、文章来敲职称、住房、官职之门，实自古而然。
当今中国似乎有三套语言：一是传媒官话，空洞无物。二是校园讲义，没有根基。这套从西方传入的学术语言，在中国这块土地上找不到它们的所指，成为漂浮在知识分子表层思维与语言中的浮萍。三是民间语言，尤其是酒席语言，反映出变动着的社会事实与社会情绪，语言活泼而富有生气。
我一直以为，缺乏协商与合作的精神与能力，是中国农民与农村中的一大问题。合作化、集体化运动，似乎并没有教会我们农民兄弟的合作意识与能力。
中国的党校，是一个组织十分完备的系统，这个系统的研究机构与人员，能够配合我的调查；这个系统的学员，本身就是我的调查对象；这个系统还是当地“社会关系网”的一个重要“纽结”。沿着党校的师生与亲友关系能把我引向我想到达的任何一个“调查现场”。
5月14日 参观大相国寺 心理时间随着生活内容的变化或重复而有快慢之分。
有组织方有管理，而组织的目的，是通过分工协作以完成非单个人所能完成的事。故“所做之事”为组织目的，分工协作是其方法。管理的实质在于，尽可能地降低组织内部的协调成本，以提高办事效率。
关键的问题或在于，我们民族千百年来在村落文化中形成的习惯行为和合作方式与现代管理要求之间的冲突。或说，是普遍化的规章制度与我们习惯的人情交往方式的冲突。
近百年来，我们这个民族似乎失去了“自我”，以至于我们这些处于大改革时代的一代人，向前忙乱地跑了一阵之后，突然彷徨回顾，既找不到来路，又看不清去路，内心积压着焦虑与困惑。不知我们从哪里来，要到哪里去，如今又处在何时何地？
和尚如今成了一种职业，寺庙成了打工挣钱之地。出家做和尚，也得拉关系，走后门。不少人“出家”的目的仅在于“还家”，或说建立一个家庭。
俗话说：“无事不登三宝殿”，又说“临事抱佛脚”。这实在是绝大多数中国人对佛教的基本态度。孔子说“未知生，焉知死”，中国人所关注的是此生此世，对灵魂、天国的有无向来存而不问。
现世精神，对具有基督教传统的西方社会来说，是一种非常近代的精神。
出大相国寺，抬头方见雕刻在佛殿屋脊的八个大字：风调雨顺，国泰民安。这不正是黄河流域农耕文化内最普遍的心愿吗？
5月15日 得到开封党校的协助 中国的现代化，以农业现代化，即广义上说的农业、农民与农村的现代化最为关键，任务也最为繁重。
毛泽东的农业合作化、集体化是进行中国农业、农民、农村现代化的一次伟大的尝试，单纯地用成功或失败并不足以评价这场规模空前的运动。
这一改革确实解决了农业产量与农民生活长期停滞不前的大问题，但其所引发出来的一系列经济、政治与文化后果，一部分已开始显现，一部分还深藏在未来的发展之中。
对于中西部广大农村来说，应该而且可能实现的现代化发展目标究竟是什么？
观察访谈实质上是研究者与被研究对象的一场持续深入的对话。
但“熟悉”与“习以为常”恰恰是理性追问的大敌。理性往往在“熟悉”与“习以为常”面前停止了分析与追问，原因恰恰在于“我已经知道了”。因此，无知状态能把一切熟悉的现象当作不熟悉的东西而加以观察、提问与思考。同时，无知状态还包括“理论上的悬置”。所谓“悬置”状态，即将我们头脑中已有的理论、概念与假设，在调查过程中暂时地悬置起来。这就是说，不要用先入为主的概念去套裁经验材料，而应让概念与经验事实自由地结合，或依据经验事实对概念作出必要的修正。
为落实农村计划生育任务，乡村干部使用各种他们认为行之有效的手段：从罚款到体罚；从牵牛羊搬家具到破门、毁屋；从直系亲属连保到邻里连保。然内地乡村的超生率，依然高达25～30%。
超生罚款成为内地不少村、乡、县“预算外收入”的重要来源。
超生罚款的分配，乡镇留存50%，上缴县20%，返回村委30%。
故为了征收到足额的超生罚款，往往放松生育控制。罚款从手段成为目的，而罚款的目的也便走向它的反面。
分田到户后，分散经营的农户缺乏一个真正保护自己利益的组织。面对凌驾于他们之上的地方政府与官员名目繁多的税收，农户先是忍气吞声，继而上访上告。最后必然是“官逼民反”。
如果我们将中国的农村放到“从传统向现代化发展”这一历史过程中加以思考的话，那么能否以及如何建设一个精简、廉洁且高效的地方政府，是关涉到中国共产党能否领导我们这个依然是农民占多数的民族完成现代化任务的根本性问题。
一是伊斯兰教堂内为何没有神画与神像，甚至连想象真主的模样也有罪过。二是改革开放后，为什么信教的人反而日见增多。
5月16日 信步铁塔公园 旁有一副对联：“诸恶莫作，诸善信奉，已了如来意；四大皆空，五蕴非有，此乃波罗蜜心。”上联是俗谛，下联是真谛。真俗并举，雅俗共赏。俗谛是对中下根器众人的说法，真谛是对上根器人的说法，针对不同的对象，进行不同的教育，佛教所谓“方便”，我们称之为“因材施教
一个社会的意识形态，核心是确定善恶标准。那么善恶标准的基础或根源在何处呢？它既不在个人之内，也不在社会之外，而在社会共同体内。
老庄的道，宋明儒学的理，释教的佛，基督教的上帝，伊斯兰教的真主，古希腊哲学中的逻各斯，近代西方哲学中的规律，便是用来奠定人间社会善恶的基石。
聪明的现代人不信这套说教，于是善恶标准便模糊起来了，只得用法律从外部规定人们的行为标准。
人间道德实践的一个令人尴尬的问题是，人们暗中都渴望作恶，但又害怕别人对他作恶，故而善恶标准只活跃在人们的道德评价中而不是落实在各自的道德实践中。
现代人发明了科学，又发明了市场经济与民主政治，在人的自然需求之上增长着无穷无尽的人为需求。到处活跃着的激情、利益与偏好汹涌澎湃
无限的贪欲被现代经济学家视为推动生产发展与社会进步的基本动力。现在的问题是，大部分注定无法满足的欲求完全有可能冲毁道德与法律设置的脆弱堤坝。一切宗教的目的在于将这股无法在世间实现的欲流引向天国，从而维持世间的秩序。
从穷乡僻壤到繁华都市，到处充塞着希望一夜致富的骚动人群。用加快发展经济来满足更多的欲求，这是一回事；总有更多的欲求得不到满足，又是另一回事。那么如何来对付这些注定无法在现实中实现的欲求呢？
佛塔一般单数，通常十三层，这说明“十三”在佛教中是个吉祥数，
一个时代普遍的社会心理与观念乃是社会存在的反映。随着人们生存方式与社会结构的变化，社会心理与观念也随之发生变化。
现代人将爱情理解为婚姻的基础，又将契约理解为政治社会的基础。将捉摸不定的爱情作为合法婚姻结合的基础，实为消除婚姻实行同居铺平了道路；将同意作为国家的基础，唯一可行的便是西方式的民主制，这使得一切以革命手段夺取并建立的政权，在寻找合法性证明时遇到难以克服的困难。
每个人都以自身为目的
市场经济的本性就是将一个又一个的人从他们各自所属的家族伦理共同体与国家伦理共同体内“揪出来替自己服务”。不仅各种生产组织而且家庭与国家都得为满足个人的需要服务。我们向“市场经济”要效率与富裕，市场经济社会同时给了我们个人主义、享乐主义与拜金主义。
我们已经急不可待地闯进了这个陌生的社会，能否从古代的道德智慧中寻找医治这个社会内已到处发作的心理与精神疾病呢？
理论是灰色的，生活之树常青。
首先要研究改革“是什么”、“可能如何”。
5月17日 包公祠断想 “端起碗来吃肉，放下筷子骂娘”，这一社会心理现象在80年代便引起人们的注意</description>
    </item>
    
    <item>
      <title>列宁政治遗产十论</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E5%88%97%E5%AE%81%E6%94%BF%E6%B2%BB%E9%81%97%E4%BA%A7%E5%8D%81%E8%AE%BA/</link>
      <pubDate>Fri, 14 Oct 2022 17:02:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E5%88%97%E5%AE%81%E6%94%BF%E6%B2%BB%E9%81%97%E4%BA%A7%E5%8D%81%E8%AE%BA/</guid>
      <description>周尚文
序一 正确地评价一个人是很难的，正确地评价一位伟人更难，尤其是评价列宁，那是难上加难。他创建了世界上第一个社会主义国家，把马克思主义理论变成了光辉的现实，可是70多年后，由他亲手缔造的苏维埃社会主义共和国联盟解体了。怎么看这个问题、怎么评价列宁就成了个大难题。
有人说列宁是罪人，要拆掉列宁塑像；有人仍讲列宁是伟人，坚决反对拆掉列宁塑像。拆也不是，不拆也不是，怎么办？
他认为列宁既不是神，也不是鬼，与历史上许许多多伟人一样，列宁是伟人，是一个有远见卓识、丰富感情，又有错误缺点的伟人。
我们把中国已经建设几十年的社会主义社会称为“初级阶段”。那么整整一百年前开始的列宁时期的社会主义应当称为什么？不用说，只能是“社会主义初级阶段的初级阶段”，或曰：“试验阶段”。
列宁驱赶持有不同政见的学者是化友为敌，是摧残学术，削弱自己。
任何伟人都有历史局限性。
列宁还提出过“向敌人学习”。他所指的“向敌人学习”，是学习敌人的长处。
列宁的一生是一心为国家、为人类着想的一生。
1920年12月，他提出“共产主义就是苏维埃政权加全国电气化”。
他曾庄严指出：无产阶级对敌人专政并不消灭本阶级内部的民主。他主张给最大多数人最高类型的民主。
序二 列宁主义从根本上说是可供实际操作的战略和策略，它具有创新、求实、可变的特性，也不可避免地带有极端、片面和机会主义的特性。
将马克思主义和列宁主义合并成‘马克思列宁主义’，是十分不科学的”。
列宁逝世后，斯大林树起列宁主义的旗帜，以标榜自己是列宁事业的继承人。
教条化扼杀了列宁主义鲜活的创造精神，造成全党全民思想僵化半僵化状态，这是苏联解体的重要原因之一。
列宁最重要的政治遗产，当然是高度集中、组织严密、钢铁般纪律的苏联共产党和一党执政以及党国一体的苏联社会主义国家模式。
按民主集中制原则，建立无产阶级政党，通过暴力革命，夺取国家政权，是马克思主义关于国家与革命的基本理论。
俄国的无产阶级革命政党，必须、只能以人数极少的职业革命家为核心，从上到下，贯彻铁的纪律，如此方能成功。由人数极少的职业革命家组成党的核心，以铁的纪律来保证贯彻全党统一的服从制，这是列宁对马克思主义建党学说的创造，也是列宁创建的俄国无产阶级革命政党不同于西欧各国社会主义政党的“新型”之“新”的所在。
无产阶级专政问题，实际上就是作为无产阶级政党的布尔什维克夺取政权、成为国家执政党以后，怎样管理、治理国家，也即执政的布尔什维克怎样行使国家职能的问题。
国家的本质特征，是和人民大众分离的公共权力。
国家既有作为阶级压迫的暴力机器的一面，又有作为维持一定秩序的公共权力的一面。
历史的实际是，十月革命胜利后，新建立的苏维埃国家把全国党、政、军的权力，一下子集中到没有任何治理国家的经历和经验、被称作“职业革命家”的人们手里，即党中央政治局手里。
就连当时世界社会主义运动中具有崇高威望的左派领袖之一、为十月革命欢呼的罗莎·卢森堡也表示担心。
“专政就是运用民主”，并呼吁“不要抛弃资产阶级民主，而要用社会主义的新内容去充实它”
十月革命胜利，苏维埃国家建立以后，布尔什维克未能完成从革命党到国家执政党的政党转型。
夺取政权的革命党必须以“人数极少的职业革命家”为核心，一切的一切，由这个核心定夺；而成为国家的执政党以后，一切的一切，再也不能完全由这个核心来定夺了，而必须依法治国。国家应当是法律至上；“职业革命家”的党有责任领导制定宪法和法律，党自身也应当在宪法和法律范围内依法行事。
忧虑、担心的有两个问题：第一，保持党中央委员会的稳定性；第二，强化国家监察机关。
列宁提出以“职业革命家为核心”的建党理论，在相当程度上把“人治”理念融入马克思主义的建党原则，这在领导俄国革命的过程中是非常成功的。
对列宁来说，纵然是作为天之骄子，有很高的天资、天聪，历史老人也为其设置了最后一道不容逾越的门槛，毕竟是“人无完人”！
布尔什维克成为国家执政党以后，怎样才能永葆党的纯洁性和稳定性？这正是列宁的可贵之处。
问题是列宁逝世后，继承者斯大林不仅很快就废止了列宁创造的、相对落后国家向社会主义过渡的新经济政策，而后又提出社会主义社会“阶级斗争愈来愈尖锐”的错误理论，这种理论被付诸实施，使苏维埃国家在和平建设年代出现“大清洗”的悲剧，成千上万无辜的干群惨遭迫害。
前言 理性对待列宁政治遗产 马列主义终结了，决不可能再出现。但是马克思主义和列宁主义都没有终结。列宁主义本身就是一条俄国通向历史复兴之路。
列宁主义实际上并不是列宁自己思想的概括总结，也不是他作为苏共和苏联领导人的实践总结，而是一种治国的策略。
马克思主义本质上是一个科学的理论体系，只有在认识论的意义上具有实践性的品格；而列宁主义从根本上说是可供实际操作的战略和策略，它具有创新、求实、可变的特性，也不可避免地带有极端、片面和机会主义的特性。
一旦将这种理论和策略固化和教条化，作为指导实践的普遍原则，就会出现严重的后果。
列宁与马克思都是无产阶级革命导师，两人在理论创造和指导政治实践方面都有重大建树；然而，马克思更多的是在书斋里进行理论研究和理论创造，而革命胜利后的列宁，更多的精力是投身国务活动，参与制定大政方针和具体决策，处置突发事件，处理实践中遇到的各种矛盾和问题。
马克思是革命的理论家，他的思路比较平稳、严谨和贯通，而列宁是革命的政治家，他的思路常常会出现跳跃、应变和反复，为应对和处置现实问题往往缺少缜密的理论思考，因此对列宁的政治遗产更要作全面的、理性的评析。
一个是革命的理论家，一个是革命的实践家，两者面对的问题是迥然不同的，这是研究者应当注意的。
列宁是全党公认的最高领袖，但他并不享有一言九鼎、一锤定音、最终裁决的权力，只是凭他的个人魅力、才智和勇气驾驭着新生的苏维埃共和国，在惊涛骇浪中前进。
列宁逝世后，斯大林树起列宁主义的旗帜，以标榜自己是列宁事业的继承人，他将列宁主义神化和教条化。
列宁是俄罗斯的儿子，也是时代的儿子。
列宁创建无产阶级革命政党，是为了打碎一个旧世界，建立一个新社会，
给我们一个革命家组织，我们就能把俄国翻转过来。
列宁是苏维埃国家的开国元勋，他的理想是要在蛮荒贫寒的俄罗斯大地上，建造一个强盛、平等、共同富裕的新社会模型，既传承马克思的共产主义理想，又可以复制，能够成为别国的榜样。
存在着两个列宁——具体环境中的列宁和本质的列宁。本质的列宁是根据马克思主义和现实要求来研究问题的列宁，这是革新家和创造者的列宁，这个列宁强调宽容、民主和人道主义；而具体环境中的列宁是一个迫于极端严峻形势，迅速寻找摆脱险恶困境的、思绪万变的活动家，形势迫使这个列宁迅速思考、急促决断，他不能每次都周密、全面考虑各种关系，有时态度生硬、脾气暴躁、不容异己，是个有限民主的代表者，这时的他，不仅是个过于严厉的领导者，而且是惩罚措施、监狱乃至集中营的支持者。
1938年，斯大林亲自参与并审定的《联共（布）党史简明教程》出版，当年这本被奉为“马列主义基础的百科全书”，
在这本书里，只有两个“神”及一群“鬼”，唯独没有“人”活动的踪迹。“神”便是列宁和斯大林，“鬼”就是托洛茨基、季诺维也夫、布哈林等党内反对派人物。
杰出人物之所以成为历史伟人，在于他能够站在时代潮流的前端，推动历史车轮前进。当然，伟人也是人，也会有缺点、犯错误，他们身上不可避免地也会有时代的局限和认识的局限。对于已经逝去的历史伟人，严肃的学者（包括许多西方学者）一般都怀有敬畏之情，人们对这些伟人也有批评，甚至是很尖锐的批评，但大多含有理性的成分，极少采用恶意谩骂和不顾事实的诬陷。
“给我们一个革命家组织，我们就能把俄国翻转过来” “没有革命的理论，就不会有革命的运动”“只有以先进理论为指南的党，才能实现先进战士的作用”
革命知识分子一般出生于非工农家庭，专制独裁统治使他们独立、民主、自由的意识受到严重压抑，当他们接受马克思主义的理论和信仰后，其中一些人便背叛自己的阶级，义无反顾地、全身心地投身革命。他们意志坚强、富有献身精神，不怕牺牲个人的一切，包括家庭和生命，他们是理想主义的革命家，只要具备一定的理论知识和组织才能，在革命实践中受到锻炼，就会成为职业革命家。
民众的胜利，历史的选择 一种是斯大林下的定论：“开辟了人类历史的新纪元”。
西方一些学者，以及那些与布尔什维克敌对的人则将其贬为“一场少数人的密谋”“一次军事政变”。
十月革命的意义，从根本上说，在于它开创了一条实现现代化的非资本主义道路。
在一般意义上，革命具有推动历史前进的积极作用，政变则往往是一个负面的概念。
就十月彼得格勒武装起义的性质而言，它无疑是一次有组织、有准备的政治革命，有革命所需要的社会氛围和群众基础，是列宁为首的布尔什维克党目的明确、运筹帷幄、坚毅勇敢、公开发动的推翻旧政权的一次革命。但就起义事件的进程来说，它具有突发性和某种隐秘性，没有经历长时期的、大规模的群众运动乃至战争行动，伤亡人数很少，具有“政变”的某些特点。
有人认为，十月革命的胜利有很大的偶然性，甚至是一个“历史的误会”。
历史总是由胜利者书写的，胜利者总是要为其政治合理性和合法性作辩护。
布尔什维克凭借其政治谋略和组织优势，利用并领导社会运动共同发起了对旧政权的冲击，致使原本就十分脆弱的临时政府未经什么抵抗就垮台了。
以马克思主义为指南的革命党有一个明确的纲领和正确灵活的战略策略，是取得革命胜利的关键。
围绕立宪会议存废的斗争 农民对政治一无所知，尽管农村中有苏维埃宣传员，但农民很快就忘记告诉他们的有关自由民主、共和政体、君主专制的含义”，他们思想深处还把实现自由和拥有土地的要求寄托在一个“好皇帝”上。 与左派社会革命党的联合与分裂 由于俄国政治、经济、文化传统的特点造就了俄国特有的民粹派理论，它的实质是试图在俄国走出一条非资本主义的农业社会主义道路。 一党执政体制的确立 当代世界各国政党政治中，大体上有以下几种执政模式：一党制、两党制、多党制、一党执政多党合作制、无执政党制。</description>
    </item>
    
    <item>
      <title>与神对话1 - chapter8关系</title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D1-chapter8%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Wed, 12 Oct 2022 10:40:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D1-chapter8%E5%85%B3%E7%B3%BB/</guid>
      <description>关系 确实有一种办法可以让你在各种关系中找到快乐，那就是根据这些关系原本的目标、而非你设定的目标去使用它们。
唯有借助你和其他人、各种地方和事件之间的关系，你才能够存在于宇宙间，才能够成为可知的量子和有形的事物。
没有别的一切，就没有你。你之所以成为你，是因为有非你的存在。
你可以选择成为一个完全让已发生的事情来左右生活的人，或者是成为一个事先选择生活目标、而且能够控制生活的人。只有后面这种人的自我创造才是有意识的。
请珍惜每份关系，把每份关系都视为你的真实身份以及和你现在选择的身份的独特构成要素。
如果人类的恋爱关系令人失望（关系从来不会真的令人失望，除非是在人类的意识中，你们认为关系若是没有制造出你们想要的结果就是令人失望的），那是因为人们进入关系的理由是错误的。
绝大多数人进入关系的时候关心的是他们能够从关系中得到什么，而非他们能够为关系付出些什么。
关系的目标 关系——乃至生活——的目标唯有一个：去获得和确定你的真实身份。
由于不想“让你失望”，他们非常努力地去成为你想要他们成为的人，去做你想要他们做的事，直到他们再也无能为力。他们再也不能满足你对他们的期望。他们再也不能饰演你指派给他们的角色。于是怨恨逐渐积累。愤怒随之而来。
最终，为了拯救他们自己（以及这种关系），这些特殊的对象开始要求做回他们真实的自己，更多地依照他们的真实身份行事。正是在这个时候，你会说他们“真的变了”。
关系的目标并非请别人来让你变得完满，而是请别人来分享你的完满。
关系的矛盾 这就是所有人类关系的矛盾之处：你无需任何人便能完整地经验到你的身份，可是……没有别人，你又什么都不是。
这是人类经验的神秘和神奇，沮丧和欢乐。必须有深刻的理解和完全的自愿才能够以有意义的方式生活在这个矛盾之中。
关系是神圣的，因为它们为你提供了最难得的机会，实际上也是唯一的机会，让你能够在生活中制造和经验你关于自我的最高观念。
但愿处在关系中的每个人都只关心自我——自我是什么人、在做什么事、拥有什么东西；自我渴望、想要和付出什么；自我正在追求、创造和经验什么；但愿处在关系中的每个人别去关心他人，而只、只、只是关心自我。
你对对方的关注——你对对方的迷恋——正是导致关系令人失望的原因。
对方过得好不好？对方在干什么呢？对方拥有什么东西啊？对方说的是什么呀？对方有什么心愿呢？有什么愿望呢？对方在想什么呢？期待什么呢？计划什么呢？
大师明白，无论对方过得好不好，正在做什么，拥有什么，说什么，有什么心愿，要求什么，这一切都并不重要。对方在做什么，期待什么，计划什么也都无关紧要。唯一要紧的是在关系中你过得好不好。
最懂得爱的人是那种以自我为中心的人。
如果你无法爱你的自我，你就无法去爱别人。
两个人真的在恋爱关系中迷失了他们的自我。他们进入这样的关系，是希望能够找到他们的自我，结果反而迷失了他们的自我。
绝大多数情人之间的痛苦，原因正在于他们的自我在恋爱关系中迷失了。
两个人结合，本来满心以为一加一将会大于二，结果却发现一加一反而小于一。他们觉得情况变得不如单身的时候。不如那时候能干，不如那时候聪明，不如那时候令人兴奋，不如那时候迷人，不如那时候快乐，不如那时候满意。
这是因为他们变差了。为了能够开始——保持——恋爱关系，他们放弃了他们大部分的真我。
这是因为人们忘记了（假定他们曾经认识到）关系的目标。
灵魂进入身体，身体获得生命，目的在于进化。你们正在进化，你们正在变化。你正在使用你们的关系和其他一切来确定你将要变成什么。
这是你到这里要完成的任务。这是创造自我的欢乐。这是认识自我的欢乐。这是有意识地变成你想要成为的人的欢乐。这就是拥有自我意识的含义。
关系中的自我 你把你的自我带进相对的世界，是为了能够利用各种工具来认识和经验你的真实身份。你的身份就是你在与其他一切的关系中创造出来的你自己。
你的第一关系必定是你与你的自我的关系。
你必须先认为你的自我有价值，然后才能认为别人有价值。你必须先认为你的自我蒙受神的恩宠，然后才能认为别人蒙受神的恩宠。你必须先认识到你的自我是神圣的，然后才能承认别人身上也有神性。
从今往后，永远以你的自我为中心。无论在什么时候，你要关注的是你现在是谁、正在做什么事、拥有什么东西，而不是别人过得怎么样。
并非在别人的行动中，而是在你的不断行动中，才能找到你的救赎。
你能做的唯有一件事。你必须尊重你的感受。因为尊重你的感受意味着尊重你自己。
在与别人进行交往的过程中，最早需要解决的问题是：在这种关系中，你的身份和你的理想身份是什么？
人只要实现了自我，除了继续实现自我之外，并没有什么事情可以做。
宇宙间除了你别无所有。
神只要求你爱别人，也爱自己。神不只如此。神还建议——推荐——你把你自己放在首位。
我在关系中的义务 你没有义务。在关系中没有，在生活中也没有。
没有义务。没有禁忌或者限制，没有规范或者规则。你不受任何环境或情况的制约，也不受任何规章或法律的束缚。
总结 关系中的目标：去获得和确定我的真实身份。 关系中的位置：把自己放在首位。 关系中的关心：关心自己过得好不好。 关系中的义务：没有义务，没有制约，没有束缚。 关系中的自我：自我实现。 </description>
    </item>
    
    <item>
      <title>与神对话1</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D1/</link>
      <pubDate>Tue, 11 Oct 2022 14:33:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D1/</guid>
      <description>尼尔·唐纳德·沃尔什
导读 雄踞《纽约时报》畅销书排行榜137周、在美国销量高达数百万册
总的来说，宗教是某个地区的人民共同拥有的宇宙观、世界观和人生观的总和。宗教试图回答的是三个终极谜团：宇宙到底是怎么来的？世界应该是哪个样子？人们活着究竟是为了什么？
生活在不同地区的民族，最初由于客观环境的差别，对这些问题产生了不同的看法，在此基础上形成了不同的宗教。各种宗教观念影响了各个民族的历史，这反过来又强化了不同宗教的差异。
到了19世纪，欧洲国家凭借工业革命建立起来的经济与暴力优势，在世界各地实施殖民统治，开启了迄今尚未完成的现代全球化进程。
接触到其他宗教思想之后，常见的反应有两种。一种是将其目为异端邪说，进行口诛笔伐，甚至大肆迫害信仰其他宗教的人；另外一种是借机反思，看看自己信奉的宗教有哪些合理之处，又有哪些不合理的地方。
尼尔·唐纳德·沃尔什在1995年出版的《与神对话》更是其中的翘楚，清晰地、全面地阐释了整个新时代的思想体系。
我的人生为什么如此失败？
它用通俗优美的语言，提供了全新的世界观和人生观。
世界上的钱不够多，时间不够多，爱情不够多，食物、水和同情不够多……总之好东西统统不够多。人类特有的这种“不够”意识创造和反复创造了你如今看到的这个世界。
唯有意识到你对这个世界的现状负有责任，你才有能力去部分地改变它：
世界以目前的方式存在，是因为你们选择了让它这样。
现代人痛苦的部分根源还在于社会的压力。众多道德观念、制度规范都会对个体施加约束，但这并不是个人焦虑感的来源。个人的焦灼更多地来自人与人之间的相互比较和相互指责。
别妒忌成功，别怜悯失败，因为你不知道在灵魂的权衡中，什么算成功，什么算失败。遇事别称其为灾难或欢乐，除非你已确定或见证它的用途。因为，如果死拯救了数以千计的生命，它还能被称为灾难吗？如果生只带来悲哀，它还能被称为欢乐吗？然而就算连这个你也别去判断，你永远走你的路，同时允许别人走他们的路就可以了。
《与神对话》三部曲的第一卷处理的是人生观问题，第二卷应对的是世界观问题，第三卷则试图解答宇宙观问题，它们共同构建了完整的新时代思想体系。
1.我们所有人是一体；2.一切皆已足够；3.没有我们必须做的事情。
读书其实也是讲缘分的。
真正地读完这套书以后，你们将会像我一样，时刻生活在爱、欢乐和感恩里。
前言 1.第一卷主要处理个人话题，关注个人在生活中遇到的困难和机会。2.第二卷将会处理全球性的地缘政治话题、这个星球上的精神生活，以及当今世界面临的困境。3.第三卷将会处理最高级别的宇宙真相，以及灵魂的艰巨任务和机会。
神鼓励我宽恕我的失败，鼓励我别生活在恐惧和愧疚之中，而是永远尝试——不停地尝试——过上更美满的生活。
Chapter 01 那段日子我非常难过，生活、工作和感情均不如意，我觉得我的人生真是彻头彻尾的失败。
我的人生为什么如此失败？要怎样才能获得成功？为什么我在与他人的交往中找不到快乐？难道我将要永远穷下去吗？
书的内容不只是给我看的，也是给你和其他遇到这本书的人看的。原因在于，我的问题就是你的问题。
感受是灵魂的语言。
隐藏在你最深的感受中的，却是你最高的真相。
最高级的思维永远是包含了欢乐的思维。最清晰的话语永远是包含了真相的话语。最美好的感受是你称之为爱的感受。
欢乐、真相、爱。这三者是可以相互替换的，它们之间永远是互通的。无论它们的次序如何。
我不会逼你。我不会胁迫你。因为我赐予你自由的意志——选择你想做的事情的力量——我永远不会将它从你身上夺走。永远不会。
聆听你的感受。聆听你最高级的思维。聆听你的经验。
话语是最不可靠的真相供给源。
别妒忌成功，别怜悯失败，因为你不知道在灵魂的权衡中，什么算成功，什么算失败。遇事别称其为灾难或欢乐，除非你已确定或见证它的用途。
爱是终极的实在。它是唯一。是全部。爱的感受是你对神的经验。
Chapter 02 在你面前是圆满的欢欣，在你的右手是永恒的快乐。
你认为神只能以一种方式在生活中出现。这是非常危险的观念。
如果你认为神只有一种模样，或者只有一种声音，或者只有一种存在方式，你就会日日夜夜都看不到我。
如果你不能从污秽卑微中看到神，你便不能全面地理解神。那是伟大的真相。
神既存在于悲哀，亦存在于欢笑；既存在于痛苦，也存在于甜蜜。万事万物背后都有神的用意——因而万事万物中都有神的存在。
神是上与下。热与冷。左与右。神可以用来尊敬，也可以用来侮慢！
对我来说，没有什么是可恶的。一切都是生活，而生活是神的礼物。
神的计划是让你们去创造一切，你们想要的一切。
唯有通过你们称为恶的事，你们才能认识到善，唯有通过你们称为魔鬼所为的事，你们才能认识和去做神所为的事。
在神看来，一切都是“可以接受的”
拒绝一样东西，等于否定它的存在。
可是你要逐一检查它们。逐一审视它们。
改变它们的理由只有一个：那就是你的真实身份让你感到不快乐。改变的用意也只有一个：那就是让你对你的真实身份感到快乐。
唯有你能知道你是否快乐。
在绝大多数情况下，做出这些决定的并不是你们，也许是你们的父母。你们的宗教。你们的教师、历史学家、政治家。
你们把许多价值判断视为你们的真相，其中很少是由你们本人根据自己的经验而做出的。任由你们自己因为别人的经验而变成现在的你。
这就是你们所有人犯下的“罪行”。你们没有等待你们自己的经验，你们把别人的经验当成福音
你们否定了自己的经验，继续根据别人所说的去思考。
你们选择去接受其他人提出的那些关于性爱的判断、看法和观念——那些人全都想操控你们的思维。
你们对待钱也是如此。每当你在生活中拥有许许多多的钱，你们就会觉得非常爽。拿到钱你们觉得很爽，花掉钱你们也觉得很爽。
如果“自由的意志”不是你们的意志，而是别人的意志，并且你们非遵从不可，那它怎能被称为自由呢？
神没有需要。神就是太极：太极就是一切。因此，从定义上来讲，神不需要也不缺少任何东西。
欲望和需要不是相同的东西
欲望是所有造物的起点。它是最初的思维。它是内在于灵魂的伟大感受。
那神的欲望是什么呢？
我的第一个欲望是，认识和经验我自己，最辉煌的我自己——认识真正的我。
我的第二个欲望是，你们将会认识和经验你们的真实身份，利用我赋予你们的能力，随心所欲地选择任何方式去创造和经验你们自己。
我的第三个欲望是，整个生命的过程在每个此刻都能经验到持续的欢乐、不断的创造、无尽的成长和完整的满足。
它们正在实现的过程中——就在此刻。
坚持你的价值观——只要你经验到它们对你有用。然而要仔细看清楚，这些你用思维、话语和行动保卫的价值观是否将你心目中最美好的自己带入你的经验空间。
逐一检查你的价值观。让它们接受公众的审视。假如你能够泰然自若、毫不犹豫地告诉世界你是谁，你的信念是什么，你对自己便是满意的。那你就再也没有理由继续与我对话了，因为你已经创造出不需要提高改进的自我，以及适合这个自我的生活。那你就到达完美的境界，可以放下这本书了。
我希望明白是什么引发我的行为，是什么导致我沦落，是什么不停地挡住我的路。这就是我来找你的原因吧，我想。</description>
    </item>
    
    <item>
      <title>西西弗神话</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D/</link>
      <pubDate>Sun, 09 Oct 2022 10:17:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D/</guid>
      <description>阿尔贝·加缪
含着微笑的悲歌 加缪1913年生于阿尔及利亚
《局外人》塑造了一个面对荒谬的人的形象，《西西弗神话》系统论述了荒谬和荒谬的人，而后来的《反抗者》则论述了荒谬的行动，于是形成了加缪从觉醒意识到反抗行动的完整哲学体系。
加缪认为，“伟大的作家必是哲学家”。
在加缪的哲学思想中，荒谬不是结果，而是作为起点来提出的。
一个我们习以为常的世界，一个我们平常非常熟悉的女人，突然间会变得那么陌生，从此变得比“失去的天堂还要遥远，我们不再能理解它们……”
荒谬取决于人和世界，二者缺一就不成其为荒谬。荒谬是“人与世界之间的唯一联系”。人一旦在平庸无奇、习以为常的生活中提出“为什么”的问题，那就是意识到了荒谬，荒谬就开始了，而人也就清醒了。
人看到了这毫无意义、杂乱无章的非人的世界，它是希望的对立面；另一方面，人自身中又深含着对幸福与理性的希望，荒谬就产生于“这种对人性的呼唤和世界不合理的沉默之间”的对抗，荒谬清楚地说明了欲求统一的精神与令这欲求统一的意念失望的世界之间的分离。
非理性因素、人的怀念以及与二者同时出现的荒谬就是造成人生悲剧的三位主角。
既然我们面对的注定是悲剧的人生，是无情无义的荒谬世界，那么，荒谬是否就必然要引出自杀的结果以结束这种在世的生活呢？
要对生活回答“是”，要对未来回答“不”！
加缪决不同意把希望寄托于将来，不希求什么永恒与舒适，不惧怕飞跃产生的危险。
重要的不是生活得最好，而是生活得最多，这就是荒谬的人的生活准则。
完全没有必要消除荒谬，关键是要活着，是要带着这种破裂去生活。
精神依靠身体去穷尽现在的一切。
身体，爱抚，创造，行动，人类的高贵于是在这毫无意义的世界里重新获得其地位。
在加缪看来，没有任何一种命运是对人的惩罚，只要竭尽全力去穷尽它就应该是幸福的。
自杀实质上是一种逃避，它是反抗的对立面，它想消除荒谬，但荒谬却永远不会被消除。
加缪不相信来世，他认为，人若为了寻找生活的意义，为了某种目的或为适应某种偏见而生活，那就会给自己树起生活的栅栏。
没有什么明天，没有什么来世，要义无反顾地生活。
萨特的存在主义自由是要脱离日常混沌，超越现在。
下决心要在这冰冷而又燃烧着的有限世界中生活。
荒谬的人则是在清醒地认识到荒谬之后，最后投入到人类反抗的熊熊火焰之中。
从荒谬推论出我的反抗、我的自由和我的激情这荒谬的人的道路。
加缪所推崇的荒谬的人是“不肯拔一毛以利永恒的人”，就是追求自我穷尽，追求穷尽既定一切的人。
关注确实的东西，毫无未来的希望。
重要的不是永恒的生命，而是永恒的创造。
在加缪看来，征服者是不愿为将来牺牲现在的人，他的伟大在于尽其所能地生活。
他意识到自己荒谬的命运，他的努力不复停歇，他知道他是自己命运的主人，他永远前进。他的行动就是对荒谬的反抗，就是对诸神的蔑视。
西西弗对荒谬的清醒意识“给他带来了痛苦，同时也造成了他的胜利”。应该认为，西西弗是幸福的。
一位法国朋友曾对我说，加缪的《局外人》和《西西弗神话》是她十八岁时的床头书。
文前辅文 我的灵魂啊，不求永生，唯尽所能吧。 荒谬的推理 真正严肃的哲学问题只有一个：自杀。判断生活是否值得经历，这本身就是在回答哲学的根本问题。
如果一个哲学家要自己的哲学受到重视，那他就必须以身作则；
生命意义的问题是诸问题中最急需回答的问题。
自杀只不过是承认生活着并不“值得”。
活着从来就没容易过，但由于种种原因，人们还继续着由存在支配着的行为，这其中最重要的原因就是习惯。
习惯是可笑的，认识到人活着的任何深刻理由都是不存在的，就是认识到日常行为是无意义的，遭受痛苦也是无用的。
荒谬的墙 起床，乘电车，在办公室或工厂工作四小时，午饭，又乘电车，四小时工作，吃饭，睡觉；星期一、二、三、四、五、六，总是一个节奏，绝大部分时间里这条道路很容易沿循。一旦某一天，“为什么”的问题被提出来，一切就从这带点惊奇味道的厌倦开始了。“开始”是至关重要的。厌倦产生于一种机械麻木生活的活动之后，但它同时开启了意识的运动。它唤醒意识并且激发起随后的活动。随后的活动是无意识地重新套上枷锁，或者是确定性地觉醒。觉醒之后，随着时间的推移，就会产生结果：自杀或是恢复旧态。厌倦自身中具有某种令人作呕的东西。在此，我应得出这样的结论：厌倦是件好事。因为一切都始于意识，而若不通过意识，则任何东西都毫无价值。这些观点并不包含什么独创之处。它们都是显而易见的：在某一段时间内，这就足以概括认识荒谬的起源。一切都起源于这平淡的“烦”。
在平淡无光生活的日日夜夜，时间带着我们往前走。
我们是向着未来生活着的：“明天”，“以后”，“你到那时”，“随着年龄增长你会明白”。
他在时间中取得他的位置
没有未来的创造 人们永远不能摆脱希望，而且它能纠缠那些想摆脱它的人们。
万事都须有个开始。
宗教之所以对异端派那么残酷，那是因为它认为最可怕的敌人莫过于歧路上的孩子。
荒谬的创造者就有两个任务：一是否定，二是颂扬，这是展现在荒谬创造者面前的道路。
深刻的思想总是处于生成之中，它吸取生活的经验并且在生活中造就自己。
导出于 2022-10-09 10:17:06</description>
    </item>
    
    <item>
      <title>身份的焦虑</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E8%BA%AB%E4%BB%BD%E7%9A%84%E7%84%A6%E8%99%91%E8%AF%91%E6%96%87%E7%BB%8F%E5%85%B8/</link>
      <pubDate>Sun, 09 Oct 2022 09:04:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E8%BA%AB%E4%BB%BD%E7%9A%84%E7%84%A6%E8%99%91%E8%AF%91%E6%96%87%E7%BB%8F%E5%85%B8/</guid>
      <description>阿兰·德波顿
中文版序言 身份的焦虑是我们对自己在世界中地位的担忧。
身份的高低决定了人情冷暖：当我们平步青云时，他人都笑颜逢迎；而一旦被扫地出门，就只落得人走茶凉了。
我们的“自我”或自我形象就像一只漏气的气球，需要不断充入他人的爱戴才能保持形状，而他人对我们的忽略则会轻而易举地把它扎破。
历史证明，社会保障了生活的基本需求之际，就是身份的焦虑滋生之时。
每当这一切发生时，我们便为自己的身份地位而担心了。
现今，身份的焦虑比以往任何时候都强烈，因为每个人获取成功（性爱的成功、经济的成功和职业的成功）的可能性似乎比以往任何时候都大。
我们必须期望更多的东西。我们每时每刻都被成功人士的故事所包围。
在绝大多数时代里，人们的主导思想与之完全相反：对生活抱以很低的期待不仅正常，而且明智。仅有极少数的人立志追求财富与成就。对大多数人来说，他们知道自己活在世上就是为人奴役、逆来顺受。即使是今天，我们攀上社会顶层的可能性也微乎其微。
不幸的是，现在的人们觉得这一切并非没有实现的可能——这种想法来自每个人阅读的杂志。
只有同那些一起长大的同伴、一起工作的同事、熟识的朋友，或是在公共场合与那些有认同感的新知相比较时，如果我们拥有和他们一样多或更多的东西的时候，我们才认为自己是幸运的。
要想获得成功的感觉，最佳途径莫过于选择一个稍逊于己的人做朋友
对身份地位的渴望，同人类的任何欲望一样，都具有积极的作用：激发潜能、力臻完美、阻止离经叛道的有害行径，并增强社会共同价值产生的凝聚力。
我们渴望得到地位和财富，但其实一旦如愿以偿，我们的生活反而会变得更加糟糕。我们的很多欲望总是与自己真正的需求毫无关系。
一旦对身份的焦虑有所了解，当我们再次面对对手的漠视和挚友的成功之时，我们的反应就不会仅仅是痛苦和内疚了。
第一部分 焦虑起因 人为什么要追求显耀的身份？对此问题的回答几成共识：要言之，无非是祈财、求名和扩大影响。
有一个显然不为权势规则所关注的字眼却能更准确地表述我们心中的渴慕，那就是“爱”。
金钱、名声和影响只能视为“爱”的表征——或者是获取爱的途径——而非终极目标。“爱”这一字眼，一般用于表述我们想要从父母或爱人那里得到的东西，怎么可以用来描述一种我们求之于社会，并受之于社会的诉求呢？
获得他人的爱就是让我们感到自己被关注——注意到我们的出现，记住我们的名字，倾听我们的意见，宽宥我们的过失，照顾我们的需求。
我们对处在不同社会地位的人是区别对待的。那些身份低微的人是不被关注的——我们可以粗鲁地对待他们，无视他们的感受，甚至可以视之为“无物”。
我们每个人都渴求一种生存的尊严。
我们在这个世界上辛苦劳作、来回奔波到底为了什么呢？所有这些贪婪和欲望，所有这些对财富、权力和名声的追求，其目的到底何在呢？难道是为了满足自然的需求？如果是这样，最底层的劳动者的收入也足以满足人的自然需求。那么人类的一切被称为‘改善生存状况’的伟大目的的价值何在？”
被他人注意、被他人关怀，得到他人的同情、赞美和支持，这就是我们想要从一切行为中得到的价值。
每一个成年人的生活可以说包含着两个关于爱的故事。第一个就是追求性爱的故事，第二个就是追求来自世界之爱的故事。
第二个关于爱的故事在强烈程度上一点不亚于第一个，在复杂性、重要性和普遍性上也是如此，而且一旦失败，所导致的痛苦不会比第一个少。
如果可行，对一个人最残忍的惩罚莫过如此：给他自由，让他在社会上逍游，却又视之如无物，完全不给他丝毫的关注。当他出现时，其他的人甚至都不愿稍稍侧身示意；当他讲话时，无人回应，也无人在意他的任何举止。如果我们周围每一个人见到我们时都视若无睹，根本就忽略我们的存在，要不了多久，我们心里就会充满愤怒，我们就能感觉到一种强烈而又莫名的绝望，相对于这种折磨，残酷的体罚将变成一种解脱。
爱之缺乏如何影响我们？为什么被人漠视能让我们如此“愤怒”、“绝望”，乃至最残酷的体罚对我们来说都可以是一种解脱？
他人对我们的关注之所以如此重要，主要原因便在于人类对自身价值的判断有一种与生俱来的不确定性——我们对自己的认识在很大程度上取决于他人对我们的看法。
我们的自我感觉和自我认同完全受制于周围的人对我们的评价。
如果我们讲出的笑话让他们开怀，我们就对自己逗笑的能力充满自信；如果我们受到他人的赞扬，我们就会对自己的优点开始留意。
我们的地位决定了我们可能赢得多少世人的爱，而世人对我们的关爱又是我们看重还是看轻自己的关键。地位对我们都是至关重要的，它是打开关爱之宫的金钥匙：没有了他人之爱，人类将失去自信；没有了他人之爱，我们将难以按自己的秉性办事。
第二章 势利倾向 一旦成年了，就意味着我们得在这满是势利鬼和冷面孔的世间争取一个位置，这些人的影响是使我们产生身份焦虑的关键所在。
现实却相当残酷：我们身边多的是势利小人，我们无时无刻不在他们势利的眼神下生活。
“势利者”一词的本意是指没有显耀身份的人。但这种词义在现代发生了很大的变化，与当初的意思几乎完全相反，指一个因为他人没有社会地位而瞧不起他人的人。
此前25年，势利者“已如铁路般延伸到英伦的每个角落。现在，在这个所谓日不落的大英帝国，你随时随地都能碰上这些势利鬼，并一眼就能认出他们。
第三章 过度期望 美国普通工人家居的全貌：地上铺满了地毯，客厅里摆放了电视机，有两个厕所，装有中央取暖器，厨房里还有洗衣机、滚筒式烘干机和冰箱。
劳作了一生，他们最值钱的家当也不过是一头牛、一只羊或一只铁锅。
人与人之间的不平等才是正常的；随遇而安，知足常乐才算明智。
对那些精英而言，让这些奴隶享有权利，或者认为他们可以追求幸福的想法都是荒谬的，其荒谬程度不亚于探讨锤子或镰刀的思维状态和幸福水平。
是的，在上帝面前我们每个人都是平等的，但这并不表明我们在尘世就可以追求人与人之间的平等。
对于当时的主流意识，如果有人胆敢质询为什么有些人注定要在农田里辛勤劳作，而另一些人又命定要在宫廷里饮酒作乐，那么他便是冒天下之大不韪——因为他挑战的是造物主的旨意。
个体的存在先于社会的出现。个体是为了自己的利益才加入社会组织中，他们放弃自己的一些自由和权利，来换取社会的保护。
洛克指出上帝并没有把地球作为私有财产给予亚当，而是把地球给予了世间所有的人，期冀所有的人都能从中获得幸福和财富的机会。他认为，统治者应该是人民的工具，人民是否应该服从他们，完全取决于这些统治者是不是为广大民众谋福利。
政府的正当性在于它们能在多大程度上提高国民获得幸福和财富的机会。
让人料想不到的是，即便是那些对物质进步和民主革命心怀赞美的人也不得不承认，他们创建的这个新的现代社会已经遇上了一个特别的难题。
的确，美国人非常富有，但这种富足并不能阻止他们想要获得更多，一旦发现别人拥有自己所没有的资产时，他们便寝食不安。
世袭的特权没了，与生俱来的财富也没了，一个人可以选择任何职业，这时，一个雄心勃勃的人当然会自命不凡，觉得自己可以从事一项更重要的职业。然而，这一切纯然是一种幻觉，现实的生活很快会让他清醒过来。以前，不平等是社会的普遍规律，因而即使再严重的不平等也不会引人注意。而现在平等了，人和人之间差异甚少，正因为如此，哪怕是细微的差距也变得明显起来……为什么生活在这个民主富足的国度里，人们仍有一种莫能名状的烦愁？这就是原因。为什么这里的人民生活平静安逸却又时时会诅咒生活？这也是原因之所在。
中世纪底层的民众却享有一种精神的宁静，这是现代的人们永远无法得到的。
由皇室和贵族统治的国家尽管有其缺点，但在那样的社会里也有一些乐趣是现代人很难想见的。由于从没有构想过另一种社会形式，每个人仅仅了解自己的身份，而从来没有想过还会有可能改变自己的身份，所以他们绝不会产生和自己的上级或主人平起平坐的期望，因而那时的人们不会对自己的权利有任何怀疑。对他们的艰苦境遇，既无敌对反感之情绪，也无堕落蒙羞之心态，因为他们相信一切都是天定，他们只能接受。农奴的地位非常低下，但他们把自己的命运视为自然的法则。正因为如此，尽管不同阶层人民之间的命运如此迥异，但各个阶层之间并无恶意。你可以在这个社会看到很多的不平等，但你不会看到人们的心灵会因此而蒙羞。
一个民主的社会拆去了所有束缚人们梦想的樊篱。一个人也许生活拮据，在物质方面远不如人，但这并不妨碍他们从理论上觉得他和任何人都是平等的。
在美国，我遇到的每一个人，不管多么穷困潦倒，他们眼里都写满希望，同时心里无不对富人们的安逸舒适心生嫉妒。
尽管如此，例外并不代表普遍情况，美国仍然有生活在底层的人们。
贵族社会里，底层的仆人能泰然地接受他们的命运，用托克维尔的话来说，他们能“愉快地生活，对自己的工作感到自豪，同时也不失自尊”。然而，在一个民主社会里，有的只是报刊和社会舆论没完没了的鼓噪，让每个生活在底层的人都相信他们总有机会攀上社会金字塔的塔尖，有机会成为实业家、大法官、科学家，甚至是总统。
对那些底层的年轻人尤甚。但在他们之中，只有极少数最优秀的幸运儿才有机会脱颖而出，实现他们的梦想；而多数的人，随着时间一天天过去，他们并不能改变自己的身份，
他们会转而变得意志消沉，内心极度痛楚，并轻贱自己，同时也憎恶自己的顶头上司们。
这一算式同时也隐含了两种提升自尊的策略：其一是努力取得更多的成就；其二是降低对自己的期望。
另人遗憾的是，西方社会并不鼓励人们去降低对自己的期望或坦然面对人之将老，欣然接受自己肥胖的事实从而提升个体的自尊，至于贫穷和卑微，则更不为社会见容。
西方社会过度地抬高了我们对自己的期望，其结果就是足够的自尊将永无可能实现。
人在世间的一生： 充满哀伤，也不乏诱惑，　Temps de doleur et de temptacion, 处处有眼泪，嫉妒和磨难，Aages de plour, 这就是该诅咒的生活，d&amp;rsquo;envie et de tourment, 人们如何能振作……Temps de langour et de dampnacion&amp;hellip;(1)</description>
    </item>
    
    <item>
      <title>世界尽头的咖啡馆</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E4%B8%96%E7%95%8C%E5%B0%BD%E5%A4%B4%E7%9A%84%E5%92%96%E5%95%A1%E9%A6%86/</link>
      <pubDate>Sun, 09 Oct 2022 09:03:49 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E4%B8%96%E7%95%8C%E5%B0%BD%E5%A4%B4%E7%9A%84%E5%92%96%E5%95%A1%E9%A6%86/</guid>
      <description>约翰·史崔勒基
序 我迷路了，也在人生的旅途中迷失了——我不知道脚下的路通往何方，也不知道自己为什么要前往那个方向。
我每天坐在格子间里，工作十到十二个小时，以后升了职，顶多就是搬进独立办公室，工作时间变成十二到十四小时，我忍不住开始想，人生就该如此，再无其他选择了吗？
我感觉自己始终忙着用生活换取金钱，这笔买卖似乎不太划算。
我遇见它的唯一原因，就是那一刻、那一夜，我需要遇见它，那家咖啡馆仅仅因此而存在。
01 我等不下去了，决定换条路试试。
我穿过隔离带，朝新的方向开去。
02 因为家里有许多工作和生活上的烦心事儿，我才决定远行，想散散心；换句话说，家里的事儿已经够烦了，真没想到出了门还是这么烦。旅行的目的明明是为了让自己放松心情，再次鼓足干劲啊。
鼓足干劲，一泻千里；再鼓足干劲，再一泻千里……循环往复，什么时候才算是个头啊？
04 你为什么来这里？你害怕死亡吗？你满足吗？ 05 从不同的视角看待事物，有时候能帮助我们解决问题。 06 我的注意力重新回到菜单上。我开始重读第一个问题——“你为什么来这里？”
单看一个问题是一回事，把这个问题变一变就是另一回事了。
但如果你把问题稍微变一变，就能改变一些事情。
如果这个问题不问别人，而是问你自己——你就不再是以前的你了。
你读一下菜单上第一个问题，但是要用事不关己的态度读，就好像你瞥到的一个路牌。
让我吃惊的是，上面的问题已经不再是“你为什么来这里？”。而是“我为什么来这里？”。
认认真真去看，然后扪心自问又是另一回事——你的世界会发生改变。
07 我愣住了，我的处境十分荒唐。
一旦你真的问出了那个问题，寻找答案就会成为你生命的一部分。
通过凯茜的话，我明白了，那个问题并非简单地在问人们为什么来这个咖啡馆。
问题与咖啡馆无关，而是在问一个人为什么存在。
为什么要问自己这种问题呢？我就从来没问过，我现在也挺好的。
“很多人都觉得‘挺好’。但有的人就是要寻找比‘挺好’更令人满意的状态、更棒的生活。”
如果我坦诚面对自己，我得承认，我多年来都在想，除了我已经体验到的事物，生活是否还有更多的可能性？
问出这个问题就好比打开一扇大门。人的心灵也好、灵魂也罢，不管你用什么词形容，它都会去追寻答案。这个问题会占据提问者生活的优先位置，直到他有一天找到答案。
要是有人找到了答案，就会产生另一股同样强大的力量。人们一旦知道了他们为什么来，为什么存在，找到了活着的目标——他们就想实现这个目标。这个目标就像藏宝图上代表藏宝地点的×。一旦看到了×，你就很难假装没看见，很难不去寻宝。回到我们说的具体问题上，一旦有人知道了他们来这里的目标，他们从情感上、甚至从生理上，都很难不去尝试实现那个目标。
只要时机成熟，每个人都得问自己这个问题。
如果有一天你决定放下那种感觉，就勇敢做出选择吧，只有你自己才能给你自己做决定。
08 你为什么来这里？这是在问一个人为什么存在。
我只想吃点儿东西，加点儿油，找个地方打发几个小时。我为什么要去想那些有的没的呢？
不同的人会在不同的时期面对那个问题。有的人在小时候就想清楚了，有的人长大一些才开始想，还有人终其一生都没想明白。
如果一个人对自己提出这个问题，他的生活就会发生一些改变。
我想知道，他们之后会怎样？
你是说他们提问之后？还是找到答案之后？
关于如何找到答案，我认为没有一个适合所有人的统一方法。每个人都有自己的生活方式。
09 要是有人问自己为什么来这里，通过某种方式搞清了他的目的，他带着这份答案，接下来要怎么做呢？
首先，他想做什么就做什么。他解开了这个谜题，答案属于他自己。关于接下来怎么做，他们有完整的、决定性的话语权。
一个人要是知道了自己存在的意义，他就会为了实现这个意义做一切想做的事？
在我过去的人生中，我所作出的大部分决定都是为了回应他人的期待，比如说家人的建议、文化环境带来的压力和别人的看法。
那要是我的存在意义是为了成为百万富翁呢？
那你就应该尽你所能，做符合你心中‘百万富翁’定义的事情。
所有的例子都是一个道理，选择权在你自己手里。
当一个人弄清了他为什么存在，就相当于定义了自己的‘存在意义（Purpose For Existing）&amp;rsquo;。我们简称其为‘PFE&amp;rsquo;。在一个人的一生中，他可以为了实现‘存在意义’做十件、二十件、甚至成百上千件事。他可以做任何事。
你会始终待在同一个地方吗？
我觉得，一个人要想知道如何实现自己的存在意义，应该去探索和迎接与PFE相关的各种事物，这就是我提的那个问题的答案。
每个人都局限于自己当前的经历和知识。这句话的重点在于‘当前’。我们生活在有史以来信息量最大的时代，每个人都有机会接触全世界的各种信息、人、文化和经历。
我不知道我来到这世上到底为了什么，也不知道我想做什么，我只是在重复大多数人在做的事。
做‘大多数人’在做的事能帮你实现自己的存在意义吗？
10 做大多数人做的事能帮我实现存在意义吗？
海龟从不与海浪相争，而是巧妙利用海浪的力量。我之所以无法追上它，就是因为我不顾海水的方向，自始至终都在划水。一开始，我还能和海龟并驾齐驱，有时候还得放慢速度等等它。但是在反方向的海浪中，我越是用力向前游，就越是感到疲惫。等到海浪前进方向再次与我游泳方向相同时，我却没有足够的精力顺势向前了。
如果一个人弄清了自己为什么存在——知道了自己的PFE，他就能把时间花在有助于实现PFE的事情上。你还说，没弄清自己PFE的人也会花时间做很多事。因此我得出一个结论，他们是把时间花在了无益于实现PFE的事情上。
如果你和你想做的事不在同一个频道，你就会浪费许多精力。等你有机会做你想做的事时，你可能已经没有力气或时间了。
每一天都有很多人想要让你把时间和精力花在他们身上。比如你收到的邮件。如果你打算参加所有活动，参与每次促销，享用每一项不请自来的服务，你就没有空闲时间了。这还只是邮件而已。再想想那些想通过电视、网络、餐厅、旅游地等等来吸引你注意力的人。你很快就会发现，自己在做大家都在做的事，或者别人想让你做的事。
在我的人生中，那些想要消耗我注意力、精力和时间，但与我的PFE并不相关的人、活动和各种事物，就是涌向岸边的反向海浪。而能帮我成就PFE的人、活动和事物，就是涌向大海的正向海浪。
11 你为什么存在？你弄清自己的存在意义后该怎么做？你能从一只绿海龟身上学到什么？
你为什么存在？你弄清自己的存在意义后该怎么做？你能从一只绿海龟身上学到什么？</description>
    </item>
    
    <item>
      <title>西西弗神话</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D/</link>
      <pubDate>Sat, 08 Oct 2022 15:05:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D/</guid>
      <description>加缪
版权信息 “西西弗神话”已成法文谚语，借喻“永久无望又无用的人生状况”
吾魂兮无求乎永生，竭尽兮人事之所能。
译序 加缪的荒诞美学 不求永生，竭尽人事。
西西弗的人生是荒诞的，没有价值，还值不值得活下去？
判断人生值不值得活，等于回答哲学的根本问题。
上帝的儿子死了，绝对可信，因为这是荒诞的；他被埋葬之后又复活了，绝对确实，因为这是不可能的。
哲学自杀”：理性阐述往往不得要领，于是利用理性阐述的失败来为信仰荒诞作辩护。
神性与人性寓于一体，所谓神人或人神，即无限性贯穿于有限性：基督本身就是“绝对的悖论”。
荒诞正是清醒的理性对其局限的确认
所谓荒诞，是指非理性与非弄清楚不可的愿望之间的冲突。
加缪的荒诞说是建立在矛盾论之上的。
人对单一性和透明性的欲望与世界不可克服的多样性和隐晦性之间的矛盾
加缪不相信有什么王者权限，但对必须摒弃理性不以为然，因为理性在其限度之内还是有用的。
加缪的荒诞说不是一种概念，用他的话来说，是一种“荒诞感”，一种“激情”，一种“感知”，一种“精神疾病”，加缪试图对这种病态作纯粹的描述，其目的是要弄清楚这种“荒诞感”是否导致自杀。
何谓“荒诞感”？“人与其生活的离异，演员与其背景的离异
何谓“荒诞感知”？人面对自身不合情理所产生的反感，对自身价值形象感到堕落[插图]，有这份自知之明，就叫“荒诞感知”。
何谓“荒诞激情”？“人是无用的激情”（萨特语），明知无用仍充满激情：明明知道自由已到尽头，前途无望，为反抗绝望而不断冒险，这叫荒诞激情。何谓“荒诞疾病”？人一旦被剥夺了幻想和光明，便感到自己是现世的局外人，随时想逃脱自我，又无可奈何置身其间，因焦虑而消沉，陷入绝望所患的一种抑郁症。
加缪说：“荒诞就是死囚的鞋带。
荒诞取决于人，也不多不少取决于世界
荒诞是世人与世界唯一的纽带，把两者拴在一起，正如唯有仇恨才能把世人锁住。这是一种不治之症。
荒诞人就是与世界、与时间形影不离的人。
荒诞人就是不为永恒做
任何事情，又不否定永恒的人
荒诞人一旦在时间点上定位，他不再属于自己，而属于时间了
因反抗时间这个最凶恶的敌人而产生的切肤之痛，就是荒诞人的永久之痛。
荒诞英雄”，既因为他的激情，也因为他的困苦。
对诸神的蔑视，对死亡的挑战，对生命的热爱，使他吃尽苦头，即使竭尽全身解数，也一事无成。
我们可以想像他是幸福的。
不去理睬它”（纪德语），或干脆踩上去，“控制局面”（纪德语）
一个人的失败，不能怪环境，要怪他自己
创造就是活两回
反抗者先把上帝否定，旨在否定之后取而代之”，尼采如是说
为了成为上帝，他应当自杀。唯其如此，才能教育芸芸众生，因为敢于自杀的人都是上帝。
不仅维护个人尊严，而且维护人类尊严
如果反抗可以从中揭示自由、团结、正义，那么存在压迫的世界就是一个荒诞的世界。唯有反抗才能阻挡荒诞。于是反抗者就有生存的价值，
因为自由、正义、一统在形而上反抗者眼里并不真正存在，只不过是一切激情的神化。
世上最强有力的人是最孤独的个人。”
发现沙漠之后，就不得不学会生存下去。
上帝唯一的托辞，就是上帝并不存在
既然世人的得救不靠上帝去完成，那就应当在人世间自我完善。既然世界没有方向，世人一旦接受这个世界，就应当给它一个方向，以便达到高级的人类社会。
世人可否毫无信仰地活着？这在西方是十足的虚无主义疑问。
而是否认教会的替代品：道德、人道主义或
社会主义（系指德国国家社会主义）。
所谓“一切皆许可”，其实什么也做不成，不知所措了；既没有禁忌，也没有法则了。世人只有被抛弃的感觉，进入一个无目的的社会，怎么办
没有好的虚无主义和坏的虚无主义，就像没有好的荒诞和坏的荒诞之分。”
我永远是自己的陌路人。
世人能否光凭荒诞而活着，
重要的不是永恒的生命，而是永恒的活力。”
上帝死了”之后，信仰失落的无家可归感，引起对存在意义的叩问。发现人生无意义，就是人对自身被抛入荒诞之中的自我发现。
叩问人生存在意义
他们共同的视野源头都是尼采的论断：“上帝死了”，进而“价值死了”，再而“理想死了”。一言以蔽之：“创始原理缺失。
作为彻底的反抗者，他们的一切精神生活都是想自己成为精神上帝，站在某个道德的制高点上，创造一种崭新的精神形态赋予人类命运。
荒诞推理 本着只对一种精神病态作纯粹的描述，暂不让任何形而上、任何信仰混杂其间。这是本书的局限所在和唯一主张。 荒诞与自杀 倘问凭什么来判断这个问题比那个问题紧要，回答是要看问题所引起的行动。
唯有明摆着的事实并加上恰如其分的抒情表达，才能既打动我们的感情又照亮我们的思路。
自杀这类举动，如同一件伟大的作品，是在心灵幽处酝酿成熟的。
原则上可以肯定，一个表里一致的人，对他信以为真的东西理应付之于行动。
人对生命的依恋，具有某种比世间一切苦难更强的东西。
我们先有生活的习惯，后有思想的习惯。
所谓希望，就是对下辈子生活的希望，应当“对得起”才行，抑或是自欺欺人：不是为生活本身而生活，而是为某个伟大的理念而生活，让理念超越生活，使生活变得崇高，给生活注入意义，任理念背叛生活。
世人自杀，因为人生不值得活，想必是没错的，但不是什么真知灼见，因为这是显而易见的道理。
人生之荒诞，难道非要
世人或抱希望或用自杀来逃避吗
荒诞是否操纵死亡？必须优先考虑这个问题，甭去管形形色色的思想方法和无私精神的把戏。</description>
    </item>
    
    <item>
      <title>学术与政治</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E5%AD%A6%E6%9C%AF%E4%B8%8E%E6%94%BF%E6%B2%BB/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E5%AD%A6%E6%9C%AF%E4%B8%8E%E6%94%BF%E6%B2%BB/</guid>
      <description>马克斯·韦伯
第二章 政治作为一种志业 何谓政治？“政治”是一个涵盖极为广泛的概念，每一种自主的领导（leitende）活动，都算是政治。
我们今天所谓的政治，指的是对一个政治团体——这在今天是指国家（Staat）——的领导或对这种领导所施的影响。
每个国家的基础都在于武力
如果社会的构成竟全然不知以武力为手段，那么“国家”的概念必荡然无存，从而出现的，正是在这种情况下一般所谓的“无政府”状态。
国家者，就是一个在某固定疆域内——注意：“疆域”（Gebiet）乃是国家的特色之一——（在事实上）肯定了自身对武力之正当使用的垄断权利的人类共同体。
国家乃是使用武力的“权利”的唯一来源。
政治追求权力（Macht）[插图]的分享，追求对权力的分配有所影响——不论是在国家之间或者是在同一个国家内的各团体之间。
从事政治的人，追求的是权力；这权力或者是手段，为了其他目的服务，不论这些目的是高贵的或是自私的；或则，这权力是“为了权力而
追求权力”，目的是享受权力带来的声望感。
国家的存在，在于被支配者必须顺从支配者声称具有的权威（Autorität）。
支配的正当性根据
首先，“永恒的昨日”的权威：也就是权威因于“古已如此”的威信和去遵袭的习惯而变成神圣的习俗（Sitte）
其次，权威可以来自个人身上超凡的恩典之赐（Gnadengabe），即所谓的卡理斯玛（Charisma）
最后，还有一类型支配，靠的是人对法规成文条款之妥当性的信任、对于按照合理性方式制定的规则所界定的事务性（sachliche）“职权”的妥当性有其信任。
对于合于法规的职责的执行，人们会去服从。
在实际中，人们之所以会去接受支配，是因于恐惧和期望这类最真实不过的动机：恐惧魔法力量的报复、恐惧权力拥有者的报复、期望在世间或在彼岸得到报偿。
如果去诘问这些服从的“正当性”根据，则答案不出于这三种“纯粹”类型[插图]：传统型的、卡理斯玛型的和法制型的。
人们服从他，不是因于习俗或法条，而是因为人们信仰这个人。
在过去，最重要的卡理斯玛式人物有两类：一方面有法师和先知，另一方面则有战时推举出的盟主、山寨头子和雇佣兵领袖（condottiere）￼。
政治上的支配权力，如何维持其支配于不坠？
支配的经营（Herrschaftsbetrieb）￼，要求持续的行政管理。
在一方面，支配的经营，需要有人力配备，旨在听命于宣称持有正当权力的支配者；而在另一方面，支配的经营，需要借助于这种服从，对于使用武力时必需的物资有所掌握和控制。
支配的经营需要由人组成的行政管理僚属（Verwaltungsstab）和物资方面的行政管理工具。
促使他们去服从的，是两项诉诸他们个人利益的东西：物质上的报偿和社会性的荣誉。
行政僚属和权力拥有者之间的共命结合关系，最终、最重要的基础，就是怕失掉这些东西。
附从战争领袖者有荣誉和战利品可得，追随群众鼓动者的人也可分得“政治战利品”（spoils）：因为垄断了官职而得榨取被支配者、政治方面的利益以及获得虚荣心的满足。
行政工具包括了金钱、建筑物、战争物质、交通工具、马匹以及任何你想得出来的东西。
一方面，权力的掌握者私人拥有由他组织起来的行政体系，通过个人的仆从、聘雇的官吏、私人的宠臣亲信等进行行政管理工作，这一类人员自身对行政工具并无所有权，而只是接受主人之指挥行事；
他设法用自己的腰包、用他家产的收益，去供应行政工具；他建立一支军队，这军队完全依赖他个人，因为这支军队的给养和装备，取自他的仓廪、他的财产、他的武器库。
从来就不曾有过什么阶层，是从来不曾以某种方式利用政治地位谋取私人经济利益的。
有人得出这样的结论：一切文件，特别是显示自己的国家有过错的文件，都应该公之于世；根据这种单方面的公开发表，过错应该单方面地、没有条件地、不计后果地加以承认。可是政治家则会认为，这样做的结果，非但不是彰扬真相，反而使真相因滥用、因挑激起的激情而变得模糊不清。
对政治来说，决定性的手段是武力。
任何人，不论其目的为何，一旦同意采用（每个政治人物都采用）武力这种手段，就必须听任它的特定后果的摆布。
任何人想要用武力，在世界上建立绝对的正义，就需要为此有跟从者——由人所构成的“机构”（Apparat）。
这些跟从者，他一定要能描绘出必然可得的精神方面和物质方面的报偿的远景——不论这报偿是在天上或在人间；非如此，这个机构就不会运作起来。
领袖的成功，完全有赖于他创造出来的这个机构的运作。
所依赖的，是看他能不能持续地向他所亟须的跟从者——赤卫队、秘密警察、煽动者——保证这些报偿。
信仰的英雄，尤其是信仰本身，都会消逝，或者沦为（这更彻底）政治上的庸俗人物和政治技术家习用咒语的一个部分
到了那个时候，由于一系列的原因，反动的时期早已开始，你们之中许多人以及——我坦然承认——我自己都在盼望、期待的东西，竟几乎无所实现——也许不能说毫无所成，但至少看起来是太少的成果；
当时正当春天，我们的爱情甫绿， 日日我谱歌曲，吟我们的风流， 像夜莺在夏天锦簇的花丛中啼唱， 到了夏日渐深就锁住了她的歌喉。
不论现在在表面上看起来胜利的是哪一群人，在我们面前的，不是夏天锦簇的花丛，而首先是冷暗苛酷的寒冻冬夜。
当一切都荡然无存，丧失自己权利的不仅是皇帝，无产阶级也不会例外。
一切历史经验也证明了，若非再接再厉地追求在这世界上不可能的事，可能的事也无法达成。
个人必须是一个领袖，同时除了是领袖之外，更必须是平常意义下所谓的英雄。
必须强迫自己的心肠坚韧，使自己能泰然面对一切希望的破灭；
谁有自信，能够面对这个从本身观点来看，愚蠢、庸俗到了不值得自己献身的地步的世界，而仍屹立不溃，谁能面对这个局面而说，“即使如此，没关系”（dennoch），谁才有以政治为志业的“使命与召唤”。
附录三 韦伯论帝国总统 照古典的民主理念，民主旨在人民的权力，肯定人民是国家主权所在，使政治权力从属于人民的同意，甚至表达人民的公共意志。
民主不只是人民获得权力的途径，同时也是统治者取得权位，加强己身正当性的工具。
第一，具有特殊卡理斯玛（Charisma）的人物，可以摆脱或独立于政府及政党官僚体系，扮演“选举战场上的英雄”，成为群众中心服从的领袖。
一旦这种领袖上台，并且继续保有大量的人民支持，便不啻获得了强大的托付（mandate），让他有足够的正当性去面对官僚行政体系、国会、社会上的各种利益团体、地方山头等。
他强烈主张总统直选，但他的考虑不是人民的“民权”，而是强化领袖权力，使他能解决德国的现实问题，完成德国的民族目标。
导出于 2022-09-28 15:03:46</description>
    </item>
    
    <item>
      <title>政治学十五讲(第二版)</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E5%AD%A6%E5%8D%81%E4%BA%94%E8%AE%B2%E7%AC%AC%E4%BA%8C%E7%89%88/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E5%AD%A6%E5%8D%81%E4%BA%94%E8%AE%B2%E7%AC%AC%E4%BA%8C%E7%89%88/</guid>
      <description>燕继荣
序言 政治思考与思考政治 政治，离我们太远，又太近。
政治，太“高尚”，又太“黑暗”。
政治，太“高深”，又太“直白”。
武
力总是最简便最不劳神的手段。
“胜者为王，败者为寇。
但他要做的事情，是调整自己的策略，说服更多的支持者，而不是为了准备推翻这个规则而发动一场“革命”战争
政治，让我们“伟大”，也让我们“渺小”。
当我们获得绝对权力的时候，我们更可以为所欲为，体验君临天下的感受，享受运用权力所带来的快乐：
传统的中国被认为是一个高度“政治化”的社会，具体表现无非在于：（1）权力本位或官本位；（2）政治经济文化结构高度合一；（3）“皇权主义”和政治全能主义。
二、 讲政治：讲什么和怎么讲 我们经历过漫长的“不许讲政治”的年代。
我们也经历过“不许不讲政治”的年代。
我们也经历了“不许乱讲政治”的年代。
说到底，就是要解决自由-民主-平等-效率-权威的关系问题，并探索解决这些关系问题的可行制度和实现途径。
设计一种聪明的制度让即使不“聪明”的人也不至于做大不聪明的事，和一心指望或坚信聪明的人办聪明的大事
前者寻求的是“好制度”，后者寻求的是“好皇帝”。
三、 中国崛起靠什么 中国如何“崛起”？中国应该以怎样的形象“崛起”？“崛起”的中国应该向世界贡献什么？
中国崛起靠什么？
20世纪美国依靠经济规模、科技领先、普世文化、军事实力、自由国际机制等因素而成为世界大国。
传统而言，作战能力往往是检验大国的标尺。而现在，权力的定义不再强调昔日极其突出的军事力量和征服。技术、教育和经济增长因素在国际权力中的作用越来越重要，而地理、人口和原材料则变得越来越不重要了……国际政治性质的变化常常使无形的权力变得更加重要。国家凝聚力、普世文化、国际制度正在被赋予新的意义。这些趋势预示着传统途径之外第二种、更有吸引力的权力运用方式。简单地说，软性的同化权力与硬性的指挥权力同样重要
如果中国要崛起，就要坚持“硬实力”与“软实力”并举的战略——在国际社会中，军事力量和经济文化力量协同发展；在国内建设方面，显性的经济建设与隐性的制度建设齐头并举。
四、 制度建设很关键 从君主制退化到僭主制，然后又被贵族统治所代替；而后贵族统治又先后被寡头统治和民主政制所代替，接着再倒退回暴民政治；经过一段无政府状态后又回到原始君主制。
一个国家的崛起，总是与一定程度的军事实力和军事路线分不开，但是，军事实力的成功只是表面现象，而优良的制度安排才是大国崛起的标志和根本保障。
制度可以塑造一个人的行为，也可以型塑一个国家的发展模式。
所谓新的发展观，就是要将国家制度建设任务纳入到大国崛起的战略中予以考虑，将单纯的经济“赶超战略”转变为国家制度建设战略。
一、 政治研究在中国 中国古代关于政治的研究主要围绕君主的“治国之道”而展开。
他们被视为“守旧派”。
他们被视为“维新派”。
他们被视为“民主派”。
中国的马克思主义者可以视为“革命派”。
中国传统的政治思想并未能演化出一种新型的民主科学思想和现代政治价值观念。
三、 主要政治意识形态 各主要意识形态流派的历史渊源关系[9]
自由主义被认为是工业化国家的意识形态
它是封建主义（feudalism）走向衰亡、市场经济逐步发展的产物。
自由主义包含了丰富的内容，它既可以说是一种政治理论，也可以说是一种经济学说，还可以说是一种伦理观念。
伦理观念，它探讨的是个人与社会的关系问题，主张“己所不欲，勿施于人”
作为经济学说，它阐述的是自由经济、自由竞争、自由贸易的理论，反对国家对经济生活的干涉
作为政治理论，它研究的是个人与政府的关系问题，强调个人自由永远是目的、国家权威始终是手段。
作为对工业资本主义的反动，社会主义代表了早期工业化过程中产业工人的利益。
改良主义的社会主义思想
马克思主义“修正主义者”（revisionist）的伯恩斯坦
以列宁（Lenin,1870-1924）和俄国布尔什维克党人为代表的社会主义者，坚持走暴力革命的道路，为了与改良主义和修正主义的社会主义划清界限，他们自称共产主义者。
社会民主主义
社会民主党人放弃了马克思社会主义的正统观点和原则，如公有制和计划经济等，用社会福利（welfare）、社会再分配（redistribution）和经济管理（economic management）来重新定义社会主义。
一、 权力的含义和特性 权力是政治学的核心概念，正如货币或资本是经济学的核心概念一样。
政治学也就是关于权力的学问，政治研究就是关于权力分配方式和权力运行机制的研究。
如何理解权力、如何定义和衡量权力
在中国古代典籍中，“权”的概念有两个基本含义，一是有衡量审度之义，二是指制约他人的能力。[2]
意指“能力”
在罗马人看来，potentia是指一个人或物影响他人或他物的能力，而potestas还有一层更狭隘的政治含义，是指人们通过协同一致的联系和行为而产生的特殊能力
权力在于人民，权威在于元老院
在早期的观念中，权力与权威、强制、力量以及暴力等概念有着严格的区别。
按照新科学机械主义构想，把权力定义为一种因果关系，即“一种主动出击的‘行动者’和被动的‘承受对象’之间的因果关系”
全人类共同的爱好，便是对权力永恒地和无休止地追求</description>
    </item>
    
    <item>
      <title>政治学有什么用？</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E5%AD%A6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E5%AD%A6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</guid>
      <description>加雷思·索思韦尔
骑电瓶车必须戴头盔吗？ 自由不仅仅是达到自律，还要有助于提升政治参与度，完善公民权利，甚至促进幸福、健康和自我实现。
政府不应该仅仅保证最低程度的自由，还应该将它最大化。
“人类就其本质而言是政治动物”
这等于把他们当作“实现目的的工具”。
我们可以告诉他们不戴头盔的风险，但是我们不应该将不戴头盔定为违法行为。
我应该结婚吗？ 家庭是“为了满足人们的日常需要而天然形成的结合”，其中男人负责指挥而女人负责服从。
家庭确实为社会提供了基石，促进了男女之间自然的互相吸引，为生育和抚养孩子提供了有利条件。
柏拉图试图让婚姻成为一种短暂的联盟，由国家安排的婚姻仅仅是为了生育后代的目的，而整个社区都将担任监护人，负责抚养众人共同的后代，柏拉图希望用性吸引力来凝聚整个社会。
每个人生来都拥有爱；它将我们与生俱来的另一半召来；它试图将人合二为一，愈合人性的伤口。
婚姻是“自然法则”的一种表达形式，在其中女性拥有的理想能力可以“在生产工作中成为助手”，而男人更高一层，“能够从事一项更加崇高的重要行动，那就是智力活动”。
婚姻有助于抚育后代，而一夫一妻制为非理性的性冲动提供了合理的出路，可以使男人解脱，自由地发展更高尚的自我。
女性的主要作用是为丈夫服务，生育并抚养子女。
他认为女儿的教育在于让她有自知之明；她应当相信别人告诉她的话。
将婚姻视为一种契约，其中包括“两个不同性别的人的联合，他们认同在彼此的生命中互相拥有彼此的性属性”
双方仿佛会在婚姻中把对方当作自己的物质财产——当作物体，或者当作实现目标的手段。
将他人视为实现我们自己目标的手段，而不是把他们视为他们的目标本身，这会导致不道德。
因为这种“占有”是相互的，所以在这种情况下，这种“物化”就是合理的；你得到了我，而我也得到了你——只要我们俩都没有违反合同就没问题！
有那么多伟大的（男性）哲学家都对婚姻和家庭持同样保守的、以丈夫为中心的观点。
男性控制、拥有和剥削妇女和生育，与资本家对待工人和生产资料的方式如出一辙，而且婚姻积累财富并传给男性后代。
就像财产应该被“解放出来”并由公众共享，家庭也应该被“废除”，人们可以自由地互相结合。
一旦取消了与婚姻和家庭有关的限制，人们便可以自由发展自己想要的关系形式，无论是一夫一妻制或其他形式都可以。
是揭露谎言，即任何背离核心家庭规范的婚姻形式在某种程度上都是“不道德的”，而他认为，其中利害关系主要不是“道德”，而在于经济——所有权和控制权。
质疑终身的一夫一妻制在生物学和心理上是否真的适合人类。
一夫一妻制常常会导致痛苦，导致不忠和虚伪，以及神经官能症。
同性婚姻的法律和舆论态度发生了变化，许多同性恋伴侣开始拥抱婚姻，实现了长期以来遭到异性恋压制的同等待遇。
至少在某些社会中，人们越来越能接受不同的生活方式和性取向。
无论你是否是公众视野中的政治人物，你都不必屈服于“传统”的压力，决定你是否结婚的主要理由都应该是私人的因素。
导出于 2022-09-28 15:03:46</description>
    </item>
    
    <item>
      <title>政治是什么？</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>蔡东杰
社会 有这么一群人，决定长期共同生活 政治乃是处理众人之事。
人们干吗要挤在一块儿过日子
我们正生活在一个巨大问号的阴影下面；我们是谁？我们来自哪里？我们又将前往何方？
我们都能发现一个事实，亦即这类动物（人类）从很早开始就有着集体行动的特征，也就是说，他们喜欢一大堆人集中在一个约略特定的地域范围里活动，然后以某种分工合作的方式彼此照料，并且渐渐发展出简单的家庭单位与社会组织结构。
是否在日常生活当中采取集体活动的形式，绝对不像一般人直觉认为的那样，仅仅是由于某些物种因竞争弱势以致自然生成的自我防卫举动，而是一种非常普遍的自然现象。
自然界当中，大概除了阳光、空气和水等三种物质要素之外，就没有所谓“取之不尽，用之不竭”的资源了；
除了地球自然环境本身具备的“绝对”稀少性之外，有时候人为因素也会带来所谓“相对”稀少性，这也就是常见的“分配不均”问题。
即便是由于强者垄断而引发的稀少状态，垄断的前提大多也是因为强者体认到资源有限的事实，以致未雨绸缪的结果。
一方面由于物种存续需要各式各样资源的不断挹注，另一方面这些生存所需要的资源又大多具有前面提到的稀少性，于是高度竞争便成为一种自然而然的现象。
人类选择群居的理由究竟是什么呢？
人们为了获得特别的好处，并认为集体生活可以带来这些好处，于是便聚在一起；政治团体则因为可以带来总的好处，于是一直发展下去。
定居性农耕部落的出现确是个重要得不得了的转折点，因为固定的生活边界、共同生活的伙伴，以及伙伴性质的愈来愈复杂，在在都使得人们不仅无可避免地朝向更复杂的社会结构发展，也必须多花点脑筋来设计并调整彼此间的关系。
制度 于是分工合作起来了 人之有异于万物者何在？
从两个人（结婚）、几个人或几十个人（家庭或家族）、一群人（部落或村庄）到更多的人（国家机器），人类的群居方式与选项可说不胜枚举。
首先，人际关系的重点由此从共谋“安全”，转向以“合作”为主的互动
国家 日子久了之后…… 今天来看，我们都生活在某个“国家”里。不过，到底什么叫做国家？国家这种单位是怎么出现的？人民与国家间的关系究竟应该如何来定位？……显然，目前还存在一大堆的问号。
人类在加入社会后不但被迫顺从强制性的权力（主要通过法律规范形式来表现），而且没有自由进出社会的机会，甚至正如前面提到过的，政治
精英们还会不断设法垄断或扩张自己的权力，包括取得终身与世袭执政的“合法性”在内。
首先是我们根本找不到契约，其次是历史证据昭昭在目，在长达数千年的君权时代，保护人民的生命与财产安全看上去一直都不像是政府的主要施政目标。
事实上，主张国家是武力产物的说法由来已久
农民虽说是定居社会的主角，但因其生存有赖于在土地上进行定期耕作，换言之，离开土地就几乎活不了，因此在面对征服者不断威胁之下，也只有同意按时缴纳赋税以换取安全（如同缴保护费给黑道一样）。
人类最初加入社会或许是理性且自愿的，但社会的扩大与建构，却未必以同意为基础。
政府、人民、土地与主权
革命 不过，想让大家都满意是很难的 这些人究竟为什么不满？他们如何聚集同样有着不满的人民？这些人诉诸暴力行动的原因是什么？而政府通常又如何响应他们的诉求呢？
人类是如何通过组织自我来脱离原始蛮荒，追求更大的生存机会，同时又是如何去强化群体内部的凝聚力，以便应付一个又一个的挑战。
除非有不得已的理由，否则理应没有人会冒着生命危险去冲撞既有体制。
初出道的绿林好汉必须被群众视为值得敬佩或者是清白的，这点可说是非常重要，因为他们如果被认为是违反地方风俗的罪人，就无法享受到所希望仰赖的保护。
其次，他们（至少表面上）的目标大多都是为了“替天行道”，也就是树立起大家都能接受的正当目标。
虽然在组织运作过程中，由领袖来进行少数统治是无法避免的结果，但我们也设法描述了领袖们如何企图长期维系甚至扩张权力的过程；他们手中最重要的武器就是意识形态。
由政客所主导的意识形态首先会声称现行的规范系统是正当的，同时也会极力地避免这些规范的有效性受到大家的普遍检定（这也就是学术与媒体自由经常受压制的原因），其结果使得统治者的特殊利益被不当地以普遍利益的形象出现
革命更常见的原因其实来自某种“不均衡感”，也就是当政治系统连大家最起码的生存需求都没办法加以响应的时候，那么人民当然只得诉诸“自力救济”；这也是陈胜与吴广为什么要揭竿而起反抗暴政，同时会有那么多人追随他们的原因所在。
避
首先，我们强调人类倾向于根据“自保”原则，为解决生存竞争压力而缔造制度；但在建立制度的过程当中，至少到目前为止，“政治阶层现象”与“权力”依旧是设计师们没有办法去除的两个附带品，其中，前者使我们被迫筛选出（其实在多数情况下是他们自己跳出来）少数人来负责操纵制度，后者则如同病毒般不断侵蚀免疫系统，最后让制度的运作逐渐偏离原先设定的轨道。
我们必须承认，人多嘴杂确实容易坏事，因此让少数秀异分子来“帮大家完成理想”是个挺不错的选项。但是，只要我们一直拿不出能够有效运作的价值测量表，以便对那些自愿参政者做真正的筛选，权力病毒便会以这些政客作为“宿主”，先是利用他们进入制度内部，接着在腐化他们的脑神经后再进一步重组（或者摧毁）制度。
尽管所有制度设计的重点都在于服务多数人的利益，并防止权力腐蚀制度根基，但事实上的挑战却不断接踵而至。
一个无法响应人民需求的制度，是既不可能让人满意也不可能稳定的。
根据执政理性来看，人民所得愈少则统治者所得自然愈多；因此，从“获利极大化”的前提出发，统治者必然会不断试探人民忍耐程度的底限，然后尽可能不越过底限以避免触怒人民。
首先是创造可用来维系政权正当性的意识形态，以便从心理层次对被统治者实施催眠动作，其次则是根据这种意识形态来创造社会阶级架构，
一般来说，意识形态与阶级架构是互补互生的，其目的都在于迫使人民打心眼里接受自己的社会地位；在这种情况下，多数人民当然无法脱离“乐岁终身苦，凶年不免馁亡”的命运。
被驯服的民众所以会冒险发动革命，其原因多半是“经济问题”（帝国暴政或王朝腐败经常被夸大）。
尽管革命确实有着“由下而上”的特质，但所谓“下”未必指的都是普通人民。
比起绝大多数缺乏意志与冒险犯难精神的民众，政治变迁其实更可能来自政治或军事精英的反叛，而非一般焦点所关注的“农民起义”或“人民革命”。
政党 让大家来自由竞争 民主的合法性，乃因选民弃权而来。
在一个多数人纷纷自愿或被迫疏离在政治过程之外，但民主政治又被高举为主流大旗的矛盾状态中，到底是谁在操控并运作着政治生活呢？那些操控政治生活的人究竟是民主的变相实践者，还是只不过将民主当作权力正当性来源而已呢？我们对这批人又有何期待呢？
究竟是谁在扮演着推动政治的“幕后黑手”呢？
在过去漫长的君权时代中，精英们若想跻身权力核心，有正确的DNA当然最好（也就是拥有跟当权集团分子一样的血缘组成），其次则必须有赖于他们对捍卫政权的贡献（名义上是保卫疆土或为国家鞠躬尽瘁，其实只是为了强化政权的根基），然后再由他们与当权者间的关系来决定其权力位置（没贡献但会拍马屁者总能够衣紫腰金并坐享荣华富贵，有贡献但关系不好者却只能面对如岳飞般的命运）
在争取人民认同的过程中，个人的权力野心必须被隐藏起来，取而代之的是一些所谓国家愿景、建设计划与他们所归纳出来的“民意”；
这些精英在权力核心里是如何进行你争我斗的。
精英们自古以来除埋首于不断提高自己地位的“垂直性”竞赛外，也会进行“水平性”的集团间斗争。
正如人类在竞争激烈的自然环境中必须通过集体行动来满足生存与物种演化的终极目标，在各自形成不同社会群体后，又继续借由诸如战争等同类相残来取得更大的“生存空间”一般，精英们所身处的政治环境似乎也隐含着这样的残酷本质，其中的竞争性甚至更为强烈。
相对于人群在社会生活中可以各据山头甚至互不来往，政治环境由于具有非常明显的金字塔结构特征，使得你死我活的“零和竞赛”变得不可避免。
一方面集结那些看来志趣相投或至少目标一致者，以壮大声势，再设法干掉那些老是跟自己唱反调的对手，最后在夺取权力大饼后进行“坐地分赃”的工作；
我们必须承认，在争名逐利的政治黑色游戏中，还是有些蠢得可爱的理想主义者会参与其中。
由此，一方面残酷权力斗争的本质部分被掩盖起来，另一方面，现代政党所高举的政策或意识形态大旗，也让更多无辜或不知其所以然的民众盲目投身其中，跟着摇旗呐喊，无形中成为许多政客的护身符
现代政党究竟是如何形塑并演变出来的？
政党是一群想法类似者为追求实践其政治目标（通常就是掌握决策权）而结合成的精英性团体。
首先，多数学者都很难接受，一个国家仅存在一个政党，或者长期仅由一个主要政党来掌握政治权力，无论是被称为“一党威权制”（限制其他政党参与）、“一党极权制”（排除其他政党参与）还是“一党霸权制”（事实是没有其他政党能有效分享政权），就能反映整个社会的需求。
列宁式政党或过去墨西哥的革命建制党等拥有“党国合一制度”者，更只是一个用来检验忠诚度的机关罢了。
只剩下两个政党在多元化社会中无论如何都还是个相对荒谬的现象。</description>
    </item>
    
    <item>
      <title>民主的细节：当代美国政治观察随笔</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%B0%91%E4%B8%BB%E7%9A%84%E7%BB%86%E8%8A%82%E5%BD%93%E4%BB%A3%E7%BE%8E%E5%9B%BD%E6%94%BF%E6%B2%BB%E8%A7%82%E5%AF%9F%E9%9A%8F%E7%AC%94/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%B0%91%E4%B8%BB%E7%9A%84%E7%BB%86%E8%8A%82%E5%BD%93%E4%BB%A3%E7%BE%8E%E5%9B%BD%E6%94%BF%E6%B2%BB%E8%A7%82%E5%AF%9F%E9%9A%8F%E7%AC%94/</guid>
      <description>刘瑜
托克维尔的那场旅行 一方面，他意识到民主的崛起是势不可挡的历史必然趋势，而且他也相信民主可以消除专制制度的一些弊端；另一方面，他又非常忧虑民主可能的危害：他忧虑民主会造成“多数暴政”，忧虑民主会使人们偏好“做奴隶的平等”甚于“自由下的不平等”，尤其忧虑民主会导致整个社会智识的平庸化，“吸干诗意的源泉”。
“不够民主”一定是件坏事吗？一个社会一定是越民主越好吗？
主导思想本来就不是“民主最大化”，而仅仅是“制衡最大化”。
美国的先驱之处，就在于它是第一个让权利的水滴从皇宫贵族渗向平民百姓的现代国家。第一步是权利的下渗，第二步才谈得上渗透的均匀。
选谁都差不多 对于一个普通美国人来说，州级选举对他们衣食住行的影响，其实比总统选举要大。
专制者更可以声称：既然在民主选举中“选谁都差不多”，那还要选举做什么？所谓选举，不过就是一群戏子做戏而已。
“选谁都差不多”这个现象的发生，其实恰恰是两党激烈竞争的结果。正是因为两个政党在竞争中都要争取大量的“中间选民”，所以它们的政见日渐“趋中”，最后，两党的政见往往稳定在最大多数选民比较赞同的位置上。而一个上台的政党，代表多数人的利益，这恰恰是民主的含义。
从这个角度来说，“选谁都差不多”又是好事，因为它说明不同的政党都在使劲谄媚“多数老百姓”。
投票率低，至少对于某些人来说，恰恰说明他们对政治体制的信任：既然我就算不投票，也要么能吃到拉面，要么吃到刀削面，那我投不投票也无所谓了。
选举议题的“鸡毛蒜皮”化，在一定程度上，恰恰是美国社会在重大基本问题上达成了共识的表现。
如果一个国家连这些最基本的共识都还没有形成，“右派”坚持工人不能成立独立工会，“左派”坚持反对市场经济，而我是那个国家的公民，那我当然会举着选票跑到投票箱前了。毕竟，在那种政治环境下，选谁会非常不一样，我可不想被人按着脖子，吃下自己不爱吃的三明治。
动什么，不能动宪法 布什的窃听计划因程序可疑而激发民愤，公众认为这是美国向极权体制敞开了大门。
在这个以自由和法治立国的国家，人们对自己的隐私权利、言论自由以及法律程序，有一种“神经质”的警觉。
一个就是对窃听本身的不满。在许多人看来，对民众言论广泛的监控，是极权统治的起点，是对自由原则的背叛。
第二层不满，集中在窃听的法律程序上：按照美国1978年制定的“外国情报监控法案”，美国政府对其公民的信息监控，必须首先申请一个特别法庭的批准。
它以“反恐”之名，越过法庭的审判，任意地、无限期地扣留政府眼中的“恐怖分子嫌疑人”。
反恐战争中的决策，并没有一般战争中的紧急性，而且，它是无限期延伸的。如果用它来为布什政府的独断辩护，那么美国公民的自由和权利就得无限期地搁置了。
美国这个国家的立国之本——三权分立的失衡。
美国的民主已经处于水深火热之中。
总统权限是“保证法律被忠实地执行”。
按照宪法的原意，总统拥有的是“执行权”，他本身并没有立法权，不能自由地去“开发”权力。
首先，美国总统选举形式的变化，使得总统越来越拥有自己独立的选民基础，并不需要对国会俯首称臣。
其次，数次政治经济危机，都给了总统扩大权力的机会。
在所有这些危机中，无疑罗斯福新政时期，是总统权力扩张最迅猛的时期。
最后，同时可能也是最重要的，还是现代社会运转方式“理性化”的后果。
许多人认为，小布什是自尼克松以来最“猖獗”的总统，直接传承了尼克松的“帝王总统”风格。
君让臣下，臣可以不下 在美国的“分立三权”中，联邦行政权这一块是完全由总统统领的，也就是说，“各部委”负责人是总统任命的，不是民选职位。同理，各“部委”内部的工作人员也是由其负责人任免，也不是民选职位。这也是为什么美国每一个新总统就职，都会带来一次“领导班子”的大更迭：每个总统都会想办法在政府内部安插本党的甚至本人的亲信，以提高本届政府的行政效率。
虽然这个替换有一个参议院批准的程序，但是这个审批针对的这些职位的“任命”，而不是“罢免”。
因为这些律师对布什政府“效忠不够”。
政党利益不应当高于国家利益，虽然联邦律师由政府任命，一旦开始工作，他们应当秉承中立原则。
在这样的国家里，真正的“君主”不是某一个人，而是一部在各种力量相互制衡不断被激活的宪法。
怎样保护弱势群体 在一个以社会主义立国的国家里出现奴工，不得不承认，我们的制度生病了。
保护弱势群体最有效的方式，莫过于增强弱势群体的“自组织”能力。
唯一缺失的，反而是那些奴工自己的声音。但是仔细想来，当各级官员、地方警官、媒体记者甚至普通网民都争先恐后地“代表”弱势群体时，难道能有谁比弱势群体更能代表他们自己？
最核心的要素，就是一个独立工会和它的结社、集会、言论自由。
既然“鸡毛蒜皮”都可以动员出如此强大的社会组织资源，一个有着强大自组织能力的社会又怎么会对“现代奴隶”这样的滔天罪行坐视不管呢？
弱者需要政府来保护他们，但是他们更需要的，是政府允许他们保护自己。
社会的自组织力被政治和资本的力量联手瓦解，今天出现这样的奴工场景难道有什么可奇怪的？
大学向左，草根向右 近年来非法移民问题是美国的一个热点问题：右翼势力倾向严格禁止非法移民入境，左翼主张更宽松的政策。
没有非法的人。
所有移民都应得到公民权！把种族主义的民兵成员赶出去！建立一个革命工人政党！
左翼趾高气扬，右翼垂头丧气。
在当代美国的“左”“右”含义。
第一，外交事务上，一般右翼倾向于扩张性外交，传播美国价值，强化美国地位，支持伊战；第二，经济事务上，右翼一般主张自由贸易，削减福利，削弱工会；第三，在社会文化上，右翼一般是“保守”的代名词，反对堕胎，反对同性恋婚姻，反对非法移民入境等。
因为文化上的分野，一般右翼也被称为“保守派”，左翼也被称为“自由派”。
右翼倾向文化保守的同时主张经济的自由化，左翼主张文化自由的同时又主张经济的控制，严格来说还真说不清谁比谁更拥护真正的自由。
2005年的一个调查表明，美国高校里72％的教师是“左翼自由派”，15％是“右翼保守派”。从党派来说，50％的教师支持民主党，11％支持共和党。
高校这样远离经济基础的象牙塔，是政治浪漫主义的温床。
虽然整个高校都左倾，但是越是远离经济基础的院系，就越左倾：人文院系81％教师是自由左翼；社会科学75％；工程学院51％；商学院49％。
直到今天，一个幽灵，左的幽灵，在大学校园的上空游荡。
说到底，对自由的威胁，不仅仅来自于政府，也可以来自于舆论。
因为对自由的威胁，不管来自政府还是舆论，都是对真相威胁的开始。
控制石油的什么 No blood for oil”了（不能为了石油而流血）。
不为石油为什么？大规模杀伤性武器又找不到，难道美国还真就是为了给伊拉克人民输入自由民主？美国还真成了雷锋不成？
成熟的民主国家之间没有战争
一个朋友说：我不在乎别人的观点是不是和我的一致，甚至不在乎别人的观点是不是愚蠢，我在乎别人的观点是不是“独立思考”的结果。
当你拥有一个观点的时候，是通过你自己掌握的信息独立做出的判断，而不是因为一百个人里面有九十九个这样说了所以人云亦云地这样说。
敌人的权利 检验一个国家的文明程度，其实不是看多数人，而是看少数人，比如残疾人，同性恋，外来移民，他们的权利有没有得到保护。</description>
    </item>
    
    <item>
      <title>政治秩序的起源：从前人类时代到法国大革命</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E7%A7%A9%E5%BA%8F%E7%9A%84%E8%B5%B7%E6%BA%90%E4%BB%8E%E5%89%8D%E4%BA%BA%E7%B1%BB%E6%97%B6%E4%BB%A3%E5%88%B0%E6%B3%95%E5%9B%BD%E5%A4%A7%E9%9D%A9%E5%91%BD/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E7%A7%A9%E5%BA%8F%E7%9A%84%E8%B5%B7%E6%BA%90%E4%BB%8E%E5%89%8D%E4%BA%BA%E7%B1%BB%E6%97%B6%E4%BB%A3%E5%88%B0%E6%B3%95%E5%9B%BD%E5%A4%A7%E9%9D%A9%E5%91%BD/</guid>
      <description>弗朗西斯·福山
第6章 中国的部落制 随着等级社会的逐渐成形，统治者开始垄断巫术，借此来提升自己的合法性。
中国西部的秦孝公和谋臣商鞅，奠基了世界上第一个真正现代的国家。
中国历史的早期社会由宗族组成，即同一祖先的父系家族。基本军事单位由宗族内大约百家男子组成，以宗族领袖为首，聚集在同一旗号下。宗族又可灵活组合，凝聚而成氏族（clan）或更高层次的宗族，而国王只是特定地区所有宗族的最高领袖。
依此类推，如要彻底摧毁敌人，一定要毁其祖庙，劫其珍宝，杀其子孙，绝其香火。
中国数世纪的历史中，亲戚团体的某些特征是万变不离其宗的。
相比之下，氏族是容纳若干宗族的更高级组合，通常基于虚拟（fictive）的亲戚关系。这种氏族和相关的姓氏联盟之所以存在，只是为了确定异族通婚。
女子不是宗族的永久成员，而是与其他重要家庭联姻的潜在资源。
中国北方，宗族力量逐渐变弱，宗族成员搬往分散的村庄，丧失了相互之间的认同。在南方，宗族和氏族成员继续并肩生活，以至整村人只有一个姓。
最混乱和误用最多的，可算是“封建的”和“封建主义”。
根据卡尔·马克思开创的传统观念，“封建主义”往往指欧洲中世纪庄园上领主和农民之间的经济剥削关系。
从政治发展的角度看，欧洲封建主义的关键不是领主和属臣之间的经济关系，而是隐含的权力分散。
封建制度的独特处恰恰是它分散的政治权力。
在这个意义上，周朝的中国是个封建社会，与中央集权国家没有相似之处。
在春秋时期，“国家像一个放大了的家庭。君主统而不治；大夫们很重要，不是因为其职位，而是因为他们是君主的亲戚，或是显赫家庭的家长”。君主与其说是真正的一国之主，倒不如说是伙伴中的老大。
周朝早期政体是部落的，至多是酋邦的，而绝不是国家的。
等级制度在狩猎和征战中脱颖而出，因为有些人或群体就是略胜一筹。
狩猎所需要的合作技能进化成军事战术和战略。
狩猎把动物送上祖先的祭台，战争把战俘送上祖先的祭台。
特别可恨的敌人则被剁成肉酱，供宫廷或军队成员进食。
发动战争是为了使另一氏族承认自己的霸权，或是为了荣誉受到藐视而实施报仇。
第8章 伟大的汉朝制度 以后的世袭贵族试图在中国掌权，不是打造地方上的权力基础，而是直接攫取中央政府。强大国家早期的中央集权，随着时间的推移，竟使自己变得永久化了。
没有一名儒者相信，对皇帝的权力或权威应有制度上的正式制衡，更不用说普选或个人权利。对皇帝权力的唯一制衡是道德；也就是说，给予皇帝正确的道德教育，敦促他仁民爱物，并时常劝诫他不可辜负这些理想。
皇帝身处儒家官僚机构之中。官僚机构只是皇帝的代理人，没有制衡皇帝的正式权利。但像所有的官僚，凭借专长和帝国运作的知识，他们施加了可观的非正式影响。
必须依赖众多顾问来制定政策、执行命令、判决呈入朝廷的案件。这些官员负责训练年轻太子，等他们长大登基后，再提供咨询服务。传统和文化上的威望，增加了高级官僚左右皇帝的影响。
武装起义是对坏皇帝的最后制裁，根据儒家天命流转的原则，又是正当合法的。
没有精确规则来确定谁享有天命，其获得往往是在造反成功之后。
显而易见，这种制衡是非常极端的，带有极大风险。
君以民为贵的儒家思想，把负责制的原则带进了中国政府。但要注意，这个负责制不是正式或程序上的，而是基于皇帝自己的道德观念，而这观念又是官僚机构所塑造的。
官僚机构所塑造的道德说教，主要反映了自身利益。也就是说，他们强烈反对法家君主赤裸裸的专制统治，因为儒家就是这种权力的首批受害者。他们只想在汉朝复辟时期保护自己的地位。这些官僚不是公众利益的监护人，而在代表基于亲戚关系的社会等级制度；他们自己，又恰恰身处该制度的顶端。
至少在原则上坚持君主应对人民负责，并执意保护抗衡集权的现存社会制度。
它日愈合理化和建制化，一步步解决家族统治的地方势力。
政治制度的现代化，就是指家族统治被官僚机构所取代。
现代官僚机构的特征包括：因功能而分的官职需有明确专长、在界定清晰的等级制度中设立各级官职、官员不得有独立的政治基础、官员必须遵守等级制度中的严格纪律、薪俸官职只是谋生的职业。
西汉的中国政府几乎符合现代官僚机构的全部特征。
汉武帝治下，官员被要求担保其推荐人选的孝悌和正直。
汉朝的中央政府日愈官僚化。职位最高的官员是三公，从高到低分别是丞相、御史大夫、太尉。有时，丞相职位一分为二，分成左右丞相，可以互相监督，互相制衡。三公之下是九卿，各有自己的僚属和预算。最重要的卿中，有掌管宗庙祭祀的奉常（后改称太常）、负责皇帝禁卫的光禄勋（秦时称郎中令）、负责皇宫和京城守军的卫尉、负责皇帝财政的少府、负责司法的廷尉、负责粮食和税收的大司农。
一般来讲，征战成功的王朝创始人一旦登基，就会卸下戎装，实施文官统治。
真正的政治权威在于教育和教养，而不在于军队威力。觊觎王位的军人发现，必须披上儒家学问的外衣，方能获得他人的信服；必须让儿子接受大儒的调教，方能继承王位。
大多数军官即使在梦中也不想去推翻美国宪法，如果真的想做，他们指挥的大多数士兵也不会服从命令。
第9章 政治衰败和家族政府的复辟 先前的平衡不再有效，引起政治衰败，直到现存参与者发明新的规则和制度来恢复秩序。
除了中国，宦官还在很多帝王的宫廷中扮演重要角色。他们已被阉割，不再有性感觉和性能力，所以深得信任。他们没有家庭，在心理上完全依赖主人，也不会想方设法为子女（因为不存在）争夺利益。他们扮演重要角色，帮助中国皇帝避开强大自治的官僚机构，并慢慢发展了自己的集团利益。
儒家是一种道德，不是超现实的宗教，一直是精英的行为准则。道教源于古老的民间信仰，现在变成非精英的抗议宗教。
在中国，宫廷中的权力就是通向地产的阳关大道，有权有势的官员可获得土地、侍从、农民、免税特权。
他们利用政治关系攫取国家权力，再使用国家权力使自己富上加富。
农业社会有条大庄园的铁律：富人将变得更富，除非遭到遏制——或是国家的，或是农民起义的，或是国家害怕农民起义而采取的。
技术是呆滞的，创业或创新的人得不到奖励。农业机械化之前，没有大规模生产的好处，所以无法解释大庄园的扩张。大地主的耕田都是分成小块，让单独农民家庭各自耕作。因债务机制，最初资源的小差别将与日俱增。
很多农业社会已达到其技术可能性的顶端，进一步投资不会增加产量。唯一的经济增长是粗放增长，即开发新耕地，或干脆争夺他人的。
财富的实际分配，代表不了生产效率或勤劳与否，只能代表起初的运气，或者业主与政治权力的关联。
汉朝的中国君主最初选择支持农民，一起反对愈益强大的大地主。
中国是创造现代国家的第一个世界文明。但这个国家不受法治限制，也不受负责制机构的限制，中国制度中唯一的责任只是道德上的。没有法治和负责制的强大国家，无疑是一个专制国家，越是现代和制度化，它的专制就越是有效。
它没有激励人心的意识形态来为自己辩解，也没有组织一个党派来实现它的愿望，凭借当时的通信技术还无法深入中国社会。它的权力所到之处，它的专制是如此暴虐，以至激起了导致自己迅速灭亡的农民起义。
第26章 更完美的专制主义 共产主义为何在俄罗斯和中国获得彻底的成功。
布尔什维克之前的俄罗斯，其取得的专制主义的性质，不同于法国或西班牙的旧政权，更接近于前现代中国或奥斯曼。
不管怎样，蒙古入侵对俄罗斯后续的政治发展施加了重大影响，且多半是消极的。首先，它切断了俄罗斯与拜占庭和中东的贸易和思想交流，后者曾是俄罗斯宗教和文化的来源。也阻碍了它与欧洲的联系，这意味俄罗斯没像西欧那样，深入参与相关的历史进程，比如文艺复兴和宗教改革。
其次，蒙古占领大大延误了俄罗斯的政治发展。
最后，蒙古人破坏了继承于拜占庭的法律传统，使政治生活变得更为恶劣、更为残忍。
蒙古统治者把自己看作纯粹的掠夺者，其目的就是从所控制的居民身上榨取资源。
他们严惩任何抵抗力量，为了杀鸡儆猴，甚至愿意处死整座城镇的居民。
他们招募俄罗斯的领主成为自己的征税官，包括将来创建俄罗斯国家的莫斯科大公。他们以自己的掠夺策略，训练数代的俄罗斯领袖。事实上，他们通过联姻而融入俄罗斯人口的基因。
俄罗斯贵族作为一个阶层，其内部团结很差，几乎没有发展出联合抵抗中央国家的机构。他们以内部的小争执而著称，经常自我损耗。
苏共总书记怀疑身边处处有阴谋诡计，杀光了当年与其携手闹革命的老共产党员。它也使人不得不忆起清洗贵族精英的中国统治者，像武则天。</description>
    </item>
    
    <item>
      <title>权力</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9D%83%E5%8A%9B/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9D%83%E5%8A%9B/</guid>
      <description>德博拉·格林菲尔德
第一部分 权力到底是什么？ 掌握权力的人控制着我们的命运。
权力能带来发展，也能导致毁灭；
权力能决定谁去参战、为什么需要和平，以及为何而战；权力能决定我们的生活方式、法律法规，能决定谁拥有物质上的优势、谁没有物质上的优势。
权力是人类关系的根本力量。
权力决定了谁生、谁死、谁来讲述你的故事。
我们之所以在乎权力，是因为我们害怕死亡，而权力可能会带来某种永生。
权力具有生存价值，不仅能使我们更容易获得共享资源、掌控自己的命运，而且能强化我们与他人之间的关系，提高我们在部族中的地位。
在我们的印象中，一个人掌握的权力越大，就能活得越长久、越精彩，甚至在他离开人世之后，依然能够活在别人的心中。
我们每时每刻都在处理权力分歧，调解有关权力的问题，但我们却常常认为是在处理与权力无关的事情。
我们也经常想要比较一下谁知道得更多、谁的人脉更广、谁的利益最重要、谁最后拍板、谁占据道德优势、谁制定规则，等等。
一个人要想成为强权人物，他就需要不惜一切代价，不惜牺牲其他所有人，努力让自己强大起来，以致能够统治世界。
我们不知道大权在握的同时如何做一个好人。
这似乎表明权力可以激发出每个人内心的邪恶。
在我们充满竞争色彩的文化中，把权力看作自我提升的手段是很自然的，但权力也是我们用来照顾我们关心的人的工具，而这本身也是一种自我提升。
权力既能让人表现出其最高尚的一面，也能让人表现出最卑劣的一面。
从本质上来说，权力本身并无好坏之分，掌权者也无高下之分。
不是我们拥有多少权力，而是我们如何运用权力。
谁会得到权力，为什么会得到权力，以及如何得到权力，就必须了解权力到底是什么，以及权力不是什么。
再没有比合适的理论更实用的东西了。
从定义上说，权力是控制他人及其结果的能力。
权力取决于他人对你的需要程度，尤其是为了获得不菲的奖赏和避免惩罚。
有人因此需要你，你比其他人更能满足他们的需要时，你就比他们拥有更大的权力
别人需要你的时候，就会主动取悦你，这就赋予了你控制权。
地位是衡量别人对你的尊重程度的标准。
有了地位，通常就有了权力，因为人们想和你建立联系。
职权是基于正式的职位或头衔，告诉别人该做什么的权力。
没有正式的职权也可能拥有权力（就像司机腾出停车位一样）；没有真正的权力也可能拥有正式的职权，
影响力是权力作用的结果。使用影响力意味着你不必使用武力。
当你有能力强迫别人时，事实上根本不需要使用武力。
简而言之，权力就是社会控制的能力。
任何人的权力都完全取决于权力生效时的环境。权力存在和消亡于人际关系之中、目标和目的之中、环境之中以及社会角色之中。
导出于 2022-09-28 15:03:44</description>
    </item>
    
    <item>
      <title>权力：为什么只为某些人所拥有（经典版）</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9D%83%E5%8A%9B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E4%B8%BA%E6%9F%90%E4%BA%9B%E4%BA%BA%E6%89%80%E6%8B%A5%E6%9C%89%E7%BB%8F%E5%85%B8%E7%89%88/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9D%83%E5%8A%9B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E4%B8%BA%E6%9F%90%E4%BA%9B%E4%BA%BA%E6%89%80%E6%8B%A5%E6%9C%89%E7%BB%8F%E5%85%B8%E7%89%88/</guid>
      <description>杰弗瑞·菲佛
第四部分 踏上你的权力之旅 当形势大好，金钱滚滚而来时，我更容易容忍一些合伙人的混蛋行为。但如果他们没有为我赚来很多钱，我们又不得不缩减公司规模时，我对他们的行为方式的容忍度就降低了。
如果你不喜欢这些新闻，那就走出去自己制作新闻。
抓住一个可用的机会，填补领导力真空，利用形势建立更高的知名度，并建立更多与高层的联系。
80%的成功都是自我表现。
根据你的天资和兴趣，找到适合你的地方，这一点非常重要。
如果每个人都在做什么事，一定是因为那是一件正确的或聪明的事，如果你做别的事情，就相当于背离了他们的集体智慧。
我们看到的往往是我们所希望看到的东西。
成功的最大障碍，不是缺乏才华或积极性，而是身陷错误的地方，他们的工作所需的权力和影响力不符合他们的天资和兴趣。
如果你觉得自己很强大，你就会在举止中散发出权力感，而其他人也会做出相应的反应；
获得权力的方法之一，就是通过你的举止和谈吐让别人感到你有权力。
导出于 2022-09-28 15:03:44</description>
    </item>
    
    <item>
      <title>权力及其逻辑</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9D%83%E5%8A%9B%E5%8F%8A%E5%85%B6%E9%80%BB%E8%BE%91/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9D%83%E5%8A%9B%E5%8F%8A%E5%85%B6%E9%80%BB%E8%BE%91/</guid>
      <description>[德]多米尼克·迈尔(Dominik Meier)
第一章 权力的本质 只有当有机会在他人不情愿的情况下坚持自己的意愿的时候，权力才存在。
权力既可以被理解为具体个人用于对他人形成潜在控制的工具，也可以被理解为社会结构用来控制参与其中的个人行为的潜在工具。
无人有权力！
如今，凡掌权的都是恶魔。
获取权力总是不道德的，行使权力总是不道德的，以及，无论是否使用，权力本身总是不道德的。
权力的地位取决于具体问题，即何人在何事上对他人具有何种程度的权力。
权力本身在道德上既非善也非恶，这是我们的观点。
养育后代的责任要求直接拥有权力。
不幸的是，暴君式的父母和不称职的医生大有人在。
权力总是邪恶的，“无论谁行使它”，这个观点已经不成立了。
当权力存在时，自由就消失了。如果我们真的是自由的，那么我们将不受任何权力束缚，因为权力总是意味着对自由行为的潜在限制。
权力和自由之间的关系不是相对的，而是一种辩证关系，这是我们的第二个原则。
首先，我们认为权力是自由的前提。
只有当屈服成为事实、自由意志被破坏的时候，权力才生效。
只要我们威胁能够将某人射死，我们就有权力控制他们。
一旦我们将威胁付诸实践，我们的权力就会失效，因为受到威胁的人不愿满足我们的要求。这个受了致命伤、曾经受到威胁的人现在用死亡完全剥夺了我们的权力。
第三章 权力的实践 全球化给权力领导体系带来的挑战。 导出于 2022-09-28 15:03:44</description>
    </item>
    
    <item>
      <title>权力精英</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9D%83%E5%8A%9B%E7%B2%BE%E8%8B%B1/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9D%83%E5%8A%9B%E7%B2%BE%E8%8B%B1/</guid>
      <description>C.赖特·米尔斯
内容简介 美国当时是由军事领袖、企业富豪和政治董事构成的权力精英阶层进行统治的大众社会，而非自由民主的国度。
启发我们思考自己所处的社会制度、社会权力结构和社会形态，权力在社会中是如何分配和运作的，以及精英、权力和民主的关系等
第1章 上流阶层 普通人的权力受到其日常生活世界的制约，甚至在工作、家庭和邻里方面，他们也常常似乎被自己理解不了但无法驾驭的力量所驱使。
现代社会的特有架构不是从自身，而是从各个层面去设计人生，这些变化现在压迫着大众社会的男男女女，因此他们感到在一个自身毫无权力的时代茫然无措。
随着信息和权力手段的集中，一些人占据了美国社会俯视众生的职位，也就是说，他们通过自己的决策，可以影响普通人的日常生活。
他们是伯克哈特所说的“大人物”。
他们支配着大公司，操纵着国家机器并拥有各种特权，指挥着军队，占据着社会结构的战略要津。所有这一切集中了他们享有的权利、财富和名望的各种有效手段。
紧挨着权力精英之下的是权力中层的职业政客，
第15章 高层的不道德 诚然，在健全的制度下也可能有腐败者，但倘若制度造成腐败，则在其中生活与工作的人也必然会被腐蚀。 导出于 2022-09-28 15:03:44</description>
    </item>
    
    <item>
      <title>极权主义的起源</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9E%81%E6%9D%83%E4%B8%BB%E4%B9%89%E7%9A%84%E8%B5%B7%E6%BA%90/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%9E%81%E6%9D%83%E4%B8%BB%E4%B9%89%E7%9A%84%E8%B5%B7%E6%BA%90/</guid>
      <description>汉娜·阿伦特
第三部　极权主义 相反，在传统的东方专制的土地上。在印度和中国，极权主义统治却有极好的机会，那里几乎有永不枯竭的材料可以喂养极权统治的那架不断积聚权力、不断毁灭人的机器，更有甚者，那里的人典型地感觉到人口太多。
过去一百五十年间大规模失业和人口剧增现象并存——几百年来普遍地蔑视人类生命价值。
第十三章 意识形态与恐怖：一种新的政府形式 凡是在它崛起执政的地方，它建立全新的政治制度，摧毁一个国家所有的社会、法律和政治传统。
一方面是滥用权力，不受法律节制，屈从于统治者的利益，敌视被统治者的利益，另一方面，恐惧作为行动原则、统治者害怕人民，人民害怕统治者——这些在我们全部的传统中都是暴政的标志。
导出于 2022-09-28 15:03:44</description>
    </item>
    
    <item>
      <title>民主的逻辑</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%B0%91%E4%B8%BB%E7%9A%84%E9%80%BB%E8%BE%91/</link>
      <pubDate>Wed, 28 Sep 2022 15:03:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%B0%91%E4%B8%BB%E7%9A%84%E9%80%BB%E8%BE%91/</guid>
      <description>包刚升
3.4 第三波民主化：全球时代 西班牙一般被视为第三波民主化的典范，该国通过执政者主动发起的政治转型完成了从军人统治向民主政体的变迁。
佛朗哥尽管是一位政治上的独裁者，但在他统治期间，西班牙的现代化程度有了稳步提高，经济发展、社会进步和对外开放都取得了很大进展。
这位流亡者不禁拷问自己：为什么当年要跟佛朗哥的军队作战呢？当初的目的不就是想要西班牙获得发展与繁荣吗？眼下的一切不就是我们想要的东西吗？
这个故事的另一个启示是，西班牙后来成功的民主转型可能与佛朗哥威权统治下的经济发展成就有关。我
这种发展型威权主义，固然是一种威权统治，但它在威权统治之下能够实现经济的发展、现代化程度的提高、文化教育的进步等。实际上，不仅是西班牙，智利、韩国等也都经历了这样的发展型威权主义阶段。
1975年，政治强人佛朗哥终于去世了
对拥有国王的西班牙来说，君主立宪加民主制度是唯一可能的政体选择。在
当有人想搞彻底的社会革命时，原本温和的中产阶级更有可能倒向保守派的怀抱。
有时，历史就像一个钟摆，在“左”“右”之间来回摆
尽管朴正熙是一个政治上的威权统治者，但他致力于发展韩国经济和推动韩国现代化，其统治时期就出现了韩国经济高速增长的“汉江奇迹”。
一旦启动了初步的工业化，如果不是外部力量加以阻止，这个国家不太可能再重新回到农业社会了。在此过程中，这样的国家通常也会获得自我学习的能力。
里根在信中说，美国不希望看到首尔发生流血事件。他还明确表示，如果韩国发生流血事件，美国此后将无法保证韩国的安全。
实际上，美国国会又在1987年通过一项决议，敦促韩国加速推进民主化与和平转型。所以，在韩国民主转型过程中，美国扮演着重要角色。
俄罗斯是这样一个案例——从启动民主转型，到转型受挫，再过渡到某种夹杂着民主与威权色彩的两不像政体。
戈尔巴乔夫始料未及的是，苏联一旦放弃以中央控制为主要特征的威权体制后，竟然要维系国家的统一也不太容易了。
另外，戈尔巴乔夫的另一个战略盲区是他忽视了改革次序的重要性。
加盟共和国的地方选举一旦完成，地方加盟共和国政治领导人的合法性甚至就超越了当时苏联的政治领导人，因为后者的合法性仍然来源于旧体制，而这种旧体制恰恰是要被戈尔巴乔夫新的改革所抛弃的。
按照俄罗斯宪法，总统不得连任两届以上。按理说，普京从2000年到2004年、再到2008年连任两届总统以后，就不能再连任了。但是，俄罗斯宪法没有规定的是，一个人连任两届之后，若隔空一届，还能否继续竞选总统？所以，普京就利用这一政治空间进行了新的政治谋划。
普京总统又回来了！实际上，普京从未离开！不仅如此，普京还促使国家杜马通过了宪法修正案，将新的总统任期从4年延长至6年。
我们应该超越民主好还是坏这样的一些观念问题，而更应该深入到民主运作的经验世界里去考察，为什么有的国家政体转型会成功，而俄罗斯政体转型会遭遇挫败？这是一个不容易回答的问题。
6.3 威权政体的困境、复兴与前景 今天全球威权政体或多或少都面临着一个基本问题，那就是合法性的困境。证明这种困境存在的标志就是，绝大多数威权政体都不会公开声称本国就是威权政体或非民主政体。
几乎所有国家都号称是民主国家，几乎所有政党都号称是民主政党，几乎所有领导人都号称是民主派领导人。
一个视角是威权政体的价值取向非常重要。
一是发展导向，二是掠夺导向。
一种常见的情形是，一个军人统治者把自己的家族成员、同学战友都提拔为高官，形成一个以军事独裁者为核心的高层统治集团。这个统治集团其实是一个分赃集团，他们通过榨取税收、控制石油或贵金属资源、贪污受贿等手段攫取巨额的个人与家族财富，同时把数亿、数十亿美元放在瑞士银行的秘密账户中。这样的威权政体基本上是掠夺型的。
总体而言，当时韩国的官僚体系表现尚好，官僚集团将致力于实现韩国工业化和现代化视为主要目标。这样的威权政体，同时也是一个发展型国家或发展型政府。
有些威权政体具有强烈的发展导向，治理绩效相对优良，少数国家甚至拥有傲人的发展成就；
第二个视角是威权政体往往会面临多层委托代理关系的困境。
威权政体的有效运转，高度依赖于最高层给整个官僚系统所施加的压力与动力。
因为一旦官员私利主宰官僚体系，威权体制的统治效能就会面临不断削弱的危险。
由此可以推论，与小规模的威权国家相比，大规模的威权国家的治理难度会更高。
第三个视角是如何理解威权政体下重大政治决定或公共政策的风险。
从逻辑上讲，在威权政体下，一个重大政治决定或一项重大公共政策更有可能在未经充分讨论、没有听取各利益相关方和专业人士意见的条件下就被决定了。这样，如果没有经过正常的议会立法流程——包括议会三读、反对派质询和议会辩论，一个重大政治决定或公共政策就出台，其犯错的可能性当然更高。
跟民主政体相比，威权政体下一旦发生决策失误，要进行纠错的成本往往更高，因为这种体制下缺少常规化的纠错机制。
大饥荒通常发生在威权政体之下，而不会发生在民主政体之下，其中的原因也跟威权政体的信息机制和纠错机制有关。[插图]所以，一个威权国家在重大项目上产生决策错误的话，其结果可能是灾难性的。
如今全球媒体的潮流似乎是更强调民主政体决策的民粹化风险，而认为威权政体决策更接近某种程度的“贤能政治”。这一点确实有些出人意料，这种观点显然未能恰当地评估威权政体决策的巨大风险
很多愚蠢的乃至灾难性的重大决策都是威权体制下少数领导人刚愎自用、一意孤行的产物。
第四个视角是威权政体往往需要付出更高的维护稳定成本。这里所谓的维稳成本，既有直接成本，也有间接成本。
威权体制通常还会禁止某些外部思想或信息的输入，甚至需要建立一个更封闭的经济、政治与信息体系。这种做法有时看起来不过是维护体制稳定的权宜之计，但其长期后果可能非常严重，有可能阻碍一个国家的经济增长、科学进步、产业升级与整体创新能力。
最后一个视角是威权政体下的领导人风险。按
在民主政体下，蛊惑人心的野心家有可能借助民粹主义力量执掌大权。这种蛊惑人心的野心家执掌大权以后，可能会对整个城邦产生重大的祸害。尽
威权政体下面临的政治领导人风险还在于，一旦一个人执掌大权以后，倘若无法胜任，往往会比民主政体下的政治领导人不胜任产生更大的破坏力。
从军政关系的角度讲，新总统也很难完全按照自己的规则去控制军方，因为军队首先效忠的是国家和宪法。
样，即便是一个不称职的领导人，其可能的危害会被控制在有限的范围之内。
与民主政体相比，威权体制下领导人的个人因素会对整个国家产生更大的或好或坏的影响。
在人类全球化和民主化的大背景下，有些威权政体竟然获得相当的适应能力和学习能力，而不是像过去学界预测的那样，威权政体注定要快速走向僵化，甚至崩溃。
这种现象，被称为威权弹性或威权韧性。
独裁者能够通过学习，不断地获得维系自身生存所需的各种技艺。
威权政体复兴的一个典型现象是发展型威权大国的崛起，这种崛起造成了巨大的全球性影响。
一是会改变国际体系中政治势力的对比，民主力量与威权力量的格局有可能发生新的调整。二是可能会让西方发达民主国家的政治影响力受到遏制。
三是可能会树立新的全球榜样和造成新的示范效应，这一点对于发展中世界的其他小国影响尤甚
对亚洲、非洲的很多国家或拉丁美洲某些民主并不稳固的国家而言，发展型威权大国的崛起创造了某种极具榜样力量的发展奇迹，也可能会成为这些国家争相学习仿效的对象。
实际上，民主政体的表现越是逊色，强人政治或新的威权政治就越有可能复兴。
这里涉及两个不同的问题：一是威权政体本身的未来，二是目前为止的威权国家的未来，两者的命运并不完全相同。
第一种是封闭型维稳战略。
第二种是发展型吸纳战略或开放型吸纳战略。
这种威权体制的战略，总体上是发展导向的，同时要有效吸纳新兴力量。
当这种威权政体一旦不再能吸纳新兴的社会力量时，就会遇到已经成长起来的社会力量的挑战。从经验来看，一个社会越发展，越是跟国际接轨，这方面的挑战就会越大。
第三种是可能的中间道路。
在不同方面实施不同策略的组合。
一个威权政体要精确计算到底哪里要实施封闭型维稳政策，哪里要实施发展型吸纳政策，这往往存在着很大的困难。
从历史经验来看，对任何一个国家来说，停滞型威权主义几乎都是最糟糕的一种治理方式；但如果是发展型威权主义，若能放宽历史的视野，这也许不是一种可以全盘否定的统治形态。
从历史进化和横向比较来看，发展型威权主义或许有其独特的价值。一方面，在发展型威权主义之下，一国的经济社会现代化程度往往会得到有效提升，而这个过程是不可逆的；另一方面，这样的威权政体往往也有助于提高该国后续转型的成功率。
其次，我们还可以思考与评估不同威权国家民主转型的可能性。
最后，值得提醒的是，考察威权国家的政治前景，不仅要有短期的视角，而且要有长期的视角。</description>
    </item>
    
    <item>
      <title>重读20世纪中国小说</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E9%87%8D%E8%AF%BB20%E4%B8%96%E7%BA%AA%E4%B8%AD%E5%9B%BD%E5%B0%8F%E8%AF%B4/</link>
      <pubDate>Wed, 28 Sep 2022 14:58:43 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E9%87%8D%E8%AF%BB20%E4%B8%96%E7%BA%AA%E4%B8%AD%E5%9B%BD%E5%B0%8F%E8%AF%B4/</guid>
      <description>许子东
1918 鲁迅《狂人日记》《药》《阿Q正传》 “五四”新文学，到底“新”在哪里？ “五四”与晚清文学的关键性区别在哪里？
梁启超和晚清谴责小说不约而同地把官场（“官本位”）视为中国社会问题的焦点。李伯元冷嘲“上上下下，无官不贪”，“不要钱的官员，说书人说实话一个都没见过”。
曾朴写即使考出来的文官，有心救国，却也好心办蠢事（重金购买假地图）。刘鹗笔下的贪官不好，清官更甚。
如果不是批判，梁启超幻想中国他日富强，关键要素也还是依靠一个党、一个领袖，说到底还是期盼官员救国，并以治国之法治党，改造官场。
中国一向是专制政体，普天下的百姓都是怕官的……中国的官，大大小小，何止几千百个；至于他们的坏处，很像是一个先生教出来的…
鲁迅关心的重点不只是“官”，也不只是“民”（把“人民”作为中心是50年代以后的事情），要点就是“人”。文学的焦点从“官本位”转向“国民性”，这是“五四”与晚清的关键区别。
如果老残说得有理，贪官不好，清官亦坏，那即使把所有的官都撤了，换一批民众百姓上去，但也还会有贪腐、专制？
按照钱理群的概括，“民族危机在于文化危机，文化危机在于‘人心’的危机，民族‘精神’的危机：……亡国先亡人，亡人先亡心，救国必先救人，救人必先救心，‘第一要着’在‘改变’人与民族的‘精神’。”
民族危机在于文化危机，文化危机在于‘人心’的危机，民族‘精神’的危机：……亡国先亡人，亡人先亡心，救国必先救人，救人必先救心
革命以前，我是做奴隶，革命以后不多久，就受了奴隶的骗，变成他们的奴隶了。
到底是贪腐专制官场导致了百姓愚昧奴性，还是百姓愚昧奴性造就了官场的贪腐专制？
他们关心的焦点已不再只是中国的官场，而是中国的人，具体说就是人的文学，就是解剖国民性。
可是今天再想，第一，中国的问题，关键到底是在官场，还是在民众，还是在“人”呢？第二，文学是否一定要（或者说有没有可能）解答中国的问题？
晚清文学处理的“官本位”问题在中国果然已经不再重要了吗？
官民相通之处：欺软怕硬，自欺欺人。
不仅骂主子，也怨奴才，要挑战整个主奴关系秩序。
显然，结果就是得罪所有人，众人都过来围观、嘲笑，连小孩也表示鄙视，甚至家人也要可怜、禁锢这个病人——于是《狂人日记》就出现了。
你说大家都病了，结果大家为了证明自己没病，一定说是你病了，而且最后真的把你医好了，也就是说你必须跟大家一起病下去——鲁迅的深刻，就像下棋比其他人多想了好几步、好几个层次。
看到自己被看，有两种可能，一是神经过敏，被迫害妄想，这是小说的写实层面，从医生角度解剖病人。二是思维敏捷，看穿别人的好奇、关心、照顾后面，其实是窥探、干涉与管制，这也是写实，但可以是象征。
“独异”与“庸众“
很多人围观一个人，这是鲁迅小说后来反复出现的基本格局。
20世纪中国小说只有“五四”这个时期，只有在鲁迅等少数作家笔下，才会出现以少数甚至个别对抗多数的场面。
“个人的自大”，就是独异，是对庸众宣战。……而“合群的自大”，“爱国的自大”，是党同伐异，是对少数的天才宣战……
鲁迅为什么支持个人独异，来批判庸众（今天叫“吃瓜群众”）？一是强调“个人的自大”“少数的天才”愤世嫉俗的价值，二是狂人知道围观他的众人，并不是官府爪牙，“他们——也有给知县打枷过的，也有给绅士掌过嘴的，也有衙役占了他妻子的，也有老子娘被债主逼死的
这些包围他迫害他的人们，本身也是被侮辱、被损害者，他们不是主子，也是奴隶，可他们却帮着官场迫害精神独异者，这使鲁迅十分困惑。只是批判官场，庸众怎么办？
从“看”与“被看”的情节、“独异”与“庸众”的格局，自然引出更严重的主题：“吃人”与“被吃”。
吃人主题更深一步，就是狂人怀疑自己是否也吃过人，被吃的人也参与吃人。
看到社会环境腐败，官场在危害百姓，导致民不聊生，这是晚清四大名著的共识。看到不仅官府富人，而且自身被欺的庸众看客，也是这黑暗中国的一个有机部分，这是“五四”文学的发现。但是看到害怕被吃的人们，甚至大胆反抗的狂人，可能自己也曾有意、无意参与过吃人，这是鲁迅独特的忏悔意识。
一个短篇这么多不同层次，这么复杂的容量，一起步，就把现代新文学提高到很高的水平，难怪后来几乎成为鲁迅创作的大纲，在某种意义上，《狂人日记》也是整个现代中国文学的总纲。
以文学诊断社会的病，希望提供某种药物使中国富强，这是鲁迅小说的愿望，某种程度上，也是20世纪中国小说的集体愿望。
鲁迅的创作，当然跟他的衰落家境、少年经历、留学日本、教育部做官等个人经验有关，这些经验中的关键词就是“屈辱”。
这些屈辱又常常和医和药有关。
两个日后的文豪，在百草园里翻石头并且分头追逐各奔东西的蟋蟀，谁知道它们到底是正宗夫妻，还是小三，或者一夜情？
给父亲买药，是说得出的屈辱；被亲戚乡邻污蔑，说买药时偷家里钱，则是说不出的侮辱，连母亲都无法帮他洗清。
碰到这种事情，周树人不吵，而是忍，但绝不忘却。国事私事都不忘，持久的反省，持久的恨。
这何尝不是在被人吃的情况下也参与吃人呢？鲁迅常常说，他没有对读者说出他全部的真话。鲁迅的真诚就在于他承认自己不真诚。
即使弃医从文，他以自己创作来诊断医治中国社会的病，希望有某种“药物”使中国富强。
第一是官府，县老爷不必出场；第二是帮凶康大叔；第三是茶馆众人，花白胡子、驼背五少爷，还有一个20多岁的人等，议论纷纷；第四是华老栓、华大妈、华小栓——普通被害者；第五就是造反派革命党夏瑜，以及他的家人夏四奶奶。
第一层基本病因，官府镇压革命党，大家都知道。第二层并发症，帮凶卖烈士鲜血给民众，反而送了小栓的命。这个次生灾难，二、三、四层的人们都看不见，施害者与受害者都不知道救命药变成了杀人凶器。更吊诡的是，凶器既是旧社会药方，又直接来自革命者身体。客观上，如果二、三、四阶层的人继续愚昧，第五类人的革命，反而加重病情。再神奇的药也是毒药。
当时人们想，针对晚清的病，需要“五四”的药。百年之后人们又要反思，如果晚清的病一直不能断根，是因为“五四”的方子也不行？还是因为没有始终坚持用“五四”的药？
困难和矛盾主要在这里：阿Q是一个农民，但阿Q精神却是一个消极的可耻的现象。
因为阿Q是农民，因此是好的。阿Q精神却是坏的，应该属于当时官员和官场。
阿Q主义是封建统治阶级的东西，它寄居在阿Q身上。
今天你是弱势民众，万一明天做官，会不会重犯官场毛病？
一是造反者一旦胜利，首先要对付的不是宿敌，而是身边的同类；二是造反者要剥夺权贵的财富自己享用；三是造反者要驱使指挥自己的奴才；四是对权贵财富（比如女人）也要选择精华，不能全盘接受。
阿Q土谷祠里的梦“是鲁迅对于刚刚觉醒的农民的心理的典型的表现”。
虽然混杂着农民的、原始的报复性，但他终究认识到革命是暴动，毫不迟移地要把地主的私有财产变为农民的私有财产”，并且“破坏了统治了农民几千年的地主阶级的秩序和‘尊严’”，这都是表现了“本质上是农民革命的思想”。
资产阶级再也不能领导中国革命了。
在鲁迅笔下，奴隶至少有三层定义。第一，清代的臣民，
倘在平时，钱铺子如果少给我一个铜圆，我是决不答应的。但我当一包现银塞在怀中，沉垫垫地觉得安心，喜欢的时候，却突然起了另一思想，就是：我们极容易变成奴隶，而且变了之后，还万分喜欢。
原来属于你的东西，比如房子、金钱、趣味、说话权利等，所有这些东西是属于你的，但随时可以被剥夺。剥夺了以后还剩一点，撤回一点，你就十分欢喜。这是鲁迅对奴隶的第二层，也是比较经典的定义。
一个活人，当然是总想活下去的，就是真正老牌的奴隶，也还在打熬着要活下去。然而自己明知道是奴隶，打熬着，并且不平着，挣扎着，一面‘意图’挣脱以至实行挣脱的，即使暂时失败，还是套上了镣铐罢，他却不过是单单的奴隶。
鲁迅对奴隶的第三层定义，你是熬着、吃苦，但是你心里觉得不平、挣扎。
如果从奴隶生活中寻出‘美’来，赞叹，抚摩，陶醉，那可简直是万劫不复的奴才了！他使自己和别人永远安住于这生活。
”起来，不愿做奴隶的人们”
起来，饥寒交迫的奴隶
在鲁迅的笔下，奴隶是生态，奴才是心态，奴隶是被动的，奴才某种程度上是主动的。
第一，要在奴隶生活当中寻找到乐趣、赞叹、抚摩、陶醉。第二，不仅被比自己强的人欺负，也会欺负比自己弱的人，就是见狼显羊相，见羊显狼相。第三，起来以后，也希望做主子，也要有自己的奴才。
第一，精神胜利法，初衷是变态地消解屈辱（老被欺负怎么活下去呢），结果却是可以找到乐趣。
原来人类历史上这些示众、游街、剃光头、剥衣服，让人们吐口水、扔鸡蛋（过去在街上扔，如今在网络上）……基本功能还是让吃瓜群众找到奴才乐趣。
被人欺负者，也欺负他人。人人负我，我亦负人人。
鲁迅写阿Q，不仅“哀其不幸，怒其不争”，而且“哀其被欺，怒其欺人”。
曾有人对鲁迅说，说在街上看到两种国人，一种像狼，一种似羊。鲁迅说，你看到的其实是一种，他只是在变。
要点是先杀同一阶级的弱者，然后才找官场老爷报仇。但又贪富家大床，又要小D去搬。村里女人，包括人妻，全部意淫一遍。
《阿Q正传》既描画国民性，又预言了中国革命。一部中篇小说交叉了20世纪中国小说的两个基本主题，所以百年来，学术界数不尽的阿Q研究，现实中也是看不完的阿Q风景。
当然，注意到国民性问题是一回事，能否改造国民性又是另一回事。</description>
    </item>
    
    <item>
      <title>中国国家治理的制度逻辑：一个组织学研究</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%B2%BB%E7%90%86%E7%9A%84%E5%88%B6%E5%BA%A6%E9%80%BB%E8%BE%91%E4%B8%80%E4%B8%AA%E7%BB%84%E7%BB%87%E5%AD%A6%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 28 Sep 2022 14:50:49 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%B2%BB%E7%90%86%E7%9A%84%E5%88%B6%E5%BA%A6%E9%80%BB%E8%BE%91%E4%B8%80%E4%B8%AA%E7%BB%84%E7%BB%87%E5%AD%A6%E7%A0%94%E7%A9%B6/</guid>
      <description>周雪光
第1章 导论：中国国家治理的制度逻辑 ［科学技术革命］为什么发生在欧洲和西方？为什么不是在中国？
中国独一无二的命运是，在其他古代文明消亡以后很久，中国的文明坚持了下来；这种坚持所包含的意义不是僵化，而是一系列的再生。
在21世纪，中国是这个世界上唯一一个将前19世纪的幅员、人口和政治文化保持在主权国家和民族范畴内部的社会。
（1）与其他古老文明相比，为什么中国文明有机体可以在历史上生存如此之久？（2）为什么中国在历史上有一度辉煌的文明历程，又有长期停滞徘徊的经历？（3）为什么中国社会在近几十年里突然迸发出巨大的活力？
宏观上，中央与地方关系在集权与放权的抉择中轮番交替，自上而下的运动式治理整顿在不同领域中重复出现，林林总总的政治教育运动绵延不断，法律制度、理性官僚制度的发展举步维艰。
它们背后是否存在着一个稳定共享的制度逻辑？在这些纷杂不一的现象背后是否隐藏着中国国家运行和中国大历史演变的深层密码？
这些密码是不是有助于我们进一步认识中国文明的绵延进程和未来走向？
一个国家的运行过程、解决问题的能力与方式、应对危机的抉择、中央与地方政府间关系、国家与社会的关系，都是建立在一系列制度设施之上的。
我的研究策略是，从现实出发，从微观着眼，以近距离的田野观察为素材，进一步思考理解这些现象背后的内在联系和机制，由微观及于宏观，由现实观察及于历史过程，由中国场景及于比较视野，进而寻找解读国家治理深层密码的线索。
中国政体的突出特点是以中央政府为中心的一统体制，即中央政府对其广大国土及居住其上的民众、各个领域和方面有着最高和最终的决定权。
中国国家治理的一个深刻矛盾是一统体制与有效治理之间的矛盾，集中表现在中央管辖权与地方治理权间的紧张和不兼容：前者趋于权力、资源向上集中，从而削弱了地方政府解决实际问题的能力，即这一体制的有效治理能力；而后者又常常表现为各行其是、偏离失控，对一统体制的中央核心产生威胁。
统体制中，这一矛盾无法得到根本解决，只能在动态中寻找某种暂时的平衡点。
一统体制有着两个基本维系机制——官僚体制和一统观念制度。
在当代社会，这两个机制受到了多重挑战：官僚组织承担了越来越多的治理功能，不堪重负；一统观念制度受到多元社会的碰撞挑战，难以为继。
系列应对机制应运而生：（1）决策一统性与执行灵活性以及逐级代理制的动态平衡，（2）政治教化的礼仪化，以及（3）运动式治理的“纠偏”机制。
虽然这一系列机制缓和了一统体制与有效治理之间的矛盾，但它们与现代国家制度建设不兼容甚至冲突，衍生了其他始料未及的后果，因此潜伏着极大的危机。
，国家建设在集权与放权、名与实、“失控”与“纠偏”的两个极端之间摇摆转换，对已经负荷累累的一统体制造成不断的冲击振动；稍有不慎，则可能酿成局势动荡。第二，这一体制的制度逻辑限制了制度创新和可能抉择的空间，使得依法治国、官僚理性、专业化过程难以充分展开，只能畸形生长，为中国未来的发展前景投下更大的不确定性阴影。
一统体制与有效治理：中国国家治理的一个深刻矛盾 任何一个国家政权都面临着竞争生存的压力，面临着所属疆域内经济与社会发展的挑战。不同国家因其面临生态环境、统辖规模和治理模式的差异，所面临的困难和挑战也每每不同。
国家治理模式不是任意选择的，常常与一个国家的历史演变过程有着深刻关系，有明显的途径依赖性（
中文中的“国家”概念有着“民族”（nation）与“国家政权”（state）的双重含义。
国家治理模式有两个主要线索：一是中央权威与地方权力间关系，一是国家与民众间关系。
中国历史上国家政权的基本特点是中央权威一统而治，即所谓“溥天之下，莫非王土；率土之滨，莫非王臣”
在这一特定的国家治理模式下，一统体制将中央政府与辽阔的国土、漫长的疆土边界、不平衡发展的区域、多样的文化制度、数以亿万计民众的生计，以及各种自然、人为的灾害和危机紧密地联系在一起了。
在民族平等、公民权利和人民国家的合法性宣称之下，现代国家在‘革命’‘解放’和‘合法权利’等名义下将个人重新组织到国家主导的集体体制之中，从而赋予现代国家对于个人的更为直接的控制权”
国家治理面临的一个重要挑战是其治理规模以及由此产生的治理负荷。
学者经常引用评价不同国家的治理模式，如新加坡模式、日本模式等等。这些讨论大多忽略了一个重要的维度，即国家治理的规模 。
从国家内部社会生活的组织过程来看，国家政权不能持久地建立在强权统治或高压政治之上，而需要得到民众的认可和服从；为此，国家通过各种整合机制和制度安排来完成这一使命。
国家规模在经济发展、国家稳定和国民福利诸方面的优势和劣势。
大国因内部群体和文化差异性在内部整合上要付出更多的代价；但国家规模提供了市场规模，因此大国有利于经济增长，有利于降低那些必需公共品（如国防）的固定成本。
组织成员因其特定角色和位置，有着各自的私有信息，必然以此寻租，而“寻租是一个官僚组织运行必不可缺的润滑剂”
第2章 国家治理逻辑与中国官僚制：一个韦伯理论视角 任何权力……都有为自己之正当性辩护的必要。
中国官僚体制为国家治理提供了稳定的组织基础和微观过程。
对于今天的民众百姓来说，日常生活中无所不在的官僚制组织即是国家。
国家治理的诸多机制大多是在“用”官僚机器以实施其意图又不得不“治”官僚体制偏离其意图这一矛盾中产生的。
从理论分析上将执掌最高权力的“国家”（或皇权）与“政府”（官僚体制）区别开来，
我的研究出发点是，官僚体制作为一个特定的组织形态，其运作过程和行为方式有其内在机制，是可以分析的。
“君主官僚制”的延续与转型：当代中国官僚体制分析 居于最高权力地位的执政党及其领袖与其下的官僚组织区分开来。
国家权力与官僚权力。
在各类施政文件中，前者常常以“党和国家”的形象出现，而后者则以“各级干部”和“基层干部”概而言之
毛泽东对官僚体制的反复批评指责和党内外频繁的整党整风运动都表明，体现最高意志的“国家”和具体操作的官僚体制之间在实际运行过程中的确存在着经常性紧张。
当代中国国家支配形式是怎样的？官僚体制在这个支配形式中是怎样的位置？
当代中国国家的合法性建立在以法理权威为表、但更多地表现出卡理斯玛权威为实的混合型基础之上。
在当代中国，这一混合型基础中的两种权威未及交融熨合，法理权威根基肤浅而卡理斯玛权威强势以行，后者的意志几欲冲破前者的羁绊；这些紧张一直存在，暗流涌动，并时常以极端形式爆发而出。
中华帝国的双重合法性即传统权威和卡理斯玛权威都受到质疑和深刻撼动，特别是皇权继承的传统合法性不复存在。
民主宪政的法理权威已经成为20世纪现代国家不争的合法性基础。
在一个经历了数千年君主官僚制、浸濡于儒教文化中的传统中国社会，法理权威并没有真正植根，所以，在国家运行的实际过程中，执政党并不是将其执政合法性基础建立在法理权威之上。
中国历史上皇权的另一个合法性基础——卡理斯玛权威——以新的形式成为执政党的实质性权力依据，执政党的种种做法的确是在倾注精力来塑造卡理斯玛权威。
卡理斯玛权威的核心是，领袖以其超凡禀赋而得到追随者的拥戴和服从；而领袖则通过不断地创造“奇迹”来显示其超凡禀赋，以延续和强化这一合法性基础。
毛泽东的卡理斯玛权威已经崭露头角（韩金铃2007，高华2000）；随后经过艰苦卓绝的军事斗争，从小到大，在出乎意料的短时间里夺取政权。在建国前后以摧枯拉朽的气势夺取政权、平定时局。
卡理斯玛权威需要用政绩（即韦伯意义上的“奇迹”）来证明它的超凡禀赋，这也体现在毛泽东在建国后通过“国家运动”在经济上激进发展的一系列做法（冯仕政2011）。建国初期的抗美援朝战争，国内经济的迅速恢复和发展，社会主义公有体制的建立，这些做法的功过是非世人仍争论不已，但有一点可以肯定，即这一切摆脱了近代以来中国积弱贫困、列强鱼肉的经历，的确是中国共产党的辉煌成就。
用韦伯的观点来看，中国1949—1976年间的国家当属原初意义上的卡理斯玛权威”
卡理斯玛权威的一个重要渊源是“追随者”的认可和服从，这也是中国共产党的鲜明特点。
一方面，卡理斯玛权威可以有效地动员群众来投入到政治、经济和社会诸方面的建设过程中，另一方面，群众运动又持续强化了群众与领袖间的关系。这一卡理斯玛权威在“文革”中达到了登峰造极的地步。
我们或许应该将‘文化大革命’运动的参加者称为‘理性的真正信徒’，原因是他们确实将毛泽东视为‘具有超自然能力的天生奇人，或者至少是天赋异禀的人’，他们愿意全身心投入到毛的事业中，而不管这个事业是什么样的事业
卡理斯玛权威有着内在的不稳定性和延续的困难，因此可能会经历一个“常规化”（routinization）的过程，即将超凡禀赋领袖的个人魅力转而移植到稳定的组织设施上，使得这些组织设施具有卡理斯玛权威的禀性，涂上“神圣化”的色彩。
中国共产党光荣的革命史、工人阶级先锋队的称谓，都放射出这种超凡禀赋的光芒，而其领袖毛泽东则更是这一权威的化身。
卡理斯玛支配事实上已与其他结构原则密不可分地结合在一起，而变成只是经验的历史图像里的一个成分，这种往往已面貌模糊、难以辨识的变形，也唯有在理论的观察下才能解析得出来
实质上的卡理斯玛权威在形式上与法理权威融为一体，成为当代中国的支配形式。﻿
在中国，作为最高权力中心的党与官僚体制之间仍然是主从关系。换言之，虽然国家支配形式已更替，但其官僚体制的结构位置一如中国历史上的官僚体制，其合法性仍然源于自上而下的授权，仍然体现在“向上负责制”的一系列制度安排之上，但国家与官僚体制间的主从关系有了新的演变。
首先，国家凌驾官僚体制的权威关系更为强化。
在当代中国，新的国家支配形式摒弃了传统权威及其与之俱来的政治文化，这些制度性约束也随着传统权威合法性一并消失了。
与帝国的文人官员进可“学而优则仕”退可“采菊东篱下”不同，在当代中国官僚体制中，官员身处职业生涯阶梯之上，骘罚臧否，全面覆盖，而且只能在政府内部封闭、狭窄的人事“市场”中流动，几无“退出”渠道。</description>
    </item>
    
    <item>
      <title>中国的当下与未来：读懂我们的现实处境与30年大趋势</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%BD%93%E4%B8%8B%E4%B8%8E%E6%9C%AA%E6%9D%A5%E8%AF%BB%E6%87%82%E6%88%91%E4%BB%AC%E7%9A%84%E7%8E%B0%E5%AE%9E%E5%A4%84%E5%A2%83%E4%B8%8E30%E5%B9%B4%E5%A4%A7%E8%B6%8B%E5%8A%BF/</link>
      <pubDate>Wed, 28 Sep 2022 14:50:49 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%BD%93%E4%B8%8B%E4%B8%8E%E6%9C%AA%E6%9D%A5%E8%AF%BB%E6%87%82%E6%88%91%E4%BB%AC%E7%9A%84%E7%8E%B0%E5%AE%9E%E5%A4%84%E5%A2%83%E4%B8%8E30%E5%B9%B4%E5%A4%A7%E8%B6%8B%E5%8A%BF/</guid>
      <description>郑永年
中国目前改革面临的结构性挑战 总体上说，尽管各个部门、组织和单位的改革声音很大，但实际层面进展不够大。
在这一体制下，政府的权力行使受党的领导。
从理论上说，社会（或者人民）是党权的最终来源，这也是中国政府的合法性基础。
但就决策本身来说，权力集中也产生了一些问题，主要表现在决策的科学性上。
中国改革到今天，并不缺改革，改革的广度有了，所缺少的是深度和力度。
往往一个政策还没有被理解消化，另一个政策就下来了；一个政策还没有被执行，更多的政策便接踵而至。
如果监察权没有节制，执行权就会受更多的制约，甚至被废掉。
中国体制改革向何处去？ 任何官僚结构都有自我扩张的本能。
尽管人们不喜欢“党国”的概念，但党国一体是个事实。
其实中共十八大以后，党的权力很快进入了社会经济事务领域，而国务院负责事务的范围被削减。党负责所有领域的重大决策，政府只负责决策执行。
第一，“以党领政”很容易演变成党的机构无限扩张。
第二，“以党领政”也很容易演变成“以党代政”。
既然所有权力都来自党权，地方有必要设立党政两套体系吗？两套班子干的是同样的事情，两者之间的互动更多地表现为互相牵制和内耗，大大降低了行政效率。
越到基层，就会有越多的机构只是因上级需要而存在。就基层本身而言，这些机构实在没有任何存在的理由。
第五，挤占社会空间，造成弱国家、弱社会现象。
一个什么都管，但什么都管不好的政党（政府），必然是一个弱政党（政府）；一个什么都不会自治而必须依赖政党（政府）的社会，必然是一个弱社会。
生存与征服：中西方两种哲学及其结果 中国的思想往往产生于危机时刻，无论是由内部因素还是由外部因素所致。
佛教的传入对本土文化构成了巨大的危机，以至于在很长历史里发生了“灭佛”运动，但也提供了一个机会，整合之后，儒释道并存，大大丰富了中国的思想。此后，不管是什么样的危机也没有产生深刻的哲学思想。
无论如何，在各种深刻危机下产生的哲学，其主体思想便是求生存，可说是“生存哲学”。
可惜，自从汉代儒学被立为官方的统治哲学之后，所有思想要么被罢黜，要么被儒化了，即道德化和人化。人们也可以把这种中国哲学称为“生活哲学”。
西方哲学的主体是征服，可以说是征服哲学。这里既包括人们对自然界的思考，也包括对人类社会的思考，也就是说，无论是自然还是人类社会，都是西方哲学需要征服的对象。
秦始皇统一中国之后，中国哲人们的眼光和思考似乎从来没有离开过人事，主要是五伦，包括君臣、父子、夫妻、兄弟和朋友。
“仰望星空”就是探索宇宙、自然、人类社会等是如何形成、运作、变化的，即马克思所说的“解释世界”，其目的是如何征服它们，即马克思所说的“改造世界”。
西方形成了自然法，中国则是社会自然法；前者关切的是普遍性，后者关切的是特殊性；前者关切的是统治世界，后者关切的是自我生存。
中国的四大发明除了对日常生活有所改进之外，基本上对中国日后的发展没有什么巨大的贡献，但却促成了西方人对世界的征服。
印刷术、火药、指南针这三种发明，已经在世界范围内把事物的全部面貌和情况都改变了：第一种是在学术方面，第二种是在战事方面，第三种是在航行方面；并由此又引起难以数计的变化：竟至任何教派、任何帝国、任何星辰对人类事务的影响都无过于这些机械性的发现了。
火药、指南针、印刷术——这是预告资产阶级社会到来的三大发明。火药把骑士阶层炸得粉碎，指南针打开了世界市场并建立了殖民地，而印刷术则变成了新教的工具，总的来说变成了科学复兴的手段，变成对精神发展创造必要前提的最强大的杠杆。
火药和指南针的整合为西方塑造了无比强大的西方海军，促成了西方殖民主义和帝国主义。
造纸术和印刷术的结合为西方社会创造了“想象共同体”（imagined communities），即民族的概念，而想象共同体的产生是西方近代民族国家中最为关键的，是近代以来西方征服世界的内部制度基础。
第一，日本和韩国原创性的技术也不是很多，它们精于应用，并在应用的基础之上有很大的改进，制造出来的产品甚至超越西方。第二，这些国家在二战后基本上采用了西方的制度，尤其是科研制度方面。主要政治精英都是接受西方教育，形成了西方的思维方式。
中国也专于应用，但是中国缺失日本人和韩国人所具有的工匠精神。
这方面，今天的情况也没有根本性的变化。人们一直在呼唤工匠精神，但在缺失文化和制度环境的情况下，工匠精神很难产生。
早期，西方世界所使用的就是最原始意义上的征服，即实行赤裸裸的殖民地和帝国主义政策。二战以来，西方主要通过世界规则的制定来统治世界。他们把自己的观点打造成“普遍适用的观念”，再把它转化成为普遍规则，在全世界扩张、推行。西方的使命感文化最初来自宗教（基督教文化），但近代以来演变成政治价值和意识形态，成为各国争相征服世界的工具。
哈佛大学教授费正清曾经提出过“冲击——回应”模式，来解释中国近代以来的现代化。也就是说，中国一直处于回应由西方的崛起而产生和强加的挑战状态。这个概念可以解释直到今天为止的中国生存哲学。
中国的BAT（百度、阿里巴巴、腾讯）无一不是以生活为中心，甚至是核心的。在西方，互联网公司被称为高科技公司，因为它们都在研发高科技。但在中国，在很大程度上说，互联网公司与其说是高科技公司，倒不如说是高科技应用公司。
在中国的互联网热衷于做外卖的时候，西方人已经用互联网走向了太空。
一句话，中国哲学从来没有超出求生存的水平；即使生存问题没有了，中国人也没有征服世界的念头，而转向了实在的生活。这种哲学的优势就是其和平性质。
对中国来说，如果生存哲学不变，其结果也是显然的，那就是继续缺少原创性技术，继续没有能力制定规则，继续当一个善于适应环境的好学生。
但如果生存哲学已经演变成为“基因”或者“血液”，那么人们只能接受命定论了。
中国近代以来的知识体系问题 中国的历史是静止的。
最大的分歧就在制度层面。不管怎样的社会，制度是其核心，因为制度是调节人与人、人与社会、人与自然的中介。
无论哪个社会，在理论与现实不相符合的时候，需要改变的是理论而非现实，因为现实，不管人们喜欢与否，是客观存在的。
名利场下的中国知识将向何处 政府从来不是知识的主体。
今天的知识悲歌的根源就在于现代知识人已经失去了“争智于孤”的局面，而纷纷加入了“争名于朝”或者“争利于市”，有些知识人甚至更为嚣张，要名利双收。
竞相通过和“朝廷”的关联来争名，这个现象随处可见。
古今中外的真正学者没有一个是争名争利的，有很多为了自己的知识尊严甚至付出了生命的代价。历史上，不乏知识人被权力和资本迫害的事例。近代以来才逐渐有了言论自由的保障。
因为国家的投入越多，名利场越大；名利场越大，知识人越是腐败。
当代中国人的处境和未来 民主，把权力交给人民。
中国很早就发展出了“养民”的概念，即把老百姓作为治理客体来对待。官方意识形态即儒家基本上是一种现实主义的统治哲学，即从人的特性来理解有效的权力行使。儒家对“民”的关切，其核心也是皇权，即避免皇权被“民”推翻，从而失去“天命”。
传统中国的这些制度安排并非是为了实现人的权利；相反，这些安排都是为了让人尽义务和责任，最终目标是为了皇权的统治。
中国在“以民为本”到“民反”之间缺少一系列制度安排，等到“民”忍无可忍的时候，就直接造反。
双方所争论的焦点并非中国需要不需要人权，因为中国也从来没有否认过人权；争论的焦点在于不同方面人权实现的优先次序问题，中国强调社会经济的发展权利，而西方强调的是政治权利。
一，中国没有经历过人的启蒙，类似于欧洲的文艺复兴，没有能够从人作为客体的人本主义，转型成为人作为主体的人本主义。
第二，受历史条件的限制，中国的启蒙运动过于强调国家的权利，而忽视甚至漠视个人的权利。
在重新强调现代化的今天，关键的是实现人的现代化，而人的现代化实现的起点，则是每一个人对他人权利的认同。
导出于 2022-09-28 14:50:49</description>
    </item>
    
    <item>
      <title>近代中国社会的新陈代谢</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E8%BF%91%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E7%9A%84%E6%96%B0%E9%99%88%E4%BB%A3%E8%B0%A2%E6%8F%92%E5%9B%BE%E6%9C%AC/</link>
      <pubDate>Wed, 28 Sep 2022 14:50:49 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E8%BF%91%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E7%9A%84%E6%96%B0%E9%99%88%E4%BB%A3%E8%B0%A2%E6%8F%92%E5%9B%BE%E6%9C%AC/</guid>
      <description>陈旭麓
第十七章 “揖美追欧，旧邦新造” “揖美追欧，旧邦新造”已由革命派的意向变成了中华民族的共同意向。
十八星代表那时中国的十八省；五色代表汉、满、蒙、回、藏五族共和；井字代表井田而引申为天下大同；金瓜钺斧代表尚武强兵的精神；三色代表自由、平等、博爱之义；白旗则代表以明涤去污染、光复旧物之旨。
武昌起义后产生的国歌和国旗，使中国第一次具备了一个近代国家应有的外观。
辛亥革命的两大历史功绩：一是革了皇帝的命，一是革了辫子的命。
1902年梁启超在《新史学》中说：“二十四史非史也，二十四姓之家谱也。”
作为人主，皇帝是世俗的权威；作为天子，皇帝是神圣的权威；作为君父，皇帝又是伦理的权威。一言以蔽之，朕即国家，朕即法律。皇帝高踞于权力金字塔的顶端。地方听命于中央，中央听命于皇帝。
皇帝君临天下，臣是他的奴仆，民则是他的奴隶。对于臣民来说，雷霆雨露皆天恩。臣民的一切都是皇帝赐予的，甚至连处死也称之为“赐死”，被杀还要“谢主龙恩”。皇帝本是圆颅方趾之属，却无人敢以圆颅方趾之属视之。他掌握着生杀予夺的大权，主宰着历代臣民命运的悲欢；他操纵一切权力又凌驾于一切人之上。所谓“天下之事无大小皆决于上”。
对君权的怀疑和批判是这一时期卓识之士共同思考的题目。
然而，易代之后，清王朝株连惨酷的文字狱又中断了这种思想，中国社会仍旧沿着皇权赓续的轨迹缓缓而行。
第十九章 新文化运动 革命成功将近十年，所希望的件件都落空，渐渐有点废然思返，觉得社会文化是整套的，要拿旧心理运用新制度，决计不可能，渐渐要求全人格的觉醒。
由辛亥革命所唤起的中国社会的希望，同民国初年中国社会的黑暗之间形成一种巨大的落差，巨大的落差产生了巨大的波潮，于是而有新文化运动。
橘逾淮为枳，在西方卓有成效的东西，到了中国却总是全然不成模样。其根由何在？
它以辛亥革命后的中国社会现实为认识起点，进而追溯到几千年历史凝结而成的文化传统，并对这种传统进行了总体性的理性批判。
孔子是中国传统小农社会的精神象征，是两千年来中国思想界的最大权威。
第二十章 历史的选择 “五四”以后，社会主义思潮成为新文化运动的主流。
在那个时候的中国，社会主义名号之下统括着马克思主义、无政府主义、工读主义、新村主义、基尔特主义、合作主义、泛劳动主义，主义与主义之间相去往往很远。
被民主和科学所唤起的成批激进民主主义者几乎在一夜之间纷纷成了社会主义者。
西方传来的社会主义思潮迅速地影响了“五四”前后涌出的一代出类拔萃之辈。这一事实有着深刻的社会原因。
其一，古有的大同理想成为一种现成的思想基础，沟通了中国人同社会主义学说之间的联系。
古已有之的大同思想并不等于近代社会主义，但它画出了一种没有争斗、互爱互助的境界。
“五四”前后的激进民主主义者们猛烈反对旧文化，但他们本身又多半是从旧文化中挣脱出来的人物。
“把自己的生活弄简单些，劳心也好，劳力也好，种菜也好，耕田也好，当小学教师也好，一日把八小时作些与人有益、与己有益的工活，那其余的功夫，都去作开发农村、改善农民生活的事业”
同近代社会主义各流派相比，原始大同理想又是空泛的。但正是这种空泛又提供了多方面理解社会主义的可能性。
那时，大家正在寻找国家的出路，追求真理，对社会主义还没有明确的认识。研究会的几十个会员中，除部分相信马克思主义以外，有的相信基尔特社会主义，有的相信无政府主义。
资本主义生产制一面固然增加富力，一面却也增加贫乏。
能开发其生产力则富，不能开发其生产力则贫。从前为清政府所制，欲开发而不能，今日共和告成，措施自由，产业勃兴，盖可预卜。然不可不防一种流弊，即资本家将从此以出是也。
只有马克思主义在风雨之中扎根于中国社会，掀开了新陈代谢的另一页。
团体发展一步，经济紧急一步；团体存在一天，经济困难一天。由经济紧急而经济困难，由经济困难而经济穷绝，以至于团体不得不解散。
要改造社会，须从根本上谋全体的改造，枝枝节节地一部分的改造是不中用的。
社会没有根本改造以前，不能试验新生活，不论工读互助团和新村。
他接触过各种社会主义，而在俄国胜利的是科学社会主义，这个事实本身就是一种引导抉择的评判。
已被证实的东西不仅是一种理论，而且是一种事实。拥有事实的理论一定是能够征服人心的理论。
从戊戌变法仿效日俄、辛亥革命仿效法美到“五四”之后仿效苏俄，表现了每个时期先进中国人的选择。
辛亥革命所设计和构筑的资产阶级民主共和国，反映了七十年社会经济变化中蕴积起来的富国强兵、大倡实业、发展资本主义的要求。
中国人由此而面临着一个很大的矛盾：在资本主义所代表的历史阶段实现之前，资产阶级革命并没有丧失其历史的进步意义；但社会主义思想体系来到中国，一开始就否定了资本主义。
历史阶段是不可超越的，但超越历史阶段的愿望又产生于历史发展过程所形成的内因和外因之中。
当马克思主义还没有与中国革命实践结合为一体的时候，急迫性曾是具有感染力的情绪。
表现为共产党内部的盲动主义、冒险主义和教条主义。
历史选择了社会主义，历史又以客观现实限制了主观愿望。这个矛盾，要求马克思主义中国化。
当社会主义制度在中国建立之后，它所面对的是没有经受过资本主义大规模冲击的小农经济的汪洋大海。这片汪洋大海里深藏着和复制着几千年传统留下的影响。优点和弱点，两者都反映了三十年新陈代谢的历史结果。
辛亥革命是中等阶级的革命，北伐战争是国民革命。
北伐战争推翻了北洋军阀，在这个过程里，共产党人和国民党人都付出过自己的鲜血。
两者的不可调和终于导致了两者的分裂和对抗，于是而有“四·一二”到“七·一五”的屠杀。
1927年春季，与武汉政府东西对峙的蒋介石和上海商业联合会中富有财力的江浙资产阶级结成了一种政治经济联盟。
发动“四·一二”政变的时候，蒋介石无疑代表了帝国主义和封建主义的利益；但是，当江浙财团拥护蒋介石的时候，他同时又得到了资产阶级的支持；当蔡元培这样德高望重的人物赞成“清党”的时候，他又得到了民主派的支持。
南昌起义和广州起义，显然志在城市；即使是湘赣边界的秋收起义，也是在“第三次攻打长沙”的口号中举起暴动旗帜的。
南昌起义和秋收起义保存下来的武装革命者，在经历了1927年的失败之后，于第二年春天汇聚于罗霄山脉的中段，开始了革命在农村的发展。
同城市相比，农村是落后的。但农村包围城市的道路却历史地成为中国民主革命走向胜利之路。这条道路最初虽然表现为失败后的退却，然而它包含着国情对于革命的制约，因此，它最终又成为一种自觉的选择。
半殖民地半封建的中国，微弱的资本主义经济和严重的地方农业经济并存。这种经济不平衡造成军阀割据的政治不平衡。由于经济不平衡，自给自足的农村经济可以提供武装割据的物质基础；由于政治不平衡，处于统治阶级矛盾间隙的农村可以成为革命首先胜利的地方。
以土地革命为内容结成了工农的武装联盟。
由于共产党的领导，新式的农民战争不同于旧式的农民起义；由于农民参加了革命，土地革命战争又比辛亥革命具有更强韧的生命力和深厚的社会基础。
当日本帝国主义的侵略使中国面对着亡国灭种之境的时候，民族革命便成为一种主要矛盾。
国民党政府监狱中所有的因共产主义或左派活动而被拘禁的人都释放了，其他逃亡到国外的人也回国为民族事业而听从分配。
因民族矛盾而第二次合作的共产党人和国民党人，并没有因民族矛盾而化解彼此之间深刻的政治分歧。双方都在民族战争的旗帜下固守着自己的阶级立场。
共产党要把抗日战争的胜利变为人民的胜利，变为民主革命的胜利。国民党要把抗日战争的胜利变为大地主大资产阶级的胜利。
国民党的抵抗力量之所以遭到极大削弱，实际上乃是战争初期我们派驻重庆的观察员所见到的那种腐败现象。
导出于 2022-09-28 14:50:49</description>
    </item>
    
    <item>
      <title>你一定要读的50部管理学经典</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E4%BD%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AF%BB%E7%9A%8450%E9%83%A8%E7%AE%A1%E7%90%86%E5%AD%A6%E7%BB%8F%E5%85%B8/</link>
      <pubDate>Wed, 28 Sep 2022 14:50:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E4%BD%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AF%BB%E7%9A%8450%E9%83%A8%E7%AE%A1%E7%90%86%E5%AD%A6%E7%BB%8F%E5%85%B8/</guid>
      <description>鲁克德
1 《科学管理原理》 1911年
泰勒
科学管理之父
理性效率的大师
希望能将当时的科学技术用于提高企业的劳动生产率，从而形成一套科学管理的理论和方法。
提高生产率而又不增加雇主和工人的劳动量，从而使双方都可从中受益
他在一片混沌中，用科学的手段去分析管理，提升管理效率，以便达到雇主和雇员的双赢。
科学，不是单凭经验的方法。
协调，不是不合。
合作，不是个人主义。
最高的产量，取代有限的产量。
发挥每个人最高的效率，实现最大的富裕
《科学管理原理》是管理史上最重要的一座丰碑，是每一位管理者必读的不朽之作。
《科学管理原理》的理论无论在哪里都很适用：生产力因之成倍地增长，工人的实际收入急剧上升，工作时间减少，工人的体力、精神压力减小，同时，销售收入和利润提高，而产品价格降低了。
劳资双方的双赢博弈——实施科学管理的核心 管理的主要目的是使雇主实现最大限度的富裕，同时也使每个雇员实现最大限度的富裕，换句话说就是实现劳资双方的双赢。
雇主和雇员共同富裕应该是管理的最主要目的
大部分的人都认为雇主和雇员的根本利益必然是对立的，但是，科学管理则恰恰相反。
施科学管理的核心问题——精神革命
对于雇主而言，其所追求的不仅是利润，更重要的是事业的发展
泰勒认为，通过“稳定工资支付率”和“标准作业量”，可以消除劳资对立，从而实现劳资双方的双赢局面。
劳资双赢，在当今社会仍然是一大难题。
依靠使命愿景和战略目标来统一组织成员的价值立场，依靠源于价值立场的制度性规范来统一各自对立的利益关系
提高劳动生产率——管理的本质问题
如何在有限的时间里获取最大程度的产出，也就是如何使生产率最大化，是泰勒奋斗一生所要探索的问题，同时也是管理的本质所在。
财富最大化只能是生产率最大化的结果。
1）科学划分工作元素
2）科学地挑选员工，并进行培训和教育
3）与员工亲密合作
4）管理者与员工应有平等的工作和责任范围
1）工作定额原理
2）科学地选人、用人
3）标准化原理
4）差别计件工资制
5）建立专门计划层
5 《谁动了我的奶酪？》 两年中销售2 000万册
这里所谓的“奶酪”是一种比喻，它可以被当成我们生命中最想得到的东西。它可能是一份工作、人际关系、金钱、财产、健康、心灵的宁静。
当面对变化时两个老鼠做得比两个小矮人要好，因为他们总是把事情简单化；而两个小矮人具有复杂的脑筋和人类的情感，却总是把事情变得复杂化。
人类那些过于复杂的智慧和情感有时又何尝不是前进道路上的阻碍呢？
当事物发生变化时，或许简单行事会给我们带来许多的便利和益处。
他们像人一样，喜欢用复杂的思维，在采取行动前，总会不断思考。
毫无准备，不知所措，逃避现实。
对这两个小矮人来说，奶酪也不仅仅是解决温饱的食物了，它意味着小矮人悠闲的生活，意味着他们的荣誉，意味着他们的社交关系，意味着他们的社会地位，还有其他很多重要的方面。
他们花了很长的时间决定该怎么办。
他们压根儿就没有想过，他们本来就是一无所有的，奶酪也是他们从别处得来的。
你可以相信，变化对你有害，你可以拒绝它；或者，你会相信寻找奶酪对你有好处，你会拥抱这种变化。这些都取决于你相信什么。
又是什么让他决定做出改变的呢？可能是恐惧吧，害怕饿死的恐惧。
生活是无时无刻不在变化的，不要害怕变化，因为害怕变化只能是逃避现实。善于观察生活中出现的细小变化，那样才能够为即将到来的大变化作好准备。
阻止你发生改变的最大因素是你自己。只有自己发生了改变，事情才会开始好转。陈旧的观念只会使你裹足不前。
新奶酪始终总是存在于某个地方，不管你是否已经意识到了它的存在。只有当你勇于克服自己的恐惧念头，并且勇于走出自己的习惯方式，去享受冒险带来的喜悦时，你才会得到新奶酪带给你的报偿和奖赏。
他必须迈出第一步，否则他永远不会看到改变自己所带来的好处。
6 《从优秀到卓越》 詹姆斯·柯林斯
《基业长青》的姊妹篇
如何将一个优秀的企业，转变为一个能够持续创造非凡业绩的卓越企业
如何管理一个卓越企业并使其具有非凡的气质并长盛不衰
需要核心价值观和一个超越盈利的目的
保持核心或激励进步的关键动力
优秀是卓越的大敌。
第5级经理人、先人后事、直面残酷的现实、刺猬理念、训练有素的文化、技术加速器、飞轮和厄运之轮。
第5级经理人是指具有谦逊品质和坚定意志的企业领导人，他们个个具有雄心壮志，永远把企业的利益放在第一位，很少计较个人的得失，他们把对社会有所建树、有所创造、有所贡献作为人生的最大价值。
人力不是最重要的财富，合适的人才才是
14 《伟大的组织者》 研究戴尔甚至整个经验学派管理思想的必读书 40 《再论如何激励员工》 该文重印后共售出100万份，使其成为该刊有史以来最受欢迎的作品。</description>
    </item>
    
    <item>
      <title>我读：梁文道的开卷八分钟（全7册）</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E6%88%91%E8%AF%BB%E6%A2%81%E6%96%87%E9%81%93%E7%9A%84%E5%BC%80%E5%8D%B7%E5%85%AB%E5%88%86%E9%92%9F%E5%85%A87%E5%86%8C/</link>
      <pubDate>Wed, 28 Sep 2022 14:50:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E6%88%91%E8%AF%BB%E6%A2%81%E6%96%87%E9%81%93%E7%9A%84%E5%BC%80%E5%8D%B7%E5%85%AB%E5%88%86%E9%92%9F%E5%85%A87%E5%86%8C/</guid>
      <description>梁文道
思想杂草 《论语》是本教人怎么做君子的书，因为从中特别能看出一个君子该有的气魄何在。 先上讣告后上天堂 既然你已经死了，我将披上兽皮，在旷野中流浪。
是有人说走就走了，死亡就是如此突然。
任何亡者生前跟你一起去过的地方、看过的东西，现在只要一碰触，马上会被带进一个回忆的漩涡里，越陷越深。
怎么样恰当地对待将要死亡的人。
The Loneliness of Dying。
垂死到底是一种什么感觉？死亡究竟是一种什么体验？
中古时代欧洲人对待死亡的态度是沉着安宁的，因为那个时候死亡随处可见，尸体腐烂的臭味和人之将死的呻吟是每个人成长经历的一部分。
现代人的死亡是备受压抑的死亡。
衰老本身就是一种禁忌，它将死者与生者隔离开来。衰老者孤立无援，无声无息地从生者的群体中疏离，同他们所爱的人的关系渐趋冷却，告别了那些原本赋予他们意义和安全感的人们。
老人和临终者在这个时代是孤寂的，他们与正常的社会生活和人际关系被完全斩断了。
在现代化国家诞生之前，人的生命是怎样的呢？人的生活充满了各种意外，匪盗四起，疾病猖獗，横死是一件很普通的事，寿终正寝反倒成了人的梦想。
现代社会相对更文明，这个文明指的是我们每个人对自己情绪的控制、对社会及自然的控制都加强了。当一切都被精密地纳入组织系统并被控制得非常完好时，我们的生活相对来说是安定的，寿命也相应延长了。
我们已经不习惯当众擤鼻涕、挖鼻孔等等，这些自然的动作被隐藏在幕后。
对于死亡的恐惧和亲人离世的痛苦，我们也隐藏了起来，没有人愿意随便乱哭了。
死亡并不是这样的，死亡没有什么秘密，它只是人生的终点，是人类生命中不可或缺的部分。如果我们不再压抑死亡，我们的孤独感也许会减轻很多。
伟大的失败者 社会需要不同意见，因为情况越复杂，我们越是要避免大家都变成同一个大脑、同一种人。
人都有一个共性：我们渴求他人的认同，也倾向于附和他人的意见，因此往往会把自己的真实感受和想法压下去。
一群人意见完全一致，就等于变成了一个脑子，他们作出的决策往往会有各种盲点和问题。
为什么我们会轻易认同他人呢？首先，我们常常会觉得自己拥有的资讯不够多，很想听听别人的意见；第二，我们缺乏自信，而越缺乏自信就越容易盲从；第三，我们很在意别人是否认同自己，
为什么大家都看到几条线一样长，只有你看到的不一样呢？这种担心和忧虑难免会让你放弃最真实的感受，屈从于他人的意见。
没去过澳洲之前，欧洲人一直以为所有的天鹅都是白色的，直到遭遇了第一只黑天鹅，他们的观念彻底改变了，这就是“黑天鹅效应”。
人类总有一种惯性，在面对一连串事实的时候，很难不去编织故事。
对头，就产生了所谓的因果关系。其实因果关系在大自然中并不必然存在。
互联网影响我们的大脑构造，使人类不再习惯像从前那样做深度思考，而逐渐流于浅薄。
其实所有的媒体都不仅仅是传播工具，媒体的形式本身已经在影响人类了。
媒介即信息。
我们时代的写作 莫言语言的放肆就是诺贝尔文学奖评委所说的“迷幻现实主义”，这种迷幻状态恰恰能够捕捉今天中国的复杂性。
今天中国很多东西说不清道不明，比如社会主义市场经济到底是什么。
社会主义市场经济是不同生产方式的并存，不同时代压缩在一个空间里，资本主义、超资本主义、前资本主义的东西都在其中。
这个人虽是钦差大臣，然而皇帝在下面已无权力，到处诸侯割据，派人下去自然会发生一系列荒唐的事。你以为自己拿着尚方宝剑和大印就管用，但别人根本不跟你玩这一套。
这里边有共产党的语言、官方语言，有民间语言，有上得台面的语言，有上不得台面的语言，有胡搅蛮缠的语言，也有好像讲道理其实不讲道理的语言，所有的语言都混在一起了。
掌握各种各样的合法性的词汇，各种各样的合法性的表述，各种各样的合法性的资源，他们以这样一种语言上的合法性将自己包装起来。这就是中国现状的一个特色。
莫言的意图非常宏大，试图以轮回串联50年历史。
他认为新中国成立初期农民是有土地的，后来开始革命，搞公社化，土地归集体所有，再后来改革开放，土地再度回到农民手中——革命几十年，朝夕间又回到原点，这是一个大轮回。
当年搞公社化，那个人坚持单干，最后儿女跟他分家，他在“文化大革命”中上吊自杀。
莫言认为农民应该跟土地绑在一起，土地只有归农民所有，农民才能真正做自己的主人。在人民公社大集体里，农民只是土地的“奴隶”，或者说是集体的“奴隶”。 不要相信作家的传记，更不要相信作家的自传，作家所有的秘密都在作品里。
要让自己的作品充满色彩和画面、声音与旋律、苦辣与酸甜、软硬与凉热等等丰富的可感受的描写，当然这一切都是借助于准确而优美的语言来实现的。
一个村庄里的中国 父母期待子女遵从传统孝道，年青一代对待父母则讲求等价交换。
个人性即社会性，最具个人性的也就是最非个人性的。个体遭遇的困难，看似主观层面的紧张或冲突，但反映的往往是社会世界深层的结构性矛盾”。
农民对苦难最常见的解释是“命苦”。
西方代际关系是“接力模式”，中国则是“反馈模式”。
中国是父母养大子女后，轮到子女来照顾父母，这是一种交换关系，
现在中国代际冲突的重点是：父母强调养育之恩，认为子女回报父母天经地义；子女则注重财物方面，主要看父母给予他们什么东西，以及对他们好不好。父母期待子女遵从传统孝道，年青一代对待父母则讲求等价交换。
政治权力的集团性垄断和社会各利益群体缺乏最为基本和公平的博弈，是目前中国社会最大的风险因素。
深圳市政府的解决办法是“法律框架、人道关怀”——既然法律无法解决问题，只好人道关怀。于先生认为，这种说法掩盖了事情的本质。政府本来就对外来务工人员负有法律责任和政治责任，所谓“人道关怀”是一种伪善。
农民维权是在合法的前提下，希望得到公平对待，然而地方政府部门滥用警力去截访，这不是让政府公信力沦亡吗？
上访事件并非政治问题，而是利益问题。政府若视之为政治问题，就会感到很严重；若看成利益问题，恢复各种合法渠道，使社会底层的合法权益有所保障，则不会有太大的政治问题。
记得我最初看见父亲的黑是害怕的，甚至是嫌恶的，但是等我看见白的时候，我才意识到，白比黑更令我畏惧。黑对于我的意义，则是日常的，平安的，吉祥的。白色的绷带，意味着矿工的伤残。
国内一些学者认为，最根本的解决之道是明确农民的土地私有财产权，产权一旦明确，很多问题迎刃而解。
这是一个涉及意识形态争论的大问题，主张前者的一般称为右派，主张后者的称为左派。
他认为小农经济是中国农业的一个基本特色，农业发展的关键在于农业劳动力产出或产值的提高。
中国自明清以来一直是“没有发展的增长”——总产量提高了，但人均投入产出比并未提高。
关键在于人口和劳动力相对过剩。这么多过剩劳动力如何安顿？只能让他们非常密集地聚在小块土地上劳作，形成小农经济。
小农经济造成的普遍状况是长期贫困，一时半会儿饿不死，要吃饱也很困难。
中国农村经济的发展主要来自食品消费变化导致的农业结构转型，源自非农经济发展带来的收入增加。
一旦农民活不下去，国家就会出乱子。
劳动力和其他生产要素一样是稀缺资源，理性经济人不可能为零报酬而劳动。
一旦土地私有化，农民卖掉土地就一无所有，连非正规经济里的农民工都无退路。
农民进城打工风险很大，没有任何保障，万一失业，回到农村还有土地可以勉强度日。</description>
    </item>
    
    <item>
      <title>清华新闻书目导读（100种）</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E6%B8%85%E5%8D%8E%E6%96%B0%E9%97%BB%E4%B9%A6%E7%9B%AE%E5%AF%BC%E8%AF%BB100%E7%A7%8D/</link>
      <pubDate>Wed, 28 Sep 2022 14:50:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E6%B8%85%E5%8D%8E%E6%96%B0%E9%97%BB%E4%B9%A6%E7%9B%AE%E5%AF%BC%E8%AF%BB100%E7%A7%8D/</guid>
      <description>李彬
博通类（50种） 《共产党宣言》是马克思、恩格斯最有影响的作品，是共产主义的“圣经”。
每个人的自由发展是一切人自由发展的条件
第一章内容最多，思想也最重要。
“至今一切社会的历史都是阶级斗争的历史”
它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的‘现金交易’，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。
总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削”。
资本在横扫一切封建羁绊的同时，也创造出了自己的掘墓人，即无产阶级。资本主义的矛盾使得无产阶级的胜利成为历史的必然。
一是共产党和无产者之间的关系，指出共产党人代表了整个阶级运动的利益；二是反驳对共产党的一些指责，指出为何要反对私有制等一些通行的资产阶级观念；三是指出共产主义革命的一些特点；四是革命后会采取的一些措施。
无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。全世界无产者，联合起来！
它奠立了马克思主义学说的基础，也是随后共产主义革命的行动指南，无数革命志士阅读此书以后走上了革命道
1936年，他对来访的美国记者斯诺表示，《共产党宣言》“特别深刻地铭记在我的心中，使我树立起对马克思主义的信仰。我接受马克思主义，认为它是对历史的正确解释，以后，我对马克思主义的信仰就没有动摇过”。
要了解中国革命与中国道路，必然要读《共产党宣言》。
我们所面临的问题马克思和恩格斯早就在《宣言》中预言到了，几次工业革命的崛起所缓解的资本主义矛盾并没有得到调和，反而以更加深刻的形式影响人类社会。
《共产党宣言》的根本真理是不可动摇的，它是一部具有世界历史意义的文献。
2. 《毛泽东选集》 有人评选过影响中华人民共和国的10本书，《毛泽东选集》也是排在第一位。
一是《毛泽东选集》
改革开放以后，对《毛泽东选集》再版，修改了一些极“左”时期的注释，篇目上没有做调整，仅仅加一篇《反对本本主义》。
二是《毛泽东文集》
三是《建国以来毛泽东文稿》，由中央文献出版社出版。
从《毛泽东选集》中，我们不仅能读到好的文章，更能读到历史，进而读到现实。
5. 《中国历代政治得失》 该书出版以后，在港、台地区和东南亚产生了很大的影响力，是投考港大中文系的必读书。
对本国的历史“有温情的敬意”，对以往的历史不是当成已过的往事，甚至为现实的失败承担责任，而是将其认作自己的先辈，怀着敬意和温情，不苛责强求；（2）对制度、人事有个全盘的了解，同样的制度，因人事变化而败坏。
虽然作为蒋介石的“帝师”，钱穆一生并不服膺马克思主义，但其知人论世的态度与方法却颇得唯物史观的精髓。
6. 《中国哲学简史》 当年冯友兰去世，临终的遗言是：“中国的哲学一定会大放异彩。” 9. 《义和团战争的起源》 义和团战争的产生，同西方在华外交官和传教士不懂中国国情有密切的关系。因此，他强调国际关系中熟悉对方国情的重要性。 10. 《蒋梦麟自传》 全书分为七个部分，第一部分是蒋梦麟自己的童年。
第二部分是他的教育经历。
在第三部分，他发现自己走的这几年中国已经变了：
五四运动以后，蔡元培先生不愿受风潮的胁迫，辞去北大的校长，北洋政府一再劝说后，他指定蒋梦麟代管北大，这便是蒋梦麟与北大20多年缘分的开始。
书的第四和第六部分叙述的是北伐以及抗日战争。
书的第四部分和第七部分是关于中国社会的一些介绍。
这本书起初用英文写成，过了10多年再转译回中文。
该书也是了解中国近代社会变迁的很好的入门书。
12. 《伟大的中国革命——1800—1985（新版）》 费正清”这个典雅的中文名，乃梁思成、林徽因夫妇所取，意为“正直清白”。
飞力、魏斐德、史景迁、傅高义等汉学名家皆出自费正清门下。
13. 《李宗仁回忆录》 不意在革命之后，这种欣欣向荣的气象反而消失。以前的所谓新人物，现在大半变成旧官僚；以前的新政机构，现在又都变成敷衍公事的衙门。
当下的中国，实由一连串的“革命”所造就，而传统就像“重力”一样，即使是革命者也不可能脱离它一飞冲天，而不得不持续“接力”
对于国民党军令、政令的不统一以及在大陆的彻底溃败，在李宗仁看来，根本在于最高统治者的私心自用，以及曾经的革命政党蜕变成为一个庞大的利益集团。
中央当局为政既不以德，则中国真正统一便永远不能完成。为应付这一错综复杂的政治局面，蒋先生在中央各部门及其权力能到达的省份中，全是因人设事。不是用人唯才、励精图治，而是以政府名气作酬庸，来拉拢亲蒋人士。
因而在中央能彻底控制的省份中，其行政效率与各项建设反不若中央政令不能贯彻的各省
国家在大兵之后，疮痍满目，哀鸿遍野，而当国者却如此以国事逞私欲，国民党政权如不瓦解，真是无天理了！
16. 《乡土中国》 “各美其美、美人之美、美美与共、天下大同”。 26. 《西方政治思想史》 继承了盎格鲁思想文化传统的人民依照罗马帝国的典范创立的美国政府，就是当下西方最为理想的政治制度。
政府权力与民众权力的协调与制衡上
好的君主政体，后来都不免腐坏，严于自我纪律的贵族逐渐退化成唯财富是逐的寡头集团，民主则每每终于暴民统治。
28. 《第三帝国的兴亡》 本书作者并不是一位科班历史学家，而是一位新闻记者。
民主和独裁之间究竟是不是像人们所期许的那样泾渭分明
对于通过合法程序获得最高权力的政治领袖他所犯下的罪行究竟应当算是谁的罪行？</description>
    </item>
    
    <item>
      <title>领导力必修课：动员团队解决难题</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E9%A2%86%E5%AF%BC%E5%8A%9B%E5%BF%85%E4%BF%AE%E8%AF%BE%E5%8A%A8%E5%91%98%E5%9B%A2%E9%98%9F%E8%A7%A3%E5%86%B3%E9%9A%BE%E9%A2%98/</link>
      <pubDate>Wed, 28 Sep 2022 14:50:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E9%A2%86%E5%AF%BC%E5%8A%9B%E5%BF%85%E4%BF%AE%E8%AF%BE%E5%8A%A8%E5%91%98%E5%9B%A2%E9%98%9F%E8%A7%A3%E5%86%B3%E9%9A%BE%E9%A2%98/</guid>
      <description>刘澜
第一讲 领导力不是当领导 “领导力”跟“当领导”不是一回事
领导力不是人生的奢侈品，而是必需品
动员团队解决难题
领导力的核心
解决难题才是领导力。
一种是维持性问题，另一种是变革性问题。
维持性问题有可能很复杂，但是答案可以从已有的知识中发现。
这两个问题的共同点在于变革，在于问题的主人公需要我们学习新的行为。
维持性问题的主要特点是复杂性，变革性问题的主要特点是不确定性。
如何正确地做事情
如何做正确的事情
变革性问题才是难题
变革性难题不仅要求你变革，还要求其他人也变革。
一个人解决问题，可以说是英雄。一个人动员一群人解决问题，才是领袖，也就是真正的领导者。
成就自己一个人的，是英雄。成就团队一群人的，是领袖。
领袖往往也是英雄，但是英雄不一定是领袖。
只有一个人可以“动员”其他人
解决难题可不是那么容易的，其他人不一定愿意去做，你需要动员。你改变他们的想法、影响他们的行为，这就是动员。
解决难题可以借助、需要动员的一切人，都是你的团队。
动员团队、动员群众、动员他人，都是一回事，只是表述不同而已。
领导力和领导职位的联系
（1）领导力是领导职位的责任；（2）领导职位是领导力的资源；（3）领导职位可以是领导力的阻碍。
担任所谓的领导职位，你就有发挥领导力——动员团队解决难题——的责任。
如果说只有以爱情为基础的婚姻才是合乎道德的，那么也只有继续保持爱情的婚姻才合乎道德。
没有爱情的婚姻是不道德的。
领导职位可以给领导力——动员团队解决难题——提供资源。
组织赋予了你指挥他们的权力，给了你奖励或者惩罚他们的工具。
没有领导职位，你同样可以去动员团队解决难题，那你就是在发挥领导力。
婚姻是爱情的资源，可以为维系和发展爱情提供平台、保障和支持。
（1）责任的迷失；（2）权力的诱惑；（3）守旧的惯性。
有可能让人忽略自己真正重要的责任——动员团队解决难题。
把权力和资源本身作为追求的目标。
倾向于提拔与自己相似的人以及认同组织现有价值观和行事方式的人
用人的套娃效应”
你要是永远都只任用比自己水平差的人，那么我们的公司就会沦为侏儒；你要是敢于启用比自己水平高的人，我们就会成长为巨人！
你要是永远都只任用跟自己一样的人，那么我们的公司只是在维持；你要是敢于启用跟自己不一样的人，我们才能在变革中成长！
“用人的套娃效应”最终会造成一个组织中担任领导职务的人产生一种系统性偏向：因循守旧。
第二讲 运用五种领导力策略 领导力不是你“当什么”，不是你“有什么”，而是你“做什么”。
领导力是你做什么。做什么呢？动员团队解决难题。
短期任务就是动员团队解决某个具体的难题。
长期任务则是提升自己与团队解决难题的能力。
完成短期任务可以运用领导力策略，完成长期任务需要进行领导力修炼。
冷静分析、盘点资源、建立联盟、积聚小胜、控制时机。
找到那些潜在的、强有力的支持者，获取他们的支持。从权力的角度看，这是借用权力。
积小胜为大胜
解决难题是充满不确定性的长期过程，最终的胜利要建立在一个个小胜利之上。小胜起到学习的作用，帮助验证和调整前进的方向，确保最终达到终点。
以小胜赢人心
小胜通常意味着小的改变，相比大的改变来说，更容易让团队接受。
一次小胜降低了严重性（‘这没什么大不了的’），降低了要求（‘原来只需要做这些’），增加了感受到的技能水平（‘至少我能够做到这个’）。
一方面，当急则急。
另一方面，当缓则缓。
怎样提升自己和团队，更有效地解决一个又一个的难题呢？
第五讲 权力是领导力的工具 承担责任需要权力，而且承担责任可以扩大权力。
权力就是让别人听你的
在社会科学上权力是最基本的概念，犹如在物理学上能是基本概念一样。
权力就是让别人听你的。如果一个人能让别人听他的，这个人就有权力。
第一种是报酬权力。
第二种是强制权力。
第三种是合法权力。
第四种是专家权力。
第五种是参照权力。
权力是一种关系。
五种权力都有可能，要看你改口的原因是什么。</description>
    </item>
    
    <item>
      <title>开放社会及其敌人</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E5%BC%80%E6%94%BE%E7%A4%BE%E4%BC%9A%E5%8F%8A%E5%85%B6%E6%95%8C%E4%BA%BA/</link>
      <pubDate>Wed, 28 Sep 2022 14:48:52 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E5%BC%80%E6%94%BE%E7%A4%BE%E4%BC%9A%E5%8F%8A%E5%85%B6%E6%95%8C%E4%BA%BA/</guid>
      <description>卡尔·波普尔
导言：卡尔·波普尔与开放社会 在人类历史中，如此多的人死于暴政在此前是亘古未有的。
在他的年轻时代，波普尔最初倾向于社会主义思想（而且由于第一次世界大战的经历还变得强烈），但是，当他在战后时期的国内战争动乱中看清了信誓旦旦的“阶级斗争”所表现的藐视人的一面之后，他又抛弃了它。后来他承认，如果事实并未表明社会主义理想与个人自由水火不容的话，他还会一直乐于追求社会主义理想。
波普尔的《开放社会及其敌人》属于本世纪最伟大的政治思想经典著作。
第十三章 马克思的社会学决定论 然而，他们的科学却建立在一种深刻的误解之上……因此，他们的行动极具破坏性和反动性。人的心灵受到如此严重的伤害，以致他们的精神分裂了，他们再也没可供选择的机会。
至于马克思主义，则被看成历史主义的最纯粹的、最发达的和最危险的形式。
他以各种方式开拓了我们的眼界，使我们的目光更敏锐。
如果不承认马克思的真诚，我们就不能公正地对待他。马克思的开放的心灵、敏锐的现实感、不信空言、尤其是不信道德方面的空言，使他成了世界上反对伪善和法利赛主义的最有影响的战士之一。
他有着帮助被压迫者的强烈欲望；他充分意识到，需要在行动上而不只是在言词中证实自身。
他追求真理的真诚和他在理智上的诚实，使他与他的许多追随者完全不同。
马克思对社会科学和社会哲学的兴趣，基本上是一种实践的兴趣。他在知识中找到了一种推动人进步的手段。
为何还要攻击马克思呢？虽然他有许多功绩，但是我认为，他是一位错误的预言家。
马克思主义是一种纯粹的历史理论，一种旨在预测经济和政治的发展的未来进程，尤其是预测革命的未来进程的理论。
正如列宁很快明白的，马克思主义不能对实际的经济问题提供帮助。
这些所谓的新经济政策，以及后来的各种实验——五年计划等——与马克思和恩格斯曾经宣布的“科学社会主义”的理论没有任何关系。
马克思的宏大的经济研究，甚至没有触及到一项建设性的经济政策。
因此，马克思主义者甚至不研究所谓的“资产阶级经济学家”在该领域中所取得的成就。
马克思主义的方法是十分贫乏的。
第十八章 社会主义的来临 经济的历史主义是马克思用于分析我们社会中即将发生的变化的方法。
每种特殊的社会体系之所以必须摧毁自身，只不过由于它必须创造出产生下一个历史时期的力量。
因为肯定没有理由相信，在一切社会体系中，资本主义会永远延续。
对基本的经济力量和我们称作“资本主义”时期危及自身生命的历史趋势的分析，已由马克思的《资本论》——他毕生的伟大著作——所进行。他探讨的历史时期和经济体系，是西欧、尤其是大约从１８世纪中叶至1867年（《资本论》发行第１版的一年）的英国的历史时期和经济体
正如他在序言中解释的，“本书的最终目的就是揭示现代社会的经济运动规律”，为的是预言它的命运。其次的目的是驳斥资本主义的辩护士，驳斥那些把资本主义的生产方式的规律描述为似乎是不可抗拒的自然规律的经济学家
导致一场社会革命不可避免的结论的“第二步”、导致预见一个无阶级社会，即社会主义之诞生的“第三步”，都只是概略提到。
即在阶级之间的社会关系的领域内，这种趋势必然导致越来越多的财富积累在越来越少的人手中；
即存在一种财富和苦难同时增长的趋势；对统治阶级，即资产阶级，是财富的增长，而对被统治阶级，即工人，是苦难的增长。
从这一结果出发，两个结论被推出；首先，除少量统治的阶级和大批受剥削的工人阶级之外，其他一切阶级必然要消失，或是变得不重要；其次，这两个阶级之间不断增长的张力，必然要导致一场社会革命。
最终得出的结论是，在工人取得对资产阶级的胜利之后，将存在一个只由单一阶级组成的社会，因而存在一个无阶级的社会、一个没有剥削的社会；也即是说，社会主义社会。
资本主义的发展已经导致除两个阶级——一小部分的资产阶级和庞大的无产阶级——之外的一切阶级的消失；苦难的增长已迫使后者反叛它的剥削者。
首先，工人必须赢得斗争，其次，通过消除资产阶级，他们必然建立一个无阶级的社会，因为只有一个阶级仍然存在。
不仅是资产阶级的数量小，而且它们的物质存在、他们的“新陈代谢”都依赖于无产阶级。
一切潜在的利益冲突现在似乎必然将从前联合的无产阶级分裂成新的阶级，并发展成一场新的阶级斗争（辩证法的原则会提示，一种新的对立、一种新对抗，很快就会发展。
最可能的发展是，那些在胜利之时实际上掌权的人——那些幸免于权力之争和各种清洗的革命领袖及其僚属——将组成新社会的统治阶级，一种新型的官僚制度的寡头政治；
通过尽可能地保留革命的意识形态，利用这些思想情感，而不是浪费时间力图摧毁它们（依照帕累托对全体统治者的劝告），他们能够很方便地做到这点。
革命的意识形态就能出于辩护的目的为他们服务；作为他们动用权力的一种辩解、一种稳定权力的手段——总之，作为一种新的“人民的鸦片”。
马克思的结论、无阶级社会来临的预言，并不能从这些前提推出。
马克思主义的偏见——“社会主义”或“共产主义”是惟一的选择和“资本主义”的惟一可能的继承者——错误解释经验。
在无阶级社会的意义上，在一种“在那里，每个人的自由发展是一切人的自由发展的条件”的“联合体”的意义上，社会主义是那种无情剥削的经济体系的惟一的可能选择
只是在占地球六分之一的俄国，我们看到一种按照马克思的预言建立的经济体系，在那里，生产资料为国家所拥有，然而其政治权力却与马克思预言相反，根本没有表现出消亡的倾向。
马克思实际上试图表明的是，只存在两种可能性：要么是一个恐怖的世界将永远继续下去，要么是一个更美好的世界会最终出现；几乎不值得我们浪费时间去认真思考第一种选择。
我们必须重申，谁也没有表明过，只存在“资本主义”和“社会主义”两种可能性。
即在科学预言的范围内尚未落败的道德和其他意识形态的要素，对历史进程发挥了深远的影响。
因为依照马克思主义，无产阶级革命应该是工业化的最终结果，而不是相反；它应该首先在高度工业化的国家发生，只是在很久以后才会在俄国发生。
第二十章 资本主义及其命运 资本主义正在经受着内在矛盾的阵痛，这些矛盾威胁着要造成它的毁灭。
无约束的资本主义
资本的积累意味着：（ａ）不断增长的生产率；财富的不断增长；财富集中在少数人手中；（ｂ）穷人和苦难的不断增长；工人的工资仅够维持生计或者不至饿死，由于工人过剩，即所谓“产业后备军”的存在，使工资维持在最低可能的水平。
尽管资本主义积累促进了通往社会主义的技术、经济和历史的进步，它却变成一种自杀性的和自我矛盾的选择。
竞争斗争是通过使商品便宜来进行的。在其他条件不变时，商品的便宜取决于劳动生产率，而劳动生产率又取决于生产规模。
资本家为了生存，不得不积累或积聚越来越多的资本；这实际上意味着，投入越来越多的资本，以购买越来越多和越来越新的机器，从而不断地提高工人的生产率
越来越多的财富集中到不同的资本家和资本家阶级的手中；随之而来的是资本家人数的减少，即一种马克思称作资本的集中的运动
因为它们描述了一种财富不断增长和越来越集中到少数人手里的趋势。但是，结论的另一部分，即苦难不断增长的规律，只是通过一种非常复杂的论证达成。
苦难蔓延的人数在增长；它也可以用来指人民受苦难的强度在增长。
它认为资本主义不可能去减轻工人的苦难，因为资本主义积累的机制使资本家经受强大的经济压力，如果不想屈从于这种压力，他们不得不将它转移给工人。
财富不断增长的规律是一件无害的事情，只要财富的增长为工人所分享是可能的。
税收制度和遗产税就能够用来抑制财富集中，并且它们就是这样被使用的。
马克思把财富集中或资本家人数减少的预言建立在这一论证的基础之上，是没有说服力的。
一直制造过剩人口的是资本主义的生产机制本身，它需要过剩人口降低雇佣工人的工资。
由于资本主义必须产生难以忍受的苦难，资本主义体系一定会崩溃。
第二十五章 历史有意义吗？ 历史主义是一种社会的、政治的、道德的（或者非道德的）哲学，而且从我们的文明开始起，它就一直具有极大的影响力。
我们发现自己永远在追逐自己的尾巴。
科学的方法毋宁是在探求那些可以反驳理论的事实。</description>
    </item>
    
    <item>
      <title>50堂经典哲学思维课</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/50%E5%A0%82%E7%BB%8F%E5%85%B8%E5%93%B2%E5%AD%A6%E6%80%9D%E7%BB%B4%E8%AF%BE/</link>
      <pubDate>Wed, 28 Sep 2022 14:38:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/50%E5%A0%82%E7%BB%8F%E5%85%B8%E5%93%B2%E5%AD%A6%E6%80%9D%E7%BB%B4%E8%AF%BE/</guid>
      <description>郁喆隽
自序：生活为何有待审视？ 未经审视的生活是不值得过的。”（A life which is unexamined is not worth living. Apology,38a）
“幸福是什么”就是一个典型的二阶问题。
所谓的“外包”就是购买服务、诉诸专家。
对于自己人生根本的问题是否都可以外包呢？是不是存在一些根本的问题，是别人无法代替你回答、因为不能代替你做出决定的呢？
思想助产士”——通过诘问来帮助别人找到他自己对于二阶问题的回答。而诞下的婴儿并不属于助产士。
对你而言，怎样的生活是值得过的？怎样的生活是不值得过的？
就此意义而言，哲学本质上是一门“自助”的学问。
哲学之所以吸引人，可能就是源自深藏于几乎每个人心底的问题——在自己的童年、在人生的危急时刻、在重大抉择的关头提出的发问。
哲学是不能学的，人只能学习哲思。（Philosphiekann man nicht lernen, man kann nur lernen zu philosophieren.）
6 莱布尼茨《单子论》 铁皮人如何获得自己的心？ 宗教的精义（包括基督教），在于实际生活……宗教的目的，在于教育群众。使他们的举动符合社会的利益……二人都认为品德就表示快乐，为善最乐，亦即一切思想的崇高目的。
铁皮人、稻草人和懦弱狮子。
铁皮人没有“心”，稻草人没有“脑子”，而狮子看上去威风凛凛却没有“胆子”
铁皮人的身体是铁皮打出来的，而铁皮是物质性的。一个全部是物质性的身体，如何获得精神性的心呢？
即便铁皮人获得了一颗心，也就是精神性的心灵，它又如何与物质性的铁皮身体沟通呢？如何沟通物质和精神世界，是笛卡尔二元论遗留的一个问题。
斯宾诺莎的哲学是把遥远的看不见的事物映入人们眼帘的望远镜；莱布尼茨的哲学是把细小的看不见的事物变成可以看得见事物的显微镜。
复合实体是单子的集合。单子（Monas）是一个希腊词，它代表单一体，或者那种作为一的东西……简单实体、生命、灵魂、精神都是单一体。
莱布尼茨的单子是一种非三维性的力或者能，不需要依靠外力的作用，单子自身的力就是它活动的原因。
隐德莱希就是一种自我的发动者，就是生命。
单子是有欲求、有感知的，且彼此独立、彼此不同。单子是灵魂，是无形体的自动机，它的产生和消灭只能由上帝的意志决定。
莱布尼茨提出要创造一种“普遍文字”，也就是用一些通用的、可计算的、如数字一般精准的符号来表达思想。
打破上帝阻隔人类所造的巴别塔，全世界的人都能明白这种文字的意义。
莱布尼茨的这些想法极为超前，他不仅用二进制为计算机奠定了运算的基础，还几乎预言了计算机的应用前景。
7 笛卡尔《第一哲学沉思集》 “我思故我在”，什么才是无可怀疑的？ 人真的能完全依赖自己的感觉吗？
要建立一套精确的知识体系，就要从审视人的感觉做起：思维与感知，大脑与身体，它们之间是如何互动的？我们如何判定真实与虚幻，正确与谬误？
如何区分梦境和现实？
怀疑一切未经过人的反思和检查就被盲目接受的教条和传统。
在笛卡尔看来，形而上学就是第一哲学。笛卡尔意义上的形而上学旨在研究关于知识的知识。
人的思维如何获取知识？什么是判定真理的标准？现实的确切本质是什么？
怀疑一切，直到找到那个不可被怀疑的基点。
前提不可靠，推论出来的结果自然也就成问题了。
一切都无法确定
万物皆可怀疑
卡尔首先怀疑的是自己的感官。
究竟要如何分辨现实和梦境呢？这就是笛卡尔提出的第一个怀疑。
此人的感知并不是绝对可靠的。
那武器就是人们的思维本身，它是最纯粹、最根本的东西。
这些真理又被称为“天赋观念”，不论是在现实还是在梦境，它们都不会被扭曲、改变。
I think, therefore I am）。
我怀疑，所以我思考，所以我存在。
我在怀疑的时候，我不能怀疑我自己的存在。</description>
    </item>
    
    <item>
      <title>作为意志和表象的世界</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E4%BD%9C%E4%B8%BA%E6%84%8F%E5%BF%97%E5%92%8C%E8%A1%A8%E8%B1%A1%E7%9A%84%E4%B8%96%E7%95%8C/</link>
      <pubDate>Wed, 28 Sep 2022 14:38:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E4%BD%9C%E4%B8%BA%E6%84%8F%E5%BF%97%E5%92%8C%E8%A1%A8%E8%B1%A1%E7%9A%84%E4%B8%96%E7%95%8C/</guid>
      <description>叔本华
卷一 表象世界初论 世界是我的表象
当自己认知太阳和大地时，认知的并非太阳和大地本身，而是见到太阳的眼睛和触摸大地的手；他周围的世界只是表象，只是和意识有关的东西，和人类有关的东西[插图]。
凡是在知识上存在的东西，包括整个世界，也只是与主体相关的客体，只是知觉者所具有的知觉：总而言之，只是表象。
这个真理告诉我们：世界是我的意志。
世界一方面完全是“表象”，另一方面也完全是“意志”。
能认识一切事物，而本身不被任何东西所认识的，是主体。
因为凡是存在的东西，都只能借助主体方能存在。
只有在从事认识活动的时候，他才真的是主体；如果成为知识的对象，就不是主体了。
导出于 2022-09-28 14:38:31</description>
    </item>
    
    <item>
      <title>哲学九讲</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6%E4%B9%9D%E8%AE%B2/</link>
      <pubDate>Wed, 28 Sep 2022 14:38:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6%E4%B9%9D%E8%AE%B2/</guid>
      <description>J.F.沃芬登
第二讲 事物 苹果本身到底是什么样的呢？我们要如何形容它呢？
然而，仅仅称它为“客体”，就可能暗示着它仅仅是主体的客体，此外什么都不是；
这些东西一旦脱离了它们的主体，就根本无所谓存在可谈。
们的问题则是：“苹果在这里是什么呢？”
关于所有的感官，我们都会发现这么一个问题：我们永远无法保证这些感官刺激对每个人的效果都一样。我们无法知道自己的视觉、触觉、味觉、嗅觉和听觉是否与其他人一样。
那苹果本身到底是什么样的呢？我们要如何形容它呢？是它本来就是甜的，还是只是某些人尝起来甜？它原本就是青色、甘甜、表面光滑、形状浑圆的吗？还是说，它的形状由感知者决定，感知者不同，其形状也会随之改变？显
我们正在试图寻找苹果的真实样子，而得到的却是不同感知者眼中各种各样的答案。
2．第一性质与第二性质 实体是一切属性的承担者，是一切表面现象的统一。
第二性质的改变对整个事物的改变影响也不及第一性质。
简而言之，第一性质是指那些关系到物体在空间上存在的性质，而
第二性质则不关系到这一点。
体积、广延[插图]、形状、能否运动、数量都属于第一性质，而颜色、声音、味道、气味则属于第二性质。
科学从本质上说是抽象的，这并不是蔑视它，只是指出它的本质特征；真正的科学爱好者都希望能领会科学的真谛。
以此类推，每个学科都只关注与其密切相关的性质，并把这些性质定为第一性质。
我们现在关心的并不是作用，而是这种区分从根本上是否合理。
事物的甜味要依靠人来品尝，我们提到的苹果之所以是表面光滑的，也是人触摸后认为它是表面光滑的
然而，它的广延和数量是它本身的品质，跟感知者没有关系。
空间上的第一性质是客观性的，是事物自身具有的，无论是否被感知，这些性质都不会变，而第二性质则是主观性的，它取决于主体将其作为感知的客体。
“难道第一性质就不是主观性的吗？”事物的广延、形状和数量，就真的比味道和气味要真实可靠吗？
那你是如何感知到或想到苹果的数量和广延的呢？
真的能够单纯地感知到事物的广延吗？没有颜色，没有味道，没有声音，也没有气味，只有广延，这样显然是不可能的。
如果确实没有办法抛开第二性质——比如说颜色，而纯粹感知到事物的广延，这样一来，第一性质与第二性质的整个区分体系就将随之崩溃。
3．本体 我们以探索苹果的本质为出发点：它本身是否真实？它是否能够离开感知的主体？是否可以把苹果的某些性质，与那些更重要、更基本的性质区分开来？ 第九讲 表象与实在 我们的判断，或正确或错误，到底指的是什么？
我们判断的是什么？
我们对事实进行感知和判断。
持
任何感知行为都必须具备两个要素：主体和客体。
我们在试图更清晰地定义客体之初，就遇到了困难。
洛克认为，概念是思维能够感知的唯一的东西，而贝克莱并不这么认为，他提倡以事实为依据，采取真正的实证方式，不做任何的捏造与假设。
我们根本无法了解物质，或许也无法感知物质，那我们为什么要假设它们是存在的呢？
心灵，而非物质，才是宇宙中的能动主体，物质只是既无用处也无根据的假设。
外在的事物都是感觉印象的集合，并被我们所感知。
贝克莱仅仅是接受了它的存在，并宣称外在仅仅是存在而已，并没有什么不可思议的物质世界；物如其表，表里如一。
导出于 2022-09-28 14:38:31</description>
    </item>
    
    <item>
      <title>黑客与画家</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B610%E4%B8%87%E5%86%8C%E7%BA%AA%E5%BF%B5%E7%89%88/</link>
      <pubDate>Wed, 28 Sep 2022 14:20:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B610%E4%B8%87%E5%86%8C%E7%BA%AA%E5%BF%B5%E7%89%88/</guid>
      <description>保罗·格雷厄姆
平装版译者序 因为毒品是非法的，所以一起使用的话，就创造出了一种共同反叛的标志。 第一部分 黑客如何成长及看待世界 如果你解决问题的方式非常丑陋笨拙，这叫做你很“黑”。如果你解决问题的方式非常聪明高超，
将整个系统操纵在股掌之间，这也叫做你很“黑”。￼
常见的犯罪动机不外乎毒品、金钱、性、仇恨等。
1 为什么书呆子不受欢迎 我真正想要的是，能够设计奇妙的火箭、写出漂亮的文章、理解编程原理。一句话，我想要做伟大的事情。
任何一种艺术，不管是否重要，如果你想要在该领域出类拔萃，就必须全身心投入
他们为了把所有事情“做对”，所付出的任何努力，不管是有意还是无意，实际上都等同于努力在使自己变得更受欢迎
我们自己创造的世界是一个残酷和愚蠢的世界。
在一个人产生良知之前，折磨就是一种娱乐。
没有什么比一个共同的敌人
更能使得人们团结起来了。
真实世界的关键并非在于它是由成年人组成的，而在于它的庞大规模使得你做的每件事都能产生真正意义上的效果。
当你所做的事情能产生真实的效果，那就不仅仅是好玩而已了，发现正确的答案就开始变得重要了
真实世界的特点是，它极其庞大。如果总体足够大，即使是人数最少的少数派，只要聚集在一起，也能产生可观的力量。
上去，这是一个残酷的世界，也是一个乏味的世界
因为我在这个世界中过得并不好，我觉得一定是自己什么地方做错了。
他们与别人不一样，不把所有时间用来玩一种耗尽全力但又毫无意义的游戏。
整个镇子就像一个巨大的幼儿园，所有一切都是为了教育下一代而有意识地造出来的。
至于学校，不过是这个虚假环境中关住牲口的围栏。表面上，学校的使命是教育儿童。事实上，学校的真正目的是把儿童都关在同一个地方，以便大人们白天可以腾出手来把事情做完。
孩子们被送进来，花6年时间，记住一些毫无意义的事实
生活在这个扭曲的世界，不仅仅对书呆子，对所有孩子来说，都是充满压力的。
文艺复兴时期的学徒是整天劳碌的牧羊狗，而今天的青少年则是神经兮兮、供人玩耍的哈巴狗。他们的疯狂源于到处都是一片可怕的无聊。
那就是我们没有得到真正的工作，没能发挥我们的才能。
我们那时做的所有事情根本就是无意义的，至少那时看来是这样。
最好的情况下，那些事情也不过是遥远的将来我们可能从事的实际工作的练习。它所面向的目标是如此遥
远，以至于当时我们都不知道自己练习这些到底是为了干什么
你在学习中遇到的文字都是专为考试而设计的，目的就是为了出题，而不是为了讲清楚问题。
逃离这种空虚生活的唯一方法，就是向它屈服。
他们不会被扔到一旁，创造自己的小社会。他们是成年人社会的低级成员。
如今的大多数青少年，对他们的家长在遥远的办公室所从事的工作几乎一无所知。他们看不到学校作业与未来走上社会后从事的工作有何联系（实际上，还是有那么一点点联系）。
如今的成年人根本不接受青少年。一般来说，他们都是在办公室工作，所以就在上班的路上，顺路把孩
子送到学校去关着，这有点像他们周末外出度假时，把狗送到寄养的地方。
当工作的专业程度越来越高时，我们就必须接受更长时间的训练。
最有效的解决方案，就是把他们集中在一个地方，用几个成年人看守所有小孩。
底层成员对上层成员毫无敬意，而上层成员也没有传帮带的光荣感。这里的一切就是杀与被杀
校园生活的两大恐怖之处——残忍和无聊—
在他们嘴里，这些词似乎都是同一个意思——“听话”。
校园生活的真正问题是空虚
现行体系中没有什么事是必然的。它是现在这个样子，大部分是因为没人去改变它￼
我觉得最难的部分，其实是能否意识到你该做什么。
任何对生活立竿见影的改变，可能还是来自于书呆子自己。
哪怕你什么也改变不了，但是仅仅是理解自己的处境，也能使得痛苦减轻一些。
学校是一个很奇怪的、人为设计出来的体系，一半像是无菌室，一半像是野蛮洪荒之地。它就像人生一样，里面无所不包，但又不是事物的真实样子。
如果你觉得人生糟透了，那不是因为体内激素分泌失调（你父母相信这种说法），也不是因为人生真的糟透了（你本人相信这种说法）。那是因为你对成年人不再具有经济价值（与工业社会以前的时期相比），所以他们把你扔在学校里，一关就是好几年，根本没有真正的事情可做。
2 黑客与画家 赌博、投机、婚姻、继承、偷窃、敲诈、诈骗、垄断、行贿、游说、造假、开矿等。
做
3 不能说的话 你一定要小心自己说的话。
历史的常态似乎就是，任何一个年代的人们，都会对一些荒谬的东西深信不疑。他们的信念还很坚定，只要有人稍微表示一点怀疑，就会惹来大麻烦。
我们这个时代是否有所不同？只要读过一点历史，你就知道答案几乎确定无疑，就是“没有不同”。
4 良好的坏习惯 对于程序员来说，“黑客”这个词的字面意思主要就是“精通”，也就是他可以随心所欲地支配计算机。
黑客是不服从管教的，
如果硬要他们服从管教，他们也就无法成为优秀程序员了。
只有深入了解当前的技术，黑客才能构想下一代技术
一个是史蒂夫·乔布斯，另一个是史蒂夫·沃兹尼亚克
26岁的肯·汤普森和28岁的丹尼斯·里奇——觉得Multics 过分复杂，就另起炉灶，写出了一个自己的操作系统。他们参照Multics，为它取了一个搞笑式的名字Unix
如果我们不可以研究当前的技术，不能思考如何改进它，那么我们怎样才能开发出新技术呢？
计算机的出现使得机器的控制系统逐渐变成了软件，产品的价值也由软件来决定。</description>
    </item>
    
    <item>
      <title>关键对话：如何高效能沟通（原书第2版）（珍藏版）</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E5%85%B3%E9%94%AE%E5%AF%B9%E8%AF%9D%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%83%BD%E6%B2%9F%E9%80%9A%E5%8E%9F%E4%B9%A6%E7%AC%AC2%E7%89%88%E7%8F%8D%E8%97%8F%E7%89%88/</link>
      <pubDate>Wed, 28 Sep 2022 14:11:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E5%85%B3%E9%94%AE%E5%AF%B9%E8%AF%9D%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%83%BD%E6%B2%9F%E9%80%9A%E5%8E%9F%E4%B9%A6%E7%AC%AC2%E7%89%88%E7%8F%8D%E8%97%8F%E7%89%88/</guid>
      <description>科里·帕特森
第1章 何谓关键对话 沟通最大的问题在于，人们想当然地认为已经沟通了。
我们所说的关键对话指的是每个人身上都会发生的和他人的互动行为，是指可影响你生活的那些日常对话。
究竟怎样的对话才是关键对话而非普通交谈呢？关键对话有三个特征。
首先，对话双方的观点有很大差距。
其次，对话存在很高的风险。
最后，对话双方的情绪非常激烈。
上面列举的种种对话之所以关键（除此之外也包括挑衅、挫折、惊恐和令人苦恼等情况），是因为其结果会对你的生活质量造成巨大的影响。
你日常生活中的某些方面会因此出现持续性的积极或消极变化。
尽管关键对话的重要性不言而喻，但我们在面对它时却经常退缩。
我们已经习惯使用各种手段来逃避敏感棘手的关键对话。
只要掌握了处理关键对话的正确方法，你就能有效地应对涉及各种话题的关键对话。
关键对话指的是两人或多人之间的一种讨论，这种讨论具有三个特点：①高风险。②不同观点。③激烈情绪。
实际上，在面对关键对话时，我们可以有以下三种反映。 ● 我们会逃避关键对话。 ● 我们敢于面对，但往往处理不当。 ● 我们敢于面对，而且处理得当。
要么是逃避对话，忍受由此带来的不利结果；要么是处理不当，忍受由此带来的不利结果；还有一种可能就是圆满完成关键对话。
在我们的生活中总会有这样的时刻，无论出于何种原因，我们会表现得非常糟糕。我们会歇斯底里地叫喊，会畏惧退缩，会说一些事后让自己后悔的话。当对话变得最为关键时，即从普通交流升级为关键对话时，我们往往会出现这些糟糕的表现。
当普通对话变成关键对话时我们经常会犯错，是因为我们的情绪还没有准备好进行有效交流。
每当面对关键对话时我们便会下意识地采取人类面对危险时最原始的应对方式——暴力对抗或转身而逃，而不是采用机智的说服和友善的关注来解决问题。
当面对充满挑战的关键对话时，你的智力水平跟一只恒河猴差不了多少。你的身体准备应对的是一只剑齿虎的攻击，而不是老板、邻居或老公的批评指责。
还有一点就是，由于关键对话经常是自发形成的，很多情况下它们都是毫无征兆地出现。
这就是我们在面对关键对话时的真实状态——棘手的问题、不依不饶的对手、高度缺血的大脑和无法正常工作的思维。这就是为什么我们平素表现得正常得体，可面对关键对话时却会变成十足的白痴。
不知道该如何开始关键对话。
首先你必须清楚什么是正确应对的关键对话。
和大家一样，你会采取临场发挥的办法来应对问题。你会抓住对方的言论，形成某种情绪，然后在此基础上决定下一步该怎么行动——当然，这一切都是在你那严重缺血的大脑中完成的。
换句话说，你的行为非但没有解决问题，反而导致你面对更加严重的、不愿看到的后果。你陷入了一个充满不健康影响的、自我伤害的怪圈而无法自拔。
尽管一开始关键对话的风险并不高，但随着时间的推移和情绪的逐渐失控，对话者之间的关系开始急转直下，生活质量一落千丈——结果证明其风险非常高。
容易带来灾难性后果的关键对话场景包括以下几方面。● 结束一段感情● 和总是冒犯你或喜欢提建议的同事交谈● 让朋友还钱● 指出老板一些不对的做法● 向经常言行不一的老板提出建议● 批评同事的工作表现● 让室友搬走● 和前任配偶讨论孩子的监护权或探访权问题● 应对处于青春期的叛逆儿女● 指出队友违反承诺的表现● 探讨关于出轨的问题● 应对配偶严重的家庭暴力问题● 和喜欢打听小道消息的同事交谈● 做出不利的行为表现评价● 说服配偶的家人不要干涉夫妻问题● 提醒同事注意个人卫生
一次失败的关键对话，其影响力不但是灾难性的，而且是深远持久的。
凡是关系牢固的夫妻、稳定的职业、成功的企业或和睦的社区，无一不得益于这样一种相同的力量，即面对高风险、情绪化和充满争议的话题时公开探讨的能力。
我们发现那些富有影响力的个人（指既能应对棘手问题，又能巩固人际关系的人），是那些能娴熟应对关键对话的成功者。
无论是和自己的老板、同事或下属进行沟通，他们不但能让对方明白自己的观点，而且能让对方心服口服地接受，而不是表现出抵触感或愤怒感。
当项目范围和进度安排不合理时，他们能否直言不讳地和上级进行讨论？当其他部门的员工消极配合时，他们是否装作视而不见？当项目主管没有尽到管理和领导责任时，他们会做出怎样的反应？
他发现这些夫妻的行为模式可以分为三类：第一类是动辄以言语威胁对方，互相叫骂；第二类是沉默寡言，在内心蓄积不满和怒火；第三类是开诚布公、彼此尊重、就事论事。
当我们长期挣扎于不健康的对话方式时，我们内心郁积的负面感受、我们承受的痛苦情绪以及我们忍耐的打击煎熬，最终会慢慢摧垮我们的健康。
不管怎么说，失败的关键对话从来不会让我们感到快乐、健康和内心安宁。
当结果充满风险、观点背道而驰、双方情绪激烈时，普通的对话便会升级为关键对话。
事实证明，逃避对话或是把对话搞砸都会带来非常严重的后果。当我们无法正确处理关键对话时，生活中所有重要的方面都会因此受到不利影响，包括我们的事业、圈子、人际关系，甚至是我们的身体健康。
第2章 掌握关键对话 当我们面对重要问题保持沉默时，我们的生活便开始上演悲剧了。
要想找到成功的秘密，我们必须首先从工作场合谈起。
第3章 从“心”开始如何确定目标 怒不可遏时的话语是最令人后悔的表达。
如何展开关键对话。
对不同的看法和激烈的情绪，怎样做才能鼓励对话双方观点的自由交流呢？</description>
    </item>
    
    <item>
      <title>心流：最优体验心理学</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E5%BF%83%E6%B5%81%E6%9C%80%E4%BC%98%E4%BD%93%E9%AA%8C%E5%BF%83%E7%90%86%E5%AD%A6/</link>
      <pubDate>Wed, 28 Sep 2022 14:11:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E5%BF%83%E6%B5%81%E6%9C%80%E4%BC%98%E4%BD%93%E9%AA%8C%E5%BF%83%E7%90%86%E5%AD%A6/</guid>
      <description>米哈里·契克森米哈赖
序一 自造内心秩序之途 人类性交为何这么短促？完成配种就够了，沉溺其中极可能成为天敌的点心。
人类与动物的最大差别在于神经系统过于发达。感知和摄取更多的信息，无疑有利于人类生存。对外部情况不感知，当然更危险，但感知更多往往也更苦恼。
序三 胜利者一无所获 激情后是空虚，大战后催生反思。
海明威认为战争胜利者丢失了人类最美好的那些事物：爱、善良、洁净、次序等，胜利者一无所获。
有些人生活着，但是什么感觉也没有，他知道一切都是空虚、空虚、空虚。我们的空虚就在空虚之中，空虚是你的名字，空虚是你的国度；你是空虚中的空虚，就像空虚本来就出在空虚中一样。
不在空虚中胜利，就在空虚中败退。
人是由无意识支配的动物，
活着就是不断摆脱自卑感追求优越的过程
幸福的真相是什么？人生的意义是什么？
为什么人们会专心致志，浑然忘我？
心流（Flow）。之后，他在“心流”概念基础上，创建了人类的最优体验（Optimal Experience）理论。
什么是心流？
心流处在技能适中、挑战适中的理想区域。
写作是在情绪紊乱中塑造秩序的一种治疗法。
一位骄傲的作家用字与词创造一个令人沉浸的世界。在这个过程中，他不断挑战自我。
在这个硬汉世界中，他是唯一的君王。直到有一天，世界失控，沙堆崩溃。
当你全力争取胜利时，其他就不那么重要了；甚至，连胜利本身都不重要。
胜利者的奖赏就是自己的兴趣、享受与内在满足。如果没有奖励，这个时候，会发生什么？你沉浸于事物本身，这就是心流。
攀岩的神秘就在于攀登本身；你爬到岩顶时，虽然很高兴已大功告成，而实际上却盼望能继续往上攀登，永不停歇。攀岩的最终目的就是攀登，正如同写诗的目的就是为写作一样；你唯一征服的是自己的内心……写作就是诗存在的理由。
爬山除了爬山之外，没有别的理由，它完全是一种自我的沟通。
刻意练习与普通练习的不同之处在于：（1）一个定义清晰的目标；（2）全神贯注及不懈努力；（3）即时的、有益的反馈；（4）持续反思和完善。
心流是体验，刻意练习是行为；刻意练习发生在技能准备阶段，而心流体验发生在技能表现阶段。
心流的本质是令人沉醉与上瘾的，在心流体验中，你会忘掉时间，并且不在意是否提升了技能。
人生也是空虚。但在那虚无的人生中，会有一间干净明亮温暖的小酒馆。它来自感官之乐、思维之乐、人际之乐、工作之乐。我歌月徘徊，我舞影零乱；举杯邀明月，对影成三人。在那里，你，邀请你的影子，外加月亮，且打来二两心流，酌言尝之。
序四 契克森米哈赖的幸福课 你是否曾经埋头钻研一个问题，忽略了时间的流逝？你是否曾经全情投入到一件事情之中，忘记了自己？
经常经历“心流”，就是优秀的人的一个共同特征。
所谓“心流”，就是当你特别专注地做一件目标明确而又有挑战的事情，而你的能力恰好能接住这个挑战时，你可能会进入的一种状态。它的特征是你做这件事的时候会忘记自己，忘记时间的流逝，你能体察到所有相关的信息，不管工作多复杂你都毫不费力，而且有强烈的愉悦感。
心流的前提是我们要主动关闭大脑的前额叶皮层的一部分功能，心流的过程是大脑分泌“去甲肾上腺素”和“多巴胺”等六种激素，不断深入，心流的愉悦感也来自这些激素
心流不再仅仅是人脑这个黑盒子的外部表现，而是有了实实在在的大脑硬件工作原理的解释。
心流，可以说是刻意练习的一个结果。
在注意力不集中的情况下，我们的大脑大部分时间处于所谓“默认模式网络”，这种状态是发散思维和创新的必要条件。
心流只是一个方法，它背后更大的逻辑是，你要通过锻炼控制自己的意识，去获得真正的幸福。
我们做事的时候并不在乎结果能不能给自己带来多大的利益，而是专注于做这件事本身，从中获得乐趣。
真正的幸福，是当你全心全意投入一件事，把自己置之度外的时候，获得的副产品。你直接追求的并不是幸福，而是把自己变得更复杂——在这个变复杂的过程中，你会找到乐趣，这个状态就是幸福的。
人生要的不是最后终点的结果，而是每时每刻点点滴滴成长的过程。
成长也不是为了达到什么目的的手段。成长本身，就是我们的目的。
爱到最高点 性本来就是除了求生与吃喝之外，最能给人满足感，且动作最强烈的一种经验。
所谓“爱使世界运转”，事实上就是说，人类行为直接或间接都靠性需求来推动。
强暴与两情相悦的结合在肉体上可能相去不远，而在心理上的效果却有天壤之别。
我们天生就能从性爱中得到快感，这是自然界促使个体从事繁殖、保障物种延续的妙法。
把对方当作独一无二的人，了解对方、帮助对方、完成对方的目标，从中发掘乐趣。
恐怕人类跟大多数哺乳动物一样，并非天生奉行一夫一妻制。
如何维持爱情的新鲜感？答案跟其他活动一样。双方关系要乐趣盎然，复杂性一定得提高；而要增加复杂性，双方就得不断在自己和对方身上寻求新的潜能。
重要的是大原则：性跟人生的其他层面一样，只要我们愿意下功夫去控制它，增强它的复杂性，它就会变得更有乐趣。
第七章 工作之乐 人跟其他动物一样，大部分时间都花在谋生上，身体需要的卡路里不会自动出现在餐桌上，房子和车子也不会自动组合供你使用。
工作可以使一个人高贵，也能把他变成禽兽。
一方面良好的工作需要高度的技巧，并能提升自我的复杂性；另一方面，被迫做不需技巧的工作，往往造成精神熵。
两种都是工作，但脑科大夫每天都有机会学习新事物，知道一切都在自己的控制之中，可以完成艰巨的任务；奴隶却只能重复令人疲惫不堪的动作，一天天越发觉得自己的处境不可能改善。
工作与爱。
一个人能在工作与人际交往中找到心流，就已踏上改善生活品质的正途了。
工作的乐趣 文明社会与原始社会差别的象征——金字塔、万里长城、泰姬陵，还有古代完工的许多寺庙、宫殿、水坝，通常都由奴隶建造，实现的则是统治者的野心，无怪乎工作会变得恶名昭彰。
工作能带来乐趣，而且往往是人生最有乐趣的一部分。
寂寞之苦 很多人孤单而又无事可做时，会产生一种无法忍受的空虚感。
几乎所有的活动都是“独乐乐不如众乐乐”，
最令人沮丧的倒不是独自工作或独自看电视，而是独自一个人并且无事可做。
独处的体验为何如此受到否定？最根本的答案是：内在维持心灵的秩序十分困难。我们往往需要外在的目标、外来的刺激、外来的回馈，帮助我们控制注意力的方向。如果缺乏外来的力量，注意力就开始游荡，思路也变得混乱—
无所事事的时候，心灵就无法遏制消极念头的来袭。除非学会控制意识，否则成年人也会被类似的情况困扰。</description>
    </item>
    
    <item>
      <title>拆掉思维里的墙：原来我还可以这样活</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E6%8B%86%E6%8E%89%E6%80%9D%E7%BB%B4%E9%87%8C%E7%9A%84%E5%A2%99%E5%8E%9F%E6%9D%A5%E6%88%91%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E6%B4%BB/</link>
      <pubDate>Wed, 28 Sep 2022 14:11:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E6%8B%86%E6%8E%89%E6%80%9D%E7%BB%B4%E9%87%8C%E7%9A%84%E5%A2%99%E5%8E%9F%E6%9D%A5%E6%88%91%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E6%B4%BB/</guid>
      <description>古典
你是“没兴趣”，还是“感兴趣” “没兴趣一族”好像从来就没有什么特别爱好，也没有什么特长，他们什么都一般般。
让一些人拥有用不完的精力和好奇心，什么都优秀
兴致勃勃地投入一个又一个冒险中，他们经历丰富，收获很多，当然失败也很多。
对什么都提不起兴趣，只有到不得不行动的时候，他们才被迫抱怨着进入，他们失败很少，也尝试得很少，因为他们觉得那个没有什么意思。
投入的快乐是无条件的 兴趣（interesting），来源于拉丁文词根“inter”，在……之间，后面加上了代表最高级的“est”和代表当下的“ing”。
兴趣就是让你自己完全身在事物其中。当你真正完全投入到当下的事情中去时，不管这个事情多么简单卑微，你都能感受到无穷的乐趣。
饥来吃饭困来眠。
他吃饭时不肯吃饭，百种需索，睡时不肯睡，千般计较，所以不同也。
吃饭的时候吃饭，喝水的时候喝水，那就是禅。可惜大部分人不是这样，我们在吃饭的时候想着工作，在喝水的时候又想着吃饭，在工作的时候想着出错，在恋爱的时候担心分手，在拥抱的时候还在看表……
这些人都是不敢投入的“无兴趣一族”
他们总在思考“读这本书，有什么用处？“
当下的投入带来快乐。
我开始多一种让自己快乐生活的方式，我觉得我在魔术方面也很有天赋呢！而且这让我自信心膨胀。
现在我们对投入有了下面的理解：
尝试是有可能成功，有可能失败的。 成功的尝试能收获到成果。 不成功的尝试能收获到智慧。 不管成不成功，投入都能带来快乐。 既然这样，为什么不停止你内心对后果的担忧，投入一些呢？ 不递简历也能入职的八种求职法 你会惊喜地发现，如果你勇敢尝试，大概有20%的人会接受你的访谈。
对于我这样一个人，如果要进入这个职业，您会给我什么建议？”“什么时候我会知道我能够胜任这份工作？”
3个月以后，她带着她的简历、这3个月中针对要求积累的案例，过来应聘这家公司。
如果万一写砸了怎么办？那也无所谓，反正名人都很忙，过一个月就把你忘了。你换个网名继续写，写到他认识你为止。
你说谁牛逼？
同学对于工作的帮助实在是太大了。
这里的面试官和蔼可亲，面试环节超长，机会超多，而且面试者只有你一个。
他们会给你提供其他行业的工作机会，这样的机会往往可遇不可求，所以俱乐部只是提供你的工作的可能性的方式。
以共享而富足
如果你真的找不到一个工作，那就自己创造一个吧！
是谁在让你不开心 是生活，还是自己？是谁在让你不快乐？
外界、别人来掌控我的生命，导致我现在的状态。
受害者习惯把痛苦和快乐放在别人手上，有的时候是家人上司，有的时候是朋友同事，还有的时候是过去的自己。
不管外界怎么样，我都有能力对自己的状况负责。这种人总能找到当下更好的方法，因为他明白，不管外界怎么样，下一步的生活，都是他们自己的！
受害者，掌控者，你的大脑中，安装了哪种模式？
所以他们花了很多的时间和金钱，从一个地方换到另一个地方，从一个人换到另一个人，却从没有更加幸福过。他们真正需要的，是拆除自己内心的痛苦按钮，成为一个自我掌控的人。
Waiting for life is waiting for death 上帝不需要你成功，他只需要你尝试 因为贵，所以好吗——价格与价值这笔账 件事情有价值，也有价格。价值来自于内在系统，价格来自于社会系统。
价格是来自统一规定的，每一个小体系都有自己的规定。
没有价格，就没有规矩，社会就不会有进步。
价值是来自内心的感受，每一个人都有自己的价值系统
价值让人感到生活的意义，让人活得幸福。
关键是不是适合你的内心，你要清晰地知道，你要什么价值。
聪明人根据价值选择合适的价格，蠢人则通过价值选择不合理的价格。
价值的世界是多维的，但是价格的世界却只有一维——这样的世界没有了可能性——当世界出现唯一一条坐标轴，则意味着世间所有的人和物瞬间各就各位，每一个东西都有其明确的坐标。
你所追求的，真的是你需要的吗？
价格让我们的生命变得狭窄，变得无路可走，变得无法突围，让壮丽辽阔的生命草原成为狭窄压抑的下水道，让我们从站着走路，变成跪着钻营的人。
这个世界还有很多有脑有心的人，他们总有一天会停下脚步，走入属于自己的小道，享受与众不同的生活。
工作是不能用钞票算的 我们干这么多年，都比不过两次拆迁，那么我们这么多年奋斗到底为了什么？我们又用什么方式来教育我们的孩子呢？
在普通的职位上面活出自己生命的意义。
感情是不能放在秤上面称的 自尊自爱，忠于内心吗？
感情是不能够放在秤上面称的。
有很多东西属于幸福系统：梦想、爱情、成就感、贡献……这些东西是无法用成功系统的东西来量化的。
幸福不是用来讲的——口是心非原则 但是这群人不约而同地都会玩一个游戏，就是先把自己损一遍，然后再狂夸一顿别人，然后享受别人更加猛烈的夸奖。
你看一个人觉得自己缺什么，你就看他不断强调什么就好了。</description>
    </item>
    
    <item>
      <title>西方哲学简史</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E7%AE%80%E5%8F%B2/</link>
      <pubDate>Wed, 28 Sep 2022 14:02:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E7%AE%80%E5%8F%B2/</guid>
      <description>伯兰特.罗素
苏格拉底之前的哲学家 希腊人对纯粹知识的探索和成就都非常伟大，现代的数学、科学与哲学都是起源于希腊；
泰勒斯
由于最初的科学实际上是包括在哲学中的，因而科学也同样诞生于公元前六世纪初。
象形文字是用图像来表意，至今中国还在使用这种文字。
西方的象形文字演变成了字母。
多神教
公元前四十世纪末到公元前三十世纪初，埃及的国王们兴建了金字塔群。之后的埃及文明停滞不前，主要原因是宗教的保守主义。
闪族人
同古代宗教一样，埃及与巴比伦的宗教也是生殖崇拜。
巴比伦的大地女神伊什塔尔在女神中地位最高
希腊殖民者为她建筑神殿，称她为阿尔蒂米斯，也就是后来的女神狄阿娜。基督教把这个形象塑造为玛利亚，也就是后来的“圣母”。
掠夺不是长久之计，于是商业开始发展。
人们认为富人在信仰方面不虔诚，在政治方面又阻碍民主制。
伯罗奔尼撒战争
人是衡量万物的尺度，存在的事物以人为尺度，不存在的事物
不存在尺度。
论
先是在世纪初领导诸城邦打败波斯，取得盟主地位，世纪末又被斯巴达打败。
教父 天主教哲学是指奥古斯丁至文艺复兴之间十个世纪内的宗教哲学。
关于中世纪，我们要讲的不止是它的哲学方面，其他方面也要讲，尤其是教会的权力。
教会的基础是教义，教义则是由哲学与宗教历史两部分组成。
统治者与教会的斗争都以失败告终，根本原因是这些统治者也是教徒。
他们的传统与野蛮没有用哲学的方式体现出来。
但丁是第一位了解哲学，并写书的世俗人。
我们要想了解中世纪的思想，就必须了解教会的发展历史。
中世纪与古代世界相比，最重要的特征是二元论
在天主教哲学的最初阶段，占统治地位的是奥古斯丁，异教徒则崇拜柏拉图。
圣托马斯·阿奎那
富商阶级
富商阶级智慧、亲民、民主、自由，受到了城市中下阶层的拥护。他们帮助教会击败
国王，同时从教会手中解放了经济。
给予中世纪最后一击的是文艺复兴与宗教改革，他们彻底瓦解了中世纪的思想体系。
中世纪时期，人们一边忍受着深刻的苦难，一边期盼着美好的来世。
天主教哲学是一个组织的哲学，这个组织便是天主教会。
基督教从一开始就对上帝和凯撒，也就是宗教与国家都尽忠，这是非常独特的。
犹太教将犹太人团结在一起，但同时让他们变得保守。
公元一世纪之后，随着耶路撒冷沦陷，犹太教变得狭隘起来。此时，兴起的基督教与犹太教之间彻底对立。在信仰基督教的国家中，犹太人没有任何地位。
教会创造了一个稳
固的体制，为学术和文艺的复兴提供了基础和温床。
一是修道运动；二是大格里高利统治下的教廷的影响；三是通过布教使蛮族改奉基督教的运动。
安东尼的隐士
这主要是因为不能区分哪个是真诚的苦行僧，哪个是贪图修道院舒适的生活才做了修道僧的；还有一个原因，即修道僧往往以狂烈的方式支持他喜爱的主教，使得宗教会议陷入异端。
任何组织一旦创立就很难以缔造者的意志为转移，因为它们已经具有了自己的生命，
查士丁尼对未来产生深远影响的是他的法典，本尼狄克对未来产生深远影响的是他的教规，而大格里高利对未来产生深远影响是因为他使教会的权利变大了。
从文艺复兴到休谟 教会威信的下降和科学威信的上升是最重要的两点，其他的不同都与这两点相关。
直到1543年哥白尼学说的发表才使得科学与教义进入了长期的斗争阶段。
科学的重要性首先表现在战争方面，科学家在战争中起的作用越来越大，比如伽利略和雷奥纳就是因此被重用的
教会威信衰落以后，个人主义逐渐发展到了无政府的地步
意大利在十五世纪时，道德和政治上都陷入了混乱，因此艺术和文学上便有了惊人的表现，很快，这种不稳定的社会便被宗教运动终止了。
近代哲学保留了大部分个人主义和主观倾向。
目前来看，现代世界似乎正试图通过暴力强加给人一种代表权贵们意志的社会秩序。
教会的腐败有目共睹，但人们却毫无办法。
为获得这种成就，我们还要忍受多少混乱？过去我们情愿忍受许多，现代却少了很多。社会组织的扩大使这一问题变得重要起来了，但到今天为止，我们还没有找到解决之道。
马基雅维利的政治哲学是科学性的经验哲学，并不谈论目的是善意的还是邪恶的这一问题，只说明为达到目的应该采用的手段。
众所周知，力量依靠
舆论，舆论凭借宣传，在宣传上比敌人显得更有道德是表面上的优势，显得有道德的方法是真的有道德。
胜利其实往往掌握在公众认为最有道德的一方。
所有东西都归公有，没有共产制度就没有平等。但莫尔还是反对说，共产制度会让人变得懒散，
乌托邦的政体是采用间接选举制的代议民主制，最高领袖是终身制的，但人民有权废黜他。
《乌托邦》一书的很多观点带有惊人的进步性，这主要体现在它关于战争、宗教自由、反对杀害动物和赞
成宽大刑罚方面
乌托邦里的生活好像也很单调和枯燥。这恐怕是一切计划性制度的共同缺陷。
宗教改革是德国的运动，而反宗教改革是西班牙的运动。
来越多的人厌倦了宗教争斗，便开始注意研究数学和自然科学等现世学问。
科学是近代世界与以前世界所有差异的根源，在十七世纪取得了极大的成就。从思想方面看，十七世纪才是近代社会的开始。
要理解近代</description>
    </item>
    
    <item>
      <title>每一个不曾起舞的日子，都是对生命的辜负</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9B%BE%E8%B5%B7%E8%88%9E%E7%9A%84%E6%97%A5%E5%AD%90%E9%83%BD%E6%98%AF%E5%AF%B9%E7%94%9F%E5%91%BD%E7%9A%84%E8%BE%9C%E8%B4%9F/</link>
      <pubDate>Wed, 28 Sep 2022 14:02:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9B%BE%E8%B5%B7%E8%88%9E%E7%9A%84%E6%97%A5%E5%AD%90%E9%83%BD%E6%98%AF%E5%AF%B9%E7%94%9F%E5%91%BD%E7%9A%84%E8%BE%9C%E8%B4%9F/</guid>
      <description>尼采
序言 1844年10月15日，弗里德里希·威廉·尼采出生于普鲁士萨克森州勒肯镇附近洛肯村的一个乡村牧师家庭。
1861年17岁尼采患严重疾病，首次出现健康恶化的征兆，被送回家休养。
他偶然地在一个旧书摊上购得了叔本华的《作为意志和表象的世界》一书。
叔本华是这个青年心中的偶像，他在以后也被认为是叔本华唯意志论的继承者
1869年2月，年仅25岁的尼采被聘为瑞士巴塞尔大学古典语言学教授。
1869年4月，尼采获得了瑞士国籍，从此成为瑞士人。
1879年，尼采辞去了巴塞尔大学的教职，开始了十年的漫游生涯，同时也进入了创作的黄金时期。
1883年，他完成了《查拉图斯特拉如是说》的第一、第二部分，1884年完成了第三部分，1885年完成了最后一部分。
在尼采发疯的前夜《瓦格纳事件》、《偶像的黄昏》、《反基督徒》、《看那这人》、《尼采反驳瓦格纳》一气呵成。它们写得标新立异，很有深度。但同时这些书也具有闻所未闻的攻击性和令人瞠目的自我吹嘘。
长期不被人理解的尼采由于无法忍受长时间的孤独，在都灵大街上抱住一匹正在受马夫虐待的马的脖子，最终失去了理智。
1900年8月25日，这位生不逢时的思想大师在魏玛与世长辞，享年55岁。
第一编 我●自我 首当其冲，便是认识自己，千万要努力求索。
现在以自己的方式活着，乃至接下来的每一个瞬间都依照这个方式，就算是永远按照自己的方式生活也心甘情愿。
别小看上天赋予你的能力。相信自己，通过学习来不断地完善自己。
内心强大的人，才是真正有思想的人，才能真正无所畏惧。
世间之恶的四分之三，皆出自恐惧。
恐惧让你为经历的事苦恼，为未曾经历的事害怕。
因为心是你自己的。
获得真正自由的方法是要学会自我控制。
那些精神自由，保持独立思考的人也正是擅长于控制自己情绪的人。
如果我们连自己都不爱，又怎会去爱别人。
对自己是个什么样的人，喜欢什么，想要什么，会做出怎样的反应要有清楚的了解。
什么才是你的挚爱？什么使你感到满足、灵魂得到升华、内心充盈？什么才是真正能吸引你的东西？这就是为你探寻自我之路铺设的指南，试着去回答就能发现真正的你。
即使你的后面没有任何追随者，没有一个朋友知己，此处只有孤零零的你，也请不要胆怯。
能来到这里的人只有你。然而这里也并非目的地，仅仅是中途而已。继续向前走吧，哪怕那是未曾有人去过的地方。 因为荒无人烟的沙漠还远远没到尽头。
决不可糊弄自己，自欺欺人。要对自己永远诚实，了解自己究竟是什么人，究竟有着怎样的癖好，拥有怎样的想法，做出怎样的反应。
1 人的内心 生活如镜首当其冲，便是认识自己，千万要努力求索。
内心强大的人，才是真正有思想的人，才能真正无所畏惧。
获得真正自由的方法是要学会自我控制。
什么才是你的挚爱？什么使你感到满足、灵魂得到升华、内心充盈？什么才是真正能吸引你的东西？
这就是为你探寻自我之路铺设的指南，试着去回答就能发现真正的你。
要对自己永远诚实，了解自己究竟是什么人，究竟有着怎样的癖好，拥有怎样的想法，做出怎样的反应。
你不必费心去寻找内涵丰富的事物，而是要充实你自己。
不招人妒是庸才。
如果你想成为恒星，应该不计较地照耀他们！
小心防范那些爱你的人们！为你戴上打着爱的名义的镣铐。
你可能遇到的最大敌人其实是你自己。
你应该准备自焚的火焰，如果你不化为灰烬，那怎么重生？
第四编 心理●反观 对手其实也可以成为你向前的永恒力量。 第七编 爱●幸福 爱不仅仅是感觉，爱的本质是行为。
应该爱对方，但该把自己放在前面。
亲密温柔地交往，但是要小心把握尺度。
共同生活，共同经历种种可能，一起流泪欢笑，分享生命中的时光。
第八编 生活●美 我在等待：可是我等待什么？
保持乐观是个聪明的选择。怀揣乐观面对一切，这是人生最伟大的事。
工作既能让我们远离罪恶、无聊，又能给我们带来疲惫和相应的报酬。
才华横溢的人是自己才能的牺牲品。
导出于 2022-09-28 14:02:07</description>
    </item>
    
    <item>
      <title>人生的智慧</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/</link>
      <pubDate>Wed, 28 Sep 2022 14:02:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/</guid>
      <description>叔本华
引言 幸福并非易事：她既不能从自身求得，亦不可能从他处求得。
如何尽可能幸福、愉快地度过一生。
幸福论
如何获得幸福的生存？
我们离开世界的时候，这个世界仍然像我们来到这个世界时一样愚蠢和丑恶，没有任何变化。
基本划分 人生所能获得的益处分为三种：外在之物，人的灵魂以及人的身体。
决定人命运的根本差异分为三类
一个人的幸福，乃至他的整个生存方式，最根本的就在于他自身的内在素质。
一个人生活在什么样的世界中，首先是由他对世界的理解决定的，世界由于不同的头脑和精神而呈现出不同的面貌。
一个人在他人心中的价值是由他所拥有的财产决定的。
人是什么 对于人的幸福来说，人的自身要比他所拥有的财产或在他人眼中的表象更有意义。
一个人本质上如何，亦即他自身所拥有的东西才是最重要的，因为自身个性是伴随人一生的，他所感受到的所有东西都受到他的个性的影响。
他经历任何事情时，感受到的首先是他自身。不论是从物质上获得的乐趣，还是从精神上获得的乐趣都是如此。
我们所能仰仗的只有自己的本性，而非金钱。
总而言之，就是“健康的身体和健康的灵魂“。
一个人之所以愉快的原因是：他自己是一个愉快的人。
建议和格言 我只把自己想到的，可能值得告诉读者的内容写下来。
理性的人追求的并非快乐，而只是避免痛苦。
一切快乐的本质都是具有否定性质的，而痛苦则有着肯定性质的本质。
如果我们意识不到自己身体整体上的健康，而只是关注疼痛的伤口，那么我们就会因为这一小块伤口而失去了总体上的舒适感。
我们的意欲都受到了损害。
意欲客体化存在于人的机体中。
意欲客体化则存在于人的渴望当中。
意欲的满足总是否定的。
每一种快乐其实都是意欲受到的限制被消除后，意欲得到解放而产生的。因此，任何快乐持续的时间都非常短。
不应该把生活的愉悦和快乐当成追求的目标；而是应该努力避开生活中各种各样的灾祸。
快乐只是一场梦，而痛苦却是真实的。
“幸福的生活”实际上应该解释为“避免了很多不幸的生活”，也就是可以勉强忍受的生活。
生活并不是用来享受的，而是需要忍受和克服的。
一个人最幸运的就是一生中没有遭受过巨大的精神痛苦或肉体痛苦，而并非曾享受过多少强烈的快乐。
判断一个人的生活是否幸福，要看他缺乏痛苦的程度。如果完全没有痛苦，也并不无聊的话，就是世上真正的幸福，其他一切都是虚假的。
我们没有感到痛苦的时候，欲望就会蠢蠢欲动，向我们展示出各种虚幻的快乐和享受；
真正的、最大的幸福就是没有痛苦的状态。
一个努力避免灾祸的人是有着明确目的的，而一个总希望获得优于自己所有的东西的人却是盲目的。
更好是好的敌人。
没有什么东西是属于我们的，一切都掌握在命运的手中，它不但以无可争辩的权利掌握着我们的财产、妻儿，而且还掌握着我们的手脚、耳目、脸中间的鼻子。
幸福和快乐只是清晨的薄雾，只能远观，一旦走近它就会消失。
痛苦和磨难则是具体而真实的。
我们就能够明白这个世界能够带来的最好的事物，就是一种没有痛苦的、安宁的因而可以勉强忍受的生存而已；
最可靠的避免不幸的方法就是不追求很幸福。
我们对幸福过分的渴求毁了生活中的一切，我们渴望的程度就决定了毁坏的程度。如果一个人抛弃了过分的期待，在自己拥有的东西之外不再渴望更多，那么他就能平安顺利地生活下去。
没有任何人、任何事值得我们过分关心。
如果你失去一个世界，不要感到悲伤，因为这并不重要；如果你得到一个世界，不要感到高兴，因为这并不重要；痛苦、欢乐、获得、失去都是过眼云烟都会从这个世界消失，因为这些都不重要。
人生的各个阶段 我们在一生中都只活在此刻当下。
生命初始，我们面对的是遥远的未来；但当走到生命的终点时，我们看到的却是身后那漫长的过去。虽然我们的性格并没有改变，但我们的心境却有了明显的变化。
童年时期，我们的状态是认知大于意欲。
童年时代，我们的关系很窄，需要的也很少，亦即，我们很少受到意欲的影响，我们生命的大部分精力都用于认知活动了。
童年时期世界中的一切都新鲜而富有魅力。
从永恒的角度观看人和事。
年轻时对事物的印象与年老时对事物的印象之间差异巨大。
对于事物真正本质的认识——这正是知识的真正内容——并不能从概念知识中获得，而是存在于我们对这个世界所进行的直观把握中。
任何教育灌输都没办法给予我们这样的直观认识，而只能通过我们自身获得。
导出于 2022-09-28 14:02:02</description>
    </item>
    
    <item>
      <title>哲学，为人生烦恼找答案</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6%E4%B8%BA%E4%BA%BA%E7%94%9F%E7%83%A6%E6%81%BC%E6%89%BE%E7%AD%94%E6%A1%88/</link>
      <pubDate>Wed, 28 Sep 2022 14:01:49 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6%E4%B8%BA%E4%BA%BA%E7%94%9F%E7%83%A6%E6%81%BC%E6%89%BE%E7%AD%94%E6%A1%88/</guid>
      <description>黄珍奎
前言 “追”救了我们 拯救我们的并非那为了实现目标的手段，而是成为目标本身的“它”。 序 将哲学变成工具的方法 哲学分为从幸福得到灵感的感情哲学、从知识得到灵感的理论哲学、从行动得到灵感的实践哲学。
感情哲学”是回答“人生是幸福的，还是不幸的？”或“人生要如何才能得到幸福？”这些问题，是关于幸福的哲学。
是重视知识，具备一套自己的体系，是一种关于理论的哲学。凡是具有伟大体系的哲学大多都属于这类。
将知识用于实践生活非常重要，是重视行动的哲学。
对实践哲学而言，知识只是用于帮助实践成功的工具之一。
我们需要的是感情哲学和实践哲学。
感情哲学和实践哲学就与“生活”息息相关。
我们必须询问自己“何谓幸福？”“如何才能得到幸福？”（感情哲学），以及“要采取什么行动才能得到幸福？”（实践哲学）。
这些“知识”可以给我们伤痕累累的“人生”带来什么帮助
如何在冷漠的世道中保护自己，尽可能减少那些无法避免的伤痛。
01 我们有办法摆脱成见和偏见吗 ——笛卡儿的“我思故我在” 如果辞掉工作，真的就活不下去了吗？天下的女人/男人全都一样吗？只要有钱，就一定能幸福吗？答案是否定的。
这种视觉上的错觉，正好显现出人类“知觉”（视觉、听觉、嗅觉、触觉）的不完整
进行思考和判断时需要情报信息，而我们是借由感官的知觉来获取所需的信息。若知觉有误，获取的信息也会跟着出错。在情报有误的情况下，不管再怎么思考和判断，都无法让意识完整。
视觉、听觉、嗅觉、触觉这些“知觉”的不完整，造成了思考、判断、信念等“意识”的不完整，这就是成见与偏见的主因。
多数人认为自己没有成见，也相信自己能够看见世界的真貌。
世上没有人可以完整认知“超越自身生活脉络之外”的事物
被成见与偏见束缚得多深，就有多不幸；而能够克服多少成见与偏见，就能得到多少幸福”。
我们又该如何克服既有的成见和偏见呢？这里有一个方法，就是“怀疑”。只要怀疑，学会从头怀疑自己深信的一切就行了。
怀疑这世上所有一切
对所有一切都必须持有怀疑。
笛卡儿先是推翻思维的所有基础，不仅是透过感官知觉的部分，连最确切、最肯定的一切，都被他视为怀疑的对象
笛卡儿认为哲学必须为不可靠的知识提供可靠的基础。
他认为想要抵达“可靠知识”这个目的地，就必须先确保踏出的第一步是“没有任何怀疑余地的”才行。
对笛卡儿而言，哲学绝对不能有误，哲学的出发点必须要显见又确凿才行，因此他坚信必须要普遍怀疑直到最后一刻。
但它究竟存在吗？这世上会有“在任何情况下都显见又确切”的东西吗？
若是站在怀疑论的角度来看，世上不会有确凿的东西
我
下定决心要认定那些进入我心绪内的所有东西，都和出现在梦中的幻影一样地不真实。我也因此发现：像这样认定所有一切都是虚假的我，必须得先是某种存在才行。由于“我思故我在”（cogito ergo sum）这项真理十分确切又可靠，任何一条怀疑论者的荒谬假定都不足以动摇它，因此我毫不犹豫地采纳它作为我寻求哲学的第一原理。
虽然可以怀疑世界上所有一切，但绝对不可怀疑的就是“正在怀疑的自己”
不管用什么方法，都不能怀疑正在“怀疑”的自己本身
当我们开始怀疑“我思”之外的所有一切，就已经在一步步地摆脱有如诅咒的成见
被誉为“现代哲学之父”，他给中世纪哲学画下了句号，并开启了现代哲学之门。而他又为何被称为“现代哲学之父”呢？
中世纪是以上帝为中心的时代，顾名思义就是“以上帝为父”，是个相信“神谕就是真理，世间万物都必须依照真理而行”的时代
我思考，所以我存在
人类并非因‘上帝’而存在，而是因‘理性’（思维）才会存在。
要我们勇敢地去怀疑那些“让我们熟悉且舒适的生活产生动摇”的东西。
一般来说，我们无法忍受推翻自己，因为这必然会让现在的生活变得陌生不便，甚至还可能因此陷入险境。
“拥有得少也是一种幸福！”“离开职场，就能看见全新的生活！”“爱情可以使人改变！
我们也必须勇敢地去怀疑那个熟悉、舒适又平稳的生活，还有将这种生活合理化的所有一切。
“严格怀疑的态度”以及“拒绝依附权威的态度”
03 做喜欢的事情可以成功吗？ ——斯宾诺莎的“自我完善力” 而我们常说的“成功”，其实网罗了各种不同的含义。
成功其实就是“达到自己向往的人生状态
依照世人的说法，只要与不喜欢的人共处，忍受自己讨厌的工作，在克服了所有的一切后，就能赚大钱、获取名声，甚至是拥有圆满的家庭？或是至少还能混口饭吃？又或是要按照那些喜欢妥协的人所说，为了做自己喜欢的事情，就得先忍受自己讨厌的事？
“压抑自己喜欢的事物，对讨厌的事情忍气吞声，就能达到所谓的‘成功’吗？
哲学家斯宾诺莎主张“神即是自然”的“泛神论”，以及精神与肉体合一的“一元论”（平行一元论）
笛卡儿主张理性与心灵的重要性，斯宾诺莎则是早早就指出了感性与欲望的重要性。
所谓欲望，就是在可掌握的范围内，依据人类本质原有的情感，决定该做什么事情的人类本质。
“当然有成功的可能，所以就顺着自己的感觉和欲望行动吧！
事物想让自己的存在延续下去的努力（自我完善力），除了是它现实上的本质之外，什么都不是。
所有的事物都是为了“让自己的存在延续下去而不断努力”，这就是所谓的“自我完善力”。
自我完善力正是所有事物的本质，而且它不仅存在于物体，也存在于人类身上。
当这样的努力（自我完善力）与精神相关时，就称为“意志”；与精神和肉体同时相关时，就称为“冲动”，所以冲动只是人类的本质，而那样的本质必会对人类求生做出贡献，因此人类便决定采取那些行动。
自我完善力在人类的精神上称为“意志”，对于具备完整精神与肉体的人类来说，称之为“冲动”。若“冲动”听起来过于模糊，不妨将它理解为“欲望”。
为了让自己的存在延续下去，我们会对食物和水产生“意志”，以及想要摄取它们的“冲动”（需求）。
他把人类对于食物和水的“意志”定义为仅存于脑中的想法，而对于食物和水的“冲动”，则是由身体的行动所体现。
自杀可说是失去自我完善力，是在极度无力的状态下所产生的结果。</description>
    </item>
    
    <item>
      <title>邓小平时代</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3/</link>
      <pubDate>Wed, 28 Sep 2022 13:57:28 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3/</guid>
      <description>傅高义
第2章　放逐与回归，1969—1974 问题是如何对待毛泽东在群众中培养出来的对他的敬畏，那些被他毁掉一生的人对他的仇恨，以及很多党内干部对他犯下错误的严重程度的认识。
中国领导人应当颂扬毛泽东，继续尊敬他
此时此刻，其实只有一个人能管好党和政府，而且由于多年磨炼，他也不会威胁到毛的地位，此人就是周恩来。
尽管毛泽东疾病缠身，被林彪事件搞得心烦意乱，但他仍然左右着手下人的命运。
毛泽东熟谙千百年来中国统治者如何处理继位的问题，并利用了这些知识谋划自己的战略。他的做法是，先不把话说死，对自己的意图给出暗示或信号，静观其变，既维持着自己的决策权，又能随时改变主意。
会不会批判“文革”，撤掉毛泽东任命的关键人物，让毛的错误任由历史评说？￼整个1973年，毛泽东一直紧盯着邓小平的表现。
第23章　转型的中国 自由划定界线，使其既能满足知识分子和一般民众的要求，又能让领导人维持社会秩序。
毛泽东靠打赢内战，赶走外国帝国主义和统一全中国取得了统治的合法性。邓小平获得合法性，靠的是在“文革”的混乱之后恢复秩序，以务实的方式处理国家面临的严重问题，实现了经济的高速增长。在这个新的时代，邓小平的接班人该如何建立自身的合法性呢？
邓小平的接班人受到压力的原因是，他们没有更加成功地阻止腐败的泛滥，也没有为解决不平等问题采取更多的措施。
中国领导人必须从经济增长以外寻找合法性来源，抓紧在解决某些公众最关心的问题上取得进展：减少腐败和不平等，提供合理水平的普遍医疗和福利，想办法证明在选拔官员时是尊重民意的。
他改善了中国与每一个重要国家的关系。
中国绝不称霸，如果中国压迫和剥削其他国家，全世界，尤其是发展中国家，可以把中国视为“社会帝国主义”，与中国人民一道推翻它的政府。
中国绝不应当称霸，干涉别国内部事务，应当与各国保持和睦关系，要集中精力搞好国内的和平发展。
导出于 2022-09-28 13:57:28</description>
    </item>
    
    <item>
      <title>傻瓜式投资（雪球岛系列）</title>
      <link>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E5%82%BB%E7%93%9C%E5%BC%8F%E6%8A%95%E8%B5%84%E9%9B%AA%E7%90%83%E5%B2%9B%E7%B3%BB%E5%88%97/</link>
      <pubDate>Wed, 28 Sep 2022 13:18:52 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E5%82%BB%E7%93%9C%E5%BC%8F%E6%8A%95%E8%B5%84%E9%9B%AA%E7%90%83%E5%B2%9B%E7%B3%BB%E5%88%97/</guid>
      <description>飞泥翱空
雪球“岛”系列电子书出版序 岛是没有意义的，除非别的岛可以到达它。 信息是没有意义的，除非别的信息可以链接它。 只有当信息与信息链接起来，我们才知道它是真是假，存在着怎样的偏颇与疏漏。 链接信息与信息的最好办法是互动。
互动是美好的，它让我们展现自己的智慧，分享别人的智慧。 互动也是惨烈的，它让我们发现别人的愚昧和偏见，也让我们发现自己的愚昧和偏见。前者可能让人不悦，后者可能就让人愤怒和绝望了。
雪球，信息不再孤岛，投资不再孤单。
第一部分围绕“傻瓜式投资，简单50：50策略”为核心，阐述了一种在几十年前就被以格雷厄姆为主的投资大师们提及的投资概念
第二部分讲述了作者自己对投资的一些基础思考与理念，
第三部分探讨了关于“简单50：50”的升级策略和升级方向的思考，
推荐序Ⅰ 资产配置的魅力（SOSME） 资本市场为我们提供了三种获取投资收益的方式：①资产配置；②择时交易；③证券选择。
行动基于思维与认知，若缺乏认知，行动的落实自然会显得异常困难。
在投资的世界里有时过量的阅读并不一定都是好的，在错误的方向努力越多也只是与目标越来越远。
50：50策略在趋势性上涨中不如股票，在趋势性下跌中不如现金，但在反复的震荡中会超越两者，50：50中的再平衡过程能够帮助你被动地完成低买高卖
要让大家抛弃潜意识里的暴富欲望、抛弃主观努力带来的成就感与兴奋感、抛弃人比人的本能——这些都是反人性的。
资产配置充满魅力——-但只有懂它的人才能感受到这种魅力，读懂这本书也许就能读懂资产配置
推荐序Ⅱ 半仓山海（小小辛巴） 很多时候全仓甚至加杠杆都跑不赢市场，为什么用半仓策略却能跑赢？
因为炒股短期是赌波动的胜负游戏，而长期却是一种生存游戏，
所有人大输特输时，能早早兑现出一半现金的人，躺着也能稳赢。
格雷厄姆提出的半仓策略的高明之处
书非抄不能读也
上升的市场中，一个真正的防御型者将满足于他的组合投资的一半所显示的收益；而当严重下跌时，他可能从他的境况要比更喜欢冒险的朋友的境况好得多中得到更大的安慰
我确信50：50模型对防御型投资者是很有益的。它非常简单，毫无疑问瞄准了正确方向。它给予追随者以下的感觉，相应于市场发展，他至少做出了某些行动；最重要的是，当市场上升到越来越危险的高度时，它将限制他拿出越来越多的钱投入普通股”这段话时，也就觉得回味无穷，更能明白强制性限制行动的重要保护作用
宋相赵普“半部论语治天下”；毛泽东同志“半部三国打天下”。
半佛半仙心已悟，半缘修道半缘君。
第一章 我们需要的是理财，不是投资 每个人的性格不同，思维不同，投资上的那些简短建议，不管我说的是什么，即便本意是善良的，但在客户自己消化理解后，却往往不一定产生好的结果。
这些“专业”的投资方法与理论，最终只能被极少数人完好地吸收，被更少的人实践与运用
在错误的方向努力越多，只会与目标越来越远。
看客和大V们大多时候是两个世界的，少数看客成长为投资牛人，但多数依然还是要继续属于自己的生活。
很多人有闲钱，只是想找地方投，追求资产的保值升值，而这个地方可能是银行、房产、债券以及股票、基金，收益率的要求并不一定非常高，但风险要在可承受的范围之内，同时最重要的是不要太花时间、太花精力，不能妨碍原本的生活、兴趣和工作。
股市里，努力不一定有回报，但不努力基本就是在赌博和娱乐了。
我得肯定，在股市里如果读了足够多的书、有天赋、有一套系统的方法，又足够勤奋，肯付出精力去挖掘和钻研，绝对能赚到钱。不
即便入了门，也可能没走对方向，即便走对了方向，也可能因为不够努力而炒了十几年股仍然没赚钱。
做客服时间久了就能知道，客户和韭菜真的没有区别，来了走，走了来。
需要好好想想，认清自己，想清楚“我到底想要什么”。是准备把股票当作家庭理财的一种资产配置？还是确实热爱财经，热爱炒股，把股票当成一种兴趣和追求呢？“把股票当成一种理财手段”与“把炒股当成毕生追求”，
资产配置就是决定买什么（指大分类、如股票、债券、现金、房产、黄金），买多少的过程。
关于资产配置，我读过的，有三本很亲民、很易懂的畅销好书：一本是《不落俗套的成功——最好的个人投资方法》。
第二本是《聪明的投资者》，
《漫步华尔街》
从一个非常长期的投资视角看（比如一个人的一整段投资生涯），资产配置对投资收益的影响要比选股和选时重要得多。
一方赚的钱，一定是市场中做出相反决定者亏损的钱。
巴菲特这样长期战胜市场的旷世奇才，毕竟只是少数中的少数。
被动投资的理念、资产配置方法对于普通个人投资者而言，对于普通的家庭理财而言，意义是极其巨大的。
它不产生佣金，券商没动力推。不产生税收，政府没好处拿。因为简单，老百姓一学就会，一会就能上手，所以几乎不需要专业管理者，基金公司不喜欢。
不需要长时间的研究和培训，所以没有稿费拿、没有学费交。
第二章 简单50：50策略 把你手头准备用于投资的闲钱（注意是闲钱），50%投资于股票指数基金（比如指数基金300ETF，代码510300），50%投资于低风险固定收益产品（在此推荐各种货币基金）。
每隔固定的一段时间进行一次资产再平衡（比如一年），使股票资产和固定收益资产的比例恢复到
50%对50%
如果这一年股票大涨，则需要卖出股票，买入货币基金，使调整后两种资产的市值恢复50%对50%。
然后，然后没有了……就是这样的简单。
它的出发点在于充分认识自己在市场上的“无知”，并尽一切可能规避决策。
以普通投资者的知识储备程度来说，抉择越多，错误越多，亏损越多。
50：50是一种彻底被动式的投资方法，完全跟随市场，不需要做任何主观判断（选股择时），规避我们“非专业投资者”乱决策带来的各种亏损。
每年选择一个固定的时间点（比如年末、年初、年中的某一天），到这一天时，无论股市涨跌，都将股票资产与现金资产的比例，恢复到50比50。
在熊市中避免大幅度的亏损比在牛市中赚了多少，更为重要。
由于90%的股民一般会在牛市阶段入市，这个时候周围的朋友都在赚钱，大家都在比谁赚得更多。
。它会帮你躲过“大众的疯狂”，并在大众极度悲观时不断买入股票。
股票越跌越买，买到没钱了股票还在跌。或者股票越涨越卖，卖光了还在涨）。
如果你自信对市场有了较深的理解，你可以尝试：①用一个5至6只股票的组合来替代300ETF；②用银行理财、债券、分级基金、打新股、套利等任何低风险投资替代货币基金；③尝试做一定程度的择时判断，将每年固定的50：50，调整到60-40甚至70-30（熊市时可逐步提高股票持仓比例，牛市时可逐步减少）。但
。巴菲特把一生的智慧浓缩为“不要亏损”，但这话对于大多知识和实践经验欠缺的人而言，没有任何意义。</description>
    </item>
    
    <item>
      <title>徐建明谈理财：观念决定一生的财富</title>
      <link>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E5%BE%90%E5%BB%BA%E6%98%8E%E8%B0%88%E7%90%86%E8%B4%A2%E8%A7%82%E5%BF%B5%E5%86%B3%E5%AE%9A%E4%B8%80%E7%94%9F%E7%9A%84%E8%B4%A2%E5%AF%8C/</link>
      <pubDate>Wed, 28 Sep 2022 13:18:52 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E5%BE%90%E5%BB%BA%E6%98%8E%E8%B0%88%E7%90%86%E8%B4%A2%E8%A7%82%E5%BF%B5%E5%86%B3%E5%AE%9A%E4%B8%80%E7%94%9F%E7%9A%84%E8%B4%A2%E5%AF%8C/</guid>
      <description>徐建明
财富从哪里来 理财大致可以分为财富的积累、财富的保障和财富的分配三项内容。
开源当然就是创造财富，也就是赚钱。赚钱最基本的方式当然就是通过劳动得到收入。
财务自由其实体现的是一种生命的状态，也是个人理财的最终目标。
人类财富的来源
人类只有在生产活动中才能创造出财富（当然现代社会中的各类交易活动也是生产活动的一种）
生产活动有三个基本要素：劳动、资本、资源（
资源在中国都是属于国家和集体所有的（
我们要获
得收入，分享生产活动创造的财富，当然就只有通过付出劳动或者拥有资本（财产）。
物以稀为贵。
想
办法拥有社会稀缺的资源是获得财富成功的不二法门。
成为富人是一种选择 一个人最终是贫穷还是富裕不是运气，也不是所谓的机遇，而是选择，是对生活方式和价值体系的选择。如果你选择了富人的生活方式，选择了富人的价值体系，你就会成为富人。
所以一个人赚钱的过程，就是向社会做贡献的过程
一个人消费的过程其实是向社会索取的过程
收入减去消费，是他的节余，而节余恰恰是他对社会的净贡献。
生活更加自律。
承受更大的风险
承担更大的责任。
对于选择成为富人的人，你应该明白，选择成为富人绝不意味着你会更加开心，也不意味着你会更加幸福或者更加荣耀，而是意味着你将付出
更多，承受更多，承担更多（我们看看蜘蛛侠吧）
乐退：令人向往的生活方式 因为只有提前退休，才能够实现有时间、有精力也有金钱做自己想做的事情。
按照胡润的研究报告称，中国富豪的乐退门槛为1.1亿元人民币，按这个标准目前中国有5.5万人具备乐退条件。
导出于 2022-09-28 13:18:52</description>
    </item>
    
    <item>
      <title>哲学家们都干了些什么</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6%E5%AE%B6%E4%BB%AC%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/</link>
      <pubDate>Wed, 28 Sep 2022 13:16:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6%E5%AE%B6%E4%BB%AC%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/</guid>
      <description>林欣浩
第二十四章 远离尘嚣 德国古典哲学的一个共同特点是晦涩难懂，不只是康德，德国哲学家全这德行。
到底是怎么解决决定论和休谟怀疑论这两个大问题的
理性主义属于独断论，经验主义又不能证明事物之间存在因果关系
在这个世界里，人类是一种非常可怜的生物。人类永远无法认识到这个世界的真面目。人类所感受到的这个世界，都是通过人类心灵中某个特殊的机制加工处理过的。
先天认识形式
世界的真面目，起个名字叫“物自体”（也被译作“自在之物”）。
人类感觉到的世界，也就是“物自体”经过“先天认识形式”加工后得到的东西，我们把他（们）叫作“表象”。
“先验”。“先验”和“先天”差不多。意思是，先于经验，说某些东西是在人获得经验之前就存在的。
先天认识形式就是先验的。再比如理性主义者相信的不言自明的公设，一般人理解的绝对真理，也都是先验的。
在康德的哲学世界里，所有的知识（也就是来自于物自体的知识）都要先经过人类心灵的加工，才能被人类认识。
在他的哲学里，不是心灵去感受经验，而是心灵加工经验，心灵生产了经验。当然，这加工过程并不是任意的。
这个比喻里，有色眼镜是先天认识形式，事物原本的颜色是物自体，人类看到的蓝色的世界，是表象。
要注意的是，每个人的眼镜都是相同的，不会有人不一样。因而，戴着眼镜其实不会妨碍人类的正常生活，连物理研究的结论都不会影响。
这个BIOS就是先天认识形式。我们人类的世界就是物自体，而电脑能理解的命令是表象。外界的任何命令都必须先经过BIOS的处理，才能让电脑把物自体的表象显示出来。
所以电脑能理解到的永远都是一条条程序命令，它不能理解人类世界的真实面貌，但它也不是和人类世界完全分离的，可以通过BIOS的中转和外界保持相关性互动。
康德认为，这世界（物自体）是人类永远无法真正认识的，人类看到的只是表象的世界。但是由于每个人对真实世界的表象方式（先天认识形式）都是相同的，所以人类看到的同一个东西的感受还是一样的，因此我们察觉不到真实的事物是否被扭曲了。所以这个世界观并不和我们的生活经验相悖。
我们这个先天认识形式里，包含了很多用来处理物自体的工具（一共有十二个先天范畴），其中一个就是因果律。
科学家只能研究表象世界，因此科学家的研究对象都是带有因果律的。
我们自己的意识就是物自体啊！
因果律只存在于先天认识形式里，并不存在于物自体中。物自体是自由的，我们自己的意识也是自由的。
康德让人的意志受到了先天认识形式的严密保护，因果律不能穿透先天认识形式去控制人的内心意志，所以人仍旧是自由的。
科学是永远无法研究人的自由意志的。 问题完美解决。
既然人类谁都不能认识物自体，你凭什么说有物自体？你凭什么说有先天认识形式？你凭什么说先天认识形式里就有因果律？
第一个证明是，我们有感觉对吧，而“感觉”暗含的意思是，我们感觉到的是“我们之外”的东西。
人类可以想象不存在物体的空间，但是不能想象不在空间中的物体。这说明空间是不依赖外界经验存在的概念。
第二十五章 王者之风 过去的哲学家们，也就是形而上学家们，他们认为真理是固定不变的，静等着人类去发现。
因此我们的教科书才说形而上学是孤立、静止地看待世界。
哲学要追求终极真理，先得解决“哪些知识、道理是绝对真实”的问题，也就是“认识论”的问题。
问题是，研究“认识论”所使用的方法也是知识的一种，也有“研究它的方式靠谱不靠谱啊”的问题。
哲学家们的工作情形就好比有一块大石头，叫作“理性”，哲学家们打算去研究这玩意儿了。但哲学家们唯一能用的工具也只能是“理性”。
我们今天对辩证法有一种庸俗的理解，说辩证法就是“看待事物要分两个方面”。
这不叫辩证法，这叫诡辩法，它的唯一作用是把所有的事实都捣成一片糨糊，逃避一切有意义的结论。
一个判断并不是世界的永恒真相。
世界不是容不得矛盾的，而恰恰相反，到处都是矛盾，矛盾就是世界的本质。
为何说矛盾可以存在？因为矛盾双方是互相依存的，“漂亮”和“丑”虽然是矛盾的，可是没有“丑”就没有“漂
亮”，两者谁也离不开谁。
有一个正题就可以找到它的反题，因此新的合题产生之后，它的反题也随之产生，这样就又产生了新的矛盾，又要有新的冲突和升华，再产生新的合题。
事物是不断变化的，这种变化是自发的、抑制不住的。
理性经过不断的辩证，就可以完全符合客观世界的真实面貌。理性就是世界的本质，世界的本质就是理性。
宇宙的本质是精神，而且是一种理性精神。 这个理性精神，就是黑格尔的“绝对精神”。
黑格尔的历史观后来被马克思批判性地继承，变成了辩证唯物主义历史观——马克思也认为，历史的进程是有方向的，不可逆转、不可阻止的，但是可以预测的。
很明显，黑格尔的预言是错的。他并没有真正终结哲学。在他身后，无论是历史还是哲学的发展，都不符合他的预言。
形而上学到了黑格尔这里，变得史无前例的庞大。黑格尔用理性建造了一座宏伟的形而上学大厦，囊括了世间
万物，实现了形而上学家们多年以来的终极梦想。
所以我们说，黑格尔是形而上学的巅峰。
只要歌德翻到另一页就会发现，那页一开始就写着两个字：“但是”。
我们追求个人幸福的最高境界，不是纵欲，而是内心的平静。
第一章 傲慢与偏见 黑格尔是形而上学的巅峰
这人叫叔本华，没什么背景，也没正经工作，整天闲晃着。出过一两本哲学书，写的是什么，不知道，没人看过。
26岁的时候，叔本华和母亲吵翻，离开了母亲后他独自生活。从此以后，直到他母亲去世的二十多年里，叔本华几乎再没有看望过她。
终于到了30岁的时候，叔本华最重要的著作《作为意志和表象的世界》出版了。
第二章 悲观主义 叔本华是康德思想的继承者。
康德哲学的一大问题是，物自体这东西其实是自相矛盾的。
物自体是超越理性，不能用理性知识体验的。但是我们观察自己的时候，可以不靠理性，而是靠非理性的“直觉”。
审视内心
万物的物自体是统一的，只有一个。
生命意志”
既然物自体是一切事物的本质，而叔本华又认识到了物自体，那么也就等于他认识到了世间万物的本质。因此叔本华和黑格尔一样，认为自己已经解决了全部的哲学问题，世界的终极答案已经在自己手里了。
那么生命意志是个什么东西呢？ 简单地说，是一股永不停歇的力量。这股力量驱使着万物去运动，去发展。</description>
    </item>
    
    <item>
      <title>2000年以来的西方</title>
      <link>https://www.pengjielee.cn/post/read/%E5%88%98%E6%93%8E/2000%E5%B9%B4%E4%BB%A5%E6%9D%A5%E7%9A%84%E8%A5%BF%E6%96%B9/</link>
      <pubDate>Wed, 28 Sep 2022 13:16:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%88%98%E6%93%8E/2000%E5%B9%B4%E4%BB%A5%E6%9D%A5%E7%9A%84%E8%A5%BF%E6%96%B9/</guid>
      <description>刘擎
我们如何想象世界（代序） 西方思想内部具有多样性和复杂性，而且包括了各种自我批判的思想传统。 2019年 世界的面容仍晦暗不清。混沌与动荡经年已久，大变局中的人们或许不再惊慌，但却难以辨识，更无从把握自身的“时代精神”（Zeitgeist）。
既然历史目的论早已被时尚思想抛弃，时间之矢也就无所谓确定的方向。
黑格尔和马克思相信，时间是一个矢量，世界历史有其方向，终将达成人类共同的目标。
大国必定会伺机扩张，寻求区域霸权，进而引发大国间冲突。
无论以“新冷战”还是“脱钩”来判定当下的势态，都暗示着中国与美国的激烈竞争乃至对抗将成定局。
冷战之后西方对于中国的发展存在三种主要的论述：崩溃论、演变论与威胁论。
如今在华盛顿的精英看来，“崩溃”希望渺茫，“演变”遥遥无期，于是“威胁”便成为关于中国的主导性论述。
不断崛起的中国并未按照西方所期望的那样，温和地融入美国创立并主导的国际秩序，而是成为挑战这个秩序的“修正力量”，已经造成了严重的威胁。
现在应当放弃过去温和的接触战略，代之以更为强硬的方式以“规制”中国，这是美国发起贸易战的理论基础。
如果进入战争只是为了最后有一个退出战略，那么当初就不应该在那里开始。
如果发起“新冷战”最终只是为了停战，那么今天就不应该开始。
即便接触战略的失败是一个事实，这本身在逻辑上并不意味着其他选项（比如“围堵”战略）将获得成功，或者不会导致同样的甚至更加严重的失败。
委员会认识到当今美中经济的一体化程度，这使得来自中国的威胁不同于苏联。但为应对这一威胁，华盛顿正越来越多地求助于各种冷战手段。
如何处理当今中国与昔日苏联的差别呢？
美国必须联合欧洲等盟友共同应对中国的挑战，但当前外交政策却走向疏远和失去盟友的歧途。
“继续接触的道路，会使美国容易受到经济和安全的威胁”，但走向脱离的道路则“可能削弱两国经济，甚至有一天可能会导致战争”。
面对中国崛起的新趋势，在“恐慌的”强硬派与“不安的”审慎派之外，过去那种乐观而友好的“亲华派”（pandahuggers）已经所剩无几。
欧洲不可能割裂与美国长久的纽带关系，但也无法承受削弱与中国的贸易关系。
最可行的未来是“一种不稳定的共存”，这种共存建立在双方都欲求“斗争而不毁灭”的关系基础上。
美方提出的一些结构性诉求，乍一看似乎咄咄逼人，但仔细想想，很多何尝不是我们深化改革开放进程中正要做的？
“时间是建筑师，但人民是工匠。”
曾经召唤人心的“欧洲精神”，曾在柏林墙倒塌之后鼓舞了千万人“重返欧洲”的梦想，以及欧洲一体化的实践，如今都变得面目不清、前景不明。
彷徨的欧洲，在欧盟整体目标与成员国各种诉求之间左右摇摆，也在中美纷争的大变局中难以抉择：美国正在疏离的盟友，或者中国的潜在新伙伴，或是更具自主性的欧洲。
走向悬崖的命运始于20世纪90年代，从那时开始，欧盟专注于市场的扩张与规制，却逐渐失去了自身的政治目标。这在美国提供的安全保障下，造成了一种永远稳定的幻觉。
当世界从基于规则的全球秩序转向由实力强权政治所决定的秩序，欧洲正面对近乎生死存亡的时刻。
欧洲人“可以依靠他人的时代已经结束”。
如果坚固的美欧同盟不复存在，欧洲如何能在一个危险的世界中繁荣兴盛？
英国在痛苦的思考后做出了选择：面对纷乱复杂的局面，决定抽身而出。“脱欧”并不是脱离欧洲，而是摆脱欧盟体制的束缚，以某种“光荣孤立”的姿态与欧洲大陆保持有弹性的距离。
社会与经济的奖赏应当依据才能、努力和成就这些“优绩”（merits）来决定。
最好的大学应当录取成绩最出色的学生，收入最高的职位应当留给最有能力的人才。对美国人来说，这是不容挑战的理想原则。
只看到有人破坏游戏规则，却没有看透这个游戏本身是一个陷阱。
美国生活中主要的痛楚，不是因为优绩制没有充分落实，而是优绩制本身造成的。
优绩制根本无法兑现它许诺的公平竞争与社会阶层流动，在虚假承诺的伪装下只是一个陷阱。
首先，优绩制固化了社会等级，折断了人们向上攀登的阶梯，实际上造就了新的世袭制。
美国社会的现状是，精英阶层能够将优越的社会和经济地位“代际传递”给自己的子女。这当然不能依靠被废弃的世袭制度，而是通过教育。
教育本来是社会阶层流动的关键通道，但优质教育是稀缺资源，需要竞争才能获得。争夺优质教育资源是一个全球现象。
精英阶层找到了保持优势的秘诀：通过支付高额费用，让孩子获得最好的升学训练，从幼儿园一直到高中，外加各种昂贵课外补习班和培训项目，让他们的子女在各级入学申请中获得难以匹敌的竞争力。
第二，推行优绩制的结果是贫富差距的扩大，结果瓦解了中产阶级。
第三，优绩制的操作具有欺骗性。
精英阶层不只用财富优势获得教育优势，而且他们故意提高了社会职业的技能门槛。
精英阶层在双重意义上作弊。首先是在入学竞争中，他们的子女接受了昂贵而优质的强化训练。
老派精英阶层的特征是闲散，因为可以不劳而获。而现在的精英主要是“超级技能”的劳工，过着超级繁忙的生活。
精英阶层生活在无止境的竞争命运中，必须付出极端的代价才能守护自己的特权地位。
如何在当代条件下重新构想自由与平等的关系。
对资本主义的不满往往激发左翼思想的回潮。
美国人心目中的“社会主义”更接近北欧的社会民主主义。
资本主义已经耗尽了其潜力，现在需要社会主义的方案才能适应当代世界的现实。
从亚当·斯密开始，资本主义最伟大的捍卫者都承认有必要克服其弊端，以此维护政治安定与社会和谐。
成功的进步运动从来都致力于“驯化市场”，而不是废除它们。
思想具有改变历史进程的力量，但左翼思想的历史实践记录并不令人乐观。
左派如何才能让人们抵御右翼政策的诱惑？追求的目标究竟是“终结”还是“转变”人们所熟悉的资本主义？
如果贫富差距过于悬殊，终将造成社会的分裂甚至崩解，那么资本主义也将因无处安身而瓦解。
西方主流思想将激进平等主义视为乌托邦式的幻想，对其可能的灾难性后果始终抱有警觉。
注重机会平等的自由竞争，若完全无视相对的结果平等，也很可能造成另一种灾难。
2018年 所谓的“自由国际秩序”是否濒临崩溃？大国竞争如何避免“修昔底德陷阱”？世界是否进入了“新冷战”时代？美国对“高尚国家”联盟的呼吁是一种新的国际战略构想吗？
正在隐退的自由世界秩序既不自由，也不具世界性，而且没有秩序可言。
“修昔底德陷阱”与“新冷战”等议题应运而生。
历史上崛起大国与守成大国为争夺霸权而竞争，难得实现和平的权力转移，往往陷入战争的结局，是谓“修昔底德陷阱”。
英国能够和平地将国际领导权转交美国，依赖于文化相似性这一相当苛刻的条件，完全不适用于中美关系。
肯尼迪从来没有放弃他的反共立场，但却愿意“与敌手共存”，从“为民主而战”转向“为守护和平而容忍多样性”，期望不同的政体之间展开和平竞赛，最终让时间来裁决哪一种制度最为可取。
赫鲁晓夫的“三和路线”（“和平过渡”、“和平竞赛”与“和平共处”）
今天的守成大国还会有耐心等待半个世纪吗？而崛起大国会甘愿退守次强来取悦霸权大国吗？
避免修昔底德陷阱最终依赖于共同价值的塑造，这是极为艰难的事业，需要付出巨大的耐心和努力。
美国曾相信中国在向世界开放的过程中“将不可避免地成为一个自由国家”，但这种天真的希望落空了。
他们低估了中国政府捍卫自身政治事业的抱负与意志。</description>
    </item>
    
    <item>
      <title>做一个清醒的现代人</title>
      <link>https://www.pengjielee.cn/post/read/%E5%88%98%E6%93%8E/%E5%81%9A%E4%B8%80%E4%B8%AA%E6%B8%85%E9%86%92%E7%9A%84%E7%8E%B0%E4%BB%A3%E4%BA%BA/</link>
      <pubDate>Wed, 28 Sep 2022 13:15:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%88%98%E6%93%8E/%E5%81%9A%E4%B8%80%E4%B8%AA%E6%B8%85%E9%86%92%E7%9A%84%E7%8E%B0%E4%BB%A3%E4%BA%BA/</guid>
      <description>刘擎
自序　在新的地平线上 “全球化”究竟是什么？
“我们”是谁？中国有多特殊？在什么意义上我们还是“纯粹的中国人”？我们追求的理想生活图景究竟是什么？
杰出的文章往往是学理与评说相映成辉，执着于真理与良知，又避开偏执和狂热，彰显理性的慎思和公允，行文晓畅却不流俗。
如何对待异己之见和论争对手是对作者学识与品格的某种检测。
聪明而善良的人们，在对待社会最重要的问题上既有站在正确的一边，也有站在错误的一边。
两者的异端，很少能用迫害来消除。
辑一　迷雾与光芒 彷徨而无从堕落的岁月，一个布尔乔亚的少女成为你仅有的心事，从此，革命一直使你无限忧伤。
在青少年时期，我和很多人一样，有一个空洞的远大抱负，但未来要做什么却并不确切。
《理想的冲突——西方社会中变化着的价值观念》
《思想家——当代哲学的创造者们》（三联书店1987年翻译出版）
世俗时代的死亡问题 论说可能会有两种相当不同的方式：一种是“律师型”的雄辩，就是调用和强化一切对自己立场有利的证据，而漠视、歪曲或诋毁所有于己不利的证据，唯一的目标就是要赢得论辩（时下流行的大专辩论赛大约是此类论说的典型）；而另一种是“智识（哲学）型”的论述，需要审慎细致地面对各种不同的证据，诚心辨析令人困惑的问题所在，最终是为了在思索与探究中寻求真智慧。
真正的学人要提防沾染过多的“律师话语习气”。
查尔斯·泰勒
像是与一位博学睿智的长者交谈，他有些絮絮叨叨，但充满真知灼见，他的迂回反复也常常是出于审慎，尽可能公允地处理与自己相左的论点。
“信仰上帝不再是唯一可能的生活方式” ，而只是多种可能的选项之一，甚至不是一个最容易的选择。
只要你还能感到死亡问题，那说明你还活着（也就无须为此费心），而一旦你死去，也就不再会感到死亡是个问题了。
古代，死者在某种意义上仍然与生者在一个共同体中，死亡是“我们”的事件。
死亡的主要问题是担心对“我的”末日审判。
现代，死亡的重心转向与亲人至爱的离别，关切的是“你”。
用“我们之死”“我之死”和“你之死”来分别表示。
也许是因为在现代社会，公共的集体事业不再能对每个人提供完整的人生意义，个人之间的亲爱关系就变得格外重要。
欢乐的意义总是与渴望永存在一起。写作与艺术创造也都是渴望永存的某种方式。
死亡颠覆了意义，如果忘记了这一点，我们就没有理解死亡的真正含义。
上帝从未死去，只是部分地隐退，而且时隐时现。
祛魅时代的学术与政治——韦伯志业演讲导读 韦伯的思想生涯有两个突出的特点。第一，他的研究领域非常广泛。
现代社会学的三大奠基人
第二，韦伯广泛介入了公共讨论，在报刊上发表过重要的政论文章，还直接卷入了许多政治活动，包括在一次大战中从军，参与野战医院的管理和建设，作为德国战后谈判使团的顾问参加凡尔赛和会，以及讨论起草“魏玛宪法”等工作。
对现代世界特征的洞察
我们这个时代，因为它所独有的理性化和理智化，最重要的是，因为世界已经被除魅，它的命运便是那些终极的、最高贵的价值，已经从公共生活中销声匿迹。
“祛魅”，disenchantment of the world
现代的来临意味着一种觉醒，像是世界到了“梦醒时分”，解除了古代迷梦一般的魅力或者魅惑。在现代之前，人们生活在一个魅惑的世界中，相信其中有神存在，有精灵和鬼怪出没，灵性不只限于人类，动物也有灵性，甚至万物有灵。这些超越人类经验感知的所谓“超验”的存在，是冥冥之中难以言说的神秘事物，却构成了古代精神极为重要的一部分。因此，古代世界笼罩在神秘的精神之中，让人难以理解，无法参透，也因此让人敬仰和畏惧。恰恰是这种神秘精神，让人类与整个宇宙连成一体，并从这种联系中获得生存的意义。古代人的终极价值，生命的根本意义，不是人类自足的，而是依托于比人类更高的存在，依赖于宇宙的整体秩序。人们往往通过宗教信仰和仪式，通过与超验存在的联系，确立生命的意义与目的，获得所谓“安身立命”的根基。
以理性化的方式来探索世界和自己
世界被理智化了，也就是被人看透了。
世界被看透了，没有什么不可思议的说不清道不明的神秘之处。人们相信，即使有些事情一时还看不透，但在原则上终究是能被看透的，其中的奥秘迟早会被破解。
古代世界那种迷雾一般的魅惑，在现代的“清晨”被理性化的光芒驱散了。现代人在回望古代世界的时候，会有一种“大梦初醒”的感觉，这就是所谓“世界的祛魅”。
这个“梦醒时分”对许多人来说，在精神上是格外“荒凉”的，信仰失去了以往神秘的根基，而科学又无法为生命的意义提供新的根本依据，终极价值不再具有客观性和公共性，会让人茫然若失。
那些终极的、最高贵的价值，已经从公共生活中销声匿迹
在这种条件下，学术生涯以及政治事业，到底还有什么价值？我们如何从事学术和政治？
思想界弥漫着狂热与骚动的情绪，很容易让煽动家和假先知大行其道，他们编织迷人的幻觉，散布言之凿凿的错误答案，鼓吹虚妄的信心，误导人们去寻求虚假的希望，走向极端狂热，或者传播貌似深刻的虚无主义，让年轻人陷入不可自拔的悲观和绝望。
学者遵循的最高原则是“智性的诚实”（intellectual honesty），就是要揭示真相，无论真相有多么严酷。
他又不希望人们被严酷的真相所吓到。揭示真相是为了让人清醒、清澈和清晰，而不是在发现真相之后陷入伤感、绝望、虚无或者狂热。
官僚就是政治系统中的行政官员、公务人员或者“官吏”。官僚的首要职责是服从上司，严格遵守纪律，最重要的特点是“专业化”抑制“个人化”。
政治家则不同，严格意义上的政治家，尤其是韦伯说的“政治领袖”，具有鲜明的“好恶感”，他们有明确的信念和立场，必须对政治行动的最终结果负责，而且责无旁贷。
官僚多半是“靠政治而生存”，而政治家是“为政治而生存”。
政治家必须引领官僚系统，为其“注入灵魂”，才能在政治事业上有所作为。
在他看来，政治家在人格上应当具备三种品质：热情、责任感和判断力。
政治行动的后果往往不会让所有人皆大欢喜，那么“什么算是好的后果”，判断的标准何在？
韦伯有一个判断标准是明确的，那就是目标与结果的一致性。
如果你的意愿是建立一个自由的社会，但结果却是普遍的奴役；如果意愿是人人平等，结果却是等级分化严重、贫富不均悬殊；如果意愿是一个道德纯洁的社会，结果却是伪善和腐败的蔓延；如果意愿是安全与稳定，结果却是人人自危和动荡不安，那么，你作为政治家就是不合格的。
民粹主义的本质——米勒《什么是民粹主义？》中译本导读 他们强硬而富有煽动力，鼓吹极端的理念和政策，宣称代表底层民众，诉诸民众被漠视的利益和被压抑的愤怒，誓言彻底改变腐败和无能的建制派精英们所造就的黑暗现状，并许诺民众一个崭新的光明未来。
民粹主义可能表现为反建制、敌视精英、愤怒、非理性、不负责任、仇富、排外……但所有这些都不是其独有的特征。
对“人民”代表性的垄断。
民粹主义者们宣称，他们，且只有他们才代表“真正的人民”及其意志和利益。
诉诸“人民的意志”意味着信奉“人民主权”原则，因此民粹主义与民主政治具有令人迷惑的相似性，也总是如影随形。
在根本上，反多元主义（anti-pluralism）的特征使民粹主义不仅是反自由的，最终也是反民主的。
同质化人民
一个复杂多元的现代民主社会中，绝不存在单一的政治意志，更不用说单一的政治观点了。这是所有欧美社会的政治现实。</description>
    </item>
    
    <item>
      <title>血酬定律：中国历史中的生存游戏</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E8%A1%80%E9%85%AC%E5%AE%9A%E5%BE%8B%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E4%B8%AD%E7%9A%84%E7%94%9F%E5%AD%98%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Wed, 28 Sep 2022 13:14:56 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E8%A1%80%E9%85%AC%E5%AE%9A%E5%BE%8B%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E4%B8%AD%E7%9A%84%E7%94%9F%E5%AD%98%E6%B8%B8%E6%88%8F/</guid>
      <description>吴思
再版前言 血酬定律有三个要点： 一、血酬就是以生命为代价从事暴力掠夺的收益。 二、当血酬大于成本时，暴力掠夺发生。 三、暴力掠夺不创造财富。
暴力掠夺不创造财富，只能转移财富，这就会引出暴力掠夺者与财富创造者互动的漫长故事。
自序 那是一种低成本伤害能力，在官吏手里就是合法伤害权。
决定规则的规则。
所谓血酬，即流血拼命所得的酬报，体现着生命与生存资源的交换关系。
血酬的价值，取决于所拼抢的东西，这就是“血酬定律”。
这个概念触及了生命、生存资源和资源分配规则三者之间的关系
所有规则的设立，说到底，都遵循一条根本规则：暴力最强者说了算。这是一条元规则，决定规则的规
那些有生命的个体或团体，投入自己或他人的性命，动用各种策略，争夺生存资源。竞争造就了资源分配的规则体系，在体系中的真实位置又注定了个体或团体的性质。
第一类：官，合法暴力的代理集团。
第二类：民，农工商生产集团。
第三类：“贼”，仰仗暴力谋生的非法团体
第四类：文化梦想中的暴力：金庸给我们编了什么梦
第五类：综合
君之视臣如土芥，则臣视君如寇仇”
这老儿要是活到今天，非严办不可！”朱元璋下令撤消孟子在孔庙中的配享资格，同时下令，有为此而谏者，以大不敬论。[2]后来，皇帝又命令儒臣重编《孟子》，删去85条，被删除的都是一些强调民比君更重要的文字。明朝科举考试，用的就是删改后的《孟子节文》。
简单的逻辑可以告诉我们，在发生争执的时候，如果在肉体上消灭对手很合算，那么，只要拔出刀来，问对手想死想活，任何争执都不难解决，任何意见都不难统一。暴力可以压倒所有规则，反之则不然。
在挑选规则的时候，拥有让对手得不偿失的伤害能力的一方，拥有否决权。死亡是最彻底的损失，所以，暴力最强者拥有最高否决权。
逻辑和历史经验共同告诉我们：暴力最强者说了算，这是决定各种规则的元规则。暴力最强者的选择，体现了对自身利益最大化的追求，而不是对正义的追求。暴力最强者甚至可以选择并修改正义观念本身。
在长时段上，平民的选择和对策，从热烈拥护到俯首帖耳到怠工偷懒到揭竿而起，可以决定暴力竞争胜利者的选择的成本和收益，决定选择者的兴亡荣辱，从而间接地影响统治者对法规的选择，间接地影响正义观念和统治者对正义观念的选择。
金庸给我们编了什么梦 武侠小说是成年人的童话
金庸给我们编织了什么梦？席卷中国的白日梦是由什么构成的？我们如此上瘾地读金庸，显露出我们内心和我们社会的什么东西？
最核心的一点，就是拥有一种超常的能力，可以保护自己不受暴力的侵犯和伤害，自己却有能力随心所欲地伤害别人。
武侠就是凭一己之力匡扶正义的人，也是替天行道的人。
第一，当这样的人门槛很低
第二，一旦成为这样的人，便会有美女
第三，你的大名在江湖中无人不知，无人不敬。
第四，法律管不着你。
金庸笔下的大侠既富且贵，又做着自己喜欢的事，正义的事，受人感激的事，但愿这等十全十美的好事能让我撞上。
原来，我们的白日梦是一个富于正义感的懒汉的富贵幻想。
竟什么人拥有超强的暴力，不受暴力的威胁，却能以暴力贯彻自己的意图？究竟什么人可以衣食无忧，既富且贵，身边美女如云？这种拥有匡扶正义的地位，凭借暴力获得立法和执法权威的社会角色，在中国历史上只有一个，那就是皇帝
不过金庸又替我们想象了一个比皇上还幸福的角色，也就是大侠。
武侠没有这些烦人的事。这是一个摆脱了讨厌的义务，又可以尽情享受生活的角色。除了内心，没有任何可以约束他的力量。
武侠梦就是中国男人的改良皇帝梦。
卧榻之畔岂容他人酣睡？一统天下正是追求社稷安全的合乎逻辑的行为。
在寻求绝对安全的意义上，追求绝顶武功的人，与追求天下一统的人，实属一丘之貉。
枪杆子里面出政权——出规则，出财富，出尊敬，出美女，出成就，出一切。对武侠的幻想，其实就是对枪杆子的幻想，对拥有强大的伤害能力的幻想。
只有平民是不值得一提的。在
西方男人的幻想可以集中在巨大的财富上，但中国的财富很缺乏自卫能力，不那么值得幻想。在一个缺乏安全和秩序的社会里，对获利能力的幻想，不如对加害能力的幻想那么具有根本性，那么肆无忌惮所向披靡。
中国的合法暴力控制者长期失职，因此公正问题格外严重。我们营养不良，我们的社会有病，所以我们特别馋这些东西，在幻想中大口吞食这些东西。
大侠赢了以后怎么办？大侠在逃避了追杀，赢得了美人心，清除了各种威胁之后，终于可以过正常生活了，就好象我们大多数人如今每天面对的问题一样，那时候，他怎么过？如何养家糊口供房子？当保镖？当武术教练？他不觉得口中寡淡吗？
如果这种问题不能提出来，如果解决这种问题的想象不能流行，那么，这是否意味着还不到提出问题的时候呢？我们的民族还不成熟？我们还没有走出童年？或者我们太老太懒太累太无能，只好在装嫩中尝一点乐趣？
《万历十五年》没说透 你们的写法都有点怪，说学术不学术，说故事不故事
明代社会绝不是按照那些公开宣称的正式规范运行的，冠冕堂皇的道德法令大体只是说说而已，于是他努力描绘这种情景。
按圣贤教导办事的倒了，不按圣贤教导办事的也倒了，这到底是为什么？是偶然还是必然？是特例还是通则？
海瑞严格按照正式规定办事，禁止各种名目的乱收费，自己带头拒收“陋规”和“常例”，也停止向上级供奉陋规和常例，这等于剥夺了各级官吏的既得利益。
动用各种正式或非正式手段，逼着帝国的官吏完成税收任务，挤压他们的闲暇，也挤压皇帝的闲暇，督着他们提高效率，又不能提供额外收入。
从不同的方向压缩了官吏集团的既得利益边界，破坏了根深蒂固的官场规矩。他们的失败或倒台，不过是违规者必然要遭遇的惩罚。
问题就出在信息渠道上，即便百姓利益受损，只要利益分配方式有利于控制信息渠道的权贵集团，传上去的就是好话，反之则是坏话。因此事实本身并不重要，重要的信息筛选者的偏好。
案情稍有模糊，他们就拥有很宽广的合法选择空间，可杀可放，可轻可重，“官断十条路”，怎么断怎么有理。
大官怕小吏，并不是指望从他们手里捞取好处，而是怕他们祸害自己。总
合法伤害权
合法伤害权”威力巨大、成本低廉，人们几乎可以无中生有、凭空攫取利益；相比之下，造福的权力却有限得多，离不开实际资源的支撑。
施恩能不能得到回报，取决于受益者的良心，而施恩者无法控制受益者的良心；加害者则可以单方面控制局面，因为加害只须依赖对方的恐惧。任何人都有恐惧，但不是任何人都有良心。
：当冤大头是老百姓最合算的选择，而当贪官污吏则是官吏最合算的选择。这不是道德问题，而是利害格局决定的。
合法伤害权的最大受益者是整个官僚集团，连皇帝都算不上，而最大的受害者则是农民集团。
官僚集团内部分肥所分的油水，最终都出自老百姓；
废渠的事理(1) 黄河边的中国》
我更信服对趋利避害这类人之常情的简单计算。
没有人管’‘没有办法’或许是村落社会内最为普遍的一种心态
。‘没有人管’，是说‘要有一个人来管他们’，‘没有办法’是说他们无力通过合作协商想出一个办法，而只能靠‘别人’来替他们作主。”</description>
    </item>
    
    <item>
      <title>论中国与世界</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E8%AE%BA%E4%B8%AD%E5%9B%BD%E4%B8%8E%E4%B8%96%E7%95%8C/</link>
      <pubDate>Wed, 28 Sep 2022 13:14:56 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E8%AE%BA%E4%B8%AD%E5%9B%BD%E4%B8%8E%E4%B8%96%E7%95%8C/</guid>
      <description>李光耀
第一章辉煌与梦想：中国的未来 中国领导人真的准备取代美国，成为亚洲乃至世界的第一大国吗？中国第一意味着什么？如果成为亚洲主导力量，中国对其他国家的行为方式将如何改变？中国成为第一的战略是什么？中国实施民族复兴的主要障碍是什么？中国领导人对实现亚洲乃至更大范围主导权感受到多强的紧迫感？中国成为第一大国后将如何看待美国在亚洲角色的变化？未来几十年，中国能否保持30多年来的两位数增长？中国会成为西方式民主国家吗？中国真的会成为第一大国吗？应该如何评价习近平？
每一位中国人都渴望一个强大、富裕的中国，一个与美国、欧洲国家和日本同样繁荣昌盛并同样具有科技竞争力的中国。这种重新唤醒的使命感是一股极其强大的力量。
一个工业化的、强大的中国会不会像美国在1945年之后那样友好地对待东南亚国家呢？
我们已经看到一个越来越自信并愿意采取强硬立场的中国。
美国的担忧是，当中国能够挑战其主导地位时，它将面对一个什么样的世界……亚洲很多中小型国家也对此表示担忧，它们担心中国可能想恢复几个世纪前的帝国地位，它们担心可能再次沦为不得不向中国进贡的附属国。
中国已经得出结论：它的最佳战略是创造一个强大和繁荣的未来，利用大批受过教育、技能日益熟练的工人赶超其他国家。中国会避免任何损害中美关系的行为，挑战美国这样一个更加强大的、技术领先的国家将毁掉中国的“和平崛起”。
德国和日本的错误就在于挑战既定的秩序。中国人不笨，他们已经避免了这个错误……国内生产总值（而非人均水平）才是国家实力的关键。
中国政府担忧对马六甲海峡的依赖，正在采取措施削弱这种依赖性。
俄罗斯的错误在于军费开支过大，民用技术投资欠缺，因此它的经济崩溃了。
这个词语本身就是矛盾的，任何崛起都是令人感到恐惧的事情。
和平复兴，或演进，或发展
然而，你们给中国年轻人灌输了太多对民族复兴的自豪感和爱国主义思想……这可能导致不稳定。
中国对东南亚的战略是很简单的：中国告诉这个地区的国家“跟着我共同发展”。
经济因素决定了根本的趋势，其他国家很难抵制中国日益增强的经济影响力。
内部看，主要挑战是文化、语言以及不能吸引、同化他国人才，今后还会面临治理方面的挑战。
在新加坡，孩子们先学汉语，然后学英语。他们可能十几岁就去美国了，能说一口流利的英语，但他们的头脑里仍流淌着4000年的汉语名言警句。
中国的国内生产总值的绝对额将不可避免地赶上美国，但其创新能力可能永远无法与美国匹敌，因为它的文化不鼓励进行思想的自由交流和碰撞。
中国人能摆脱他们自己的文化束缚吗？这不符合他们5000年的历史。当中央强大时，国家就会繁荣；当中央虚弱时，各省、各县就会出现很多小皇帝。
中国领导人最大的担忧就是贪腐的腐蚀作用以及贪腐在公民中激发的反感。他们从来都不确定它什么时候会崩溃。
中国在前进的道路上存在的劣势和需要克服的障碍比大多数观察人士意识到的都要多。
缺少法治
我们这么做是为了向世界开放自己，使我们自己接触并利用那些促进发现、发明与创造力的主要力量，这些力量不仅存在于英语这门语言中，还存在于英语的思维方式中。
虽然我曾经建议一位中国领导人把英语作为中国的第一语言，但对于一个自信的大国和文化而言，这显然是不现实的。
中国的策略是在这个框架下发展，等待时机，直到变得足够强大，可以重新定义政治经济秩序。
中国无须争夺东亚。中国会逐渐加强与东亚国家的经济联系，向它们提供一个有着13亿消费者的市场。再有一二十年，中国将成为东亚最大的进出口国。
我们不反对且欢迎美国在亚太的存在。
在经济发达水平和军事方面，在百年内中国不可能追上美国，但中国可以通过不对称的发展给美国施加巨大的压力。
中国人要的是一个复兴的中国。
有一件事情是肯定的：当前的制度在今后50年里不可能维持不变。
其一，中国必须掌握权力，以确保稳定；其二，他们对多党制下的不稳定怀有深深的忧虑，这将导致中央失去对地方省份的控制，从而引发可怕的后果，就像军阀混战的20世纪二三十年代那样。
但是，我同意在这个即时通信和卫星技术迅速发展的世界上，你不可能一边做出野蛮的行为，一边说这是你的内部问题
那么他们就不会用野蛮的方式对待自己的人民。
司法独立还需要20年才能在实践中实现，因为中国的历史传统是地方法官以皇帝代表的身份执行皇帝的命令，这个传统给中国官场打下了深深的烙印。
中国的最大优势不在于军事影响力，而在于经济影响力……中国拥有的廉价劳动力超过其他任何一个国家，它的影响力只会提升并超过美国。
中国的问题比较严峻：制度变革、商业文化变革、反腐以及新思想体系的形成。
如果没有难以预料的重大灾害给中国带来混乱或者使中国再度分裂成多个军阀领地，中国民众接受再组织、再教育、再培训并充分利用现代科技只是一个时间问题。中国将利用发达国家和新兴工业化国家的成果加快发展步伐，建设成一个全面工业化的高科技社会，即便50年不够，100年足矣。
他们有强大的情感自制力，不会让个人的不幸和苦难影响其判断。
第二章霸权下的忧虑：美国的未来 历史上，美国已经展现出了很大的自我更新与复兴的能力。
美国人头脑中没有根深蒂固的陈旧思想，而是思维活跃，富有想象力，态度务实；拥有各类优秀的研究中心，竞相发明新技术、提出新理念；美国社会能够吸引世界各地的人才，并能轻而易举地使其融入其中；英语相当于一个开放的体系，是科学、技术、发明、商业、教育和外交等领域的领导者以及各国顶尖人才的通用语言。
美国是军事力量最强大的国家，是经济最富活力的国家，美国凭借创新、生产效率和消费依然是全球经济增长的引擎。
纵观历史，所有成功的帝国都接受其他种族、语种、宗教和文化的人，并让他们融入自己的民族。
今后10年、15年或20年，美国仍将是最有进取心、最有创新性的经济体，因为它拥有尖端的民用技术与军用技术…
国际竞争归根结底是人才的竞争，
美国经济出类拔萃的根源在于美国人富有企业家精神。
美国文化与东方文化之间的一个根本区别就是个体在社会中的地位不同。在美国文化中，个体的利益是主要的。
至少在今后10年、20年或30年内，我认为美国不会丧失这些能力，人才不会涌向中国。
如果要去中国并在那里稳定下来，你不得不掌握汉语，而且你必须适应中国的文化环境。这是很难逾越的障碍。
美国这个国家的伟大之处不仅体现在其权力与财富上，而且体现在它是一个由崇高理想推动的国家。
所有大国中，美国可谓是最友好的，肯定不比任何一个新兴国家严厉…
如果总统给他的人民开出的是一剂苦药，那么他就不会再次当选。
如果他们发现了问题，却因为治理体制的原因而无法加以解决，那么这种体制可以说是运转不灵的。
我相信，一个国家如果要发展自己，更需要纪律，而不是民主。民主过于兴旺，就会催生无纪律、无秩序的环境，这是不利于发展的。要检验一套政治体制的价值，最终还是要看它能否建立稳定的社会环境，是否有助于改善大多数民众的生活标准，能否在确保人民和平共处的前提下享有最大限度的自由。
美国文化过于注重个人权利，个人有权根据自己的喜好采取各种行为，但这种个人权利的膨胀是以牺牲社会秩序为代价的
在健全社会里，年轻的女孩和年老的妇人能够在夜晚安全出行，年轻人不会再被毒贩利用……在美国这个社会中，处在最顶层的3%~5%的人才有能力应对这种混乱无序的状态，才能应对各种思潮的激烈碰撞。
他们唯一的回报就是社会对他们所做贡献的赞誉。
在过去40年间，我观察到即便一个国家的政体落后，但如果由优秀的、强有力的领导人掌舵，政府还是令人满意的，能取得相当大的进步。
如果一个民族因为找不到合适的人才运作民主制度而丧失信念，那么无论这个制度多么完美，终将消亡。
要治理好一个国家，最佳方法就是让最优秀的人做难度最大的工作。
美国的债务是我最担心的，因为这个问题最有可能弱化美国的全球领导地位。
中国的注意力非常集中，它正在世界各地寻找能源，它也正在世界各地广交朋友，包括东南亚地区。
第三章对抗的代价：美中关系的未来 现在，中国的行为纯粹是为了自己的国家利益，它对改变世界不感兴趣。
中国将把两国对峙维持在依然可以利用美国的水平。
中国将推进其军事现代化，但目的不是挑战美国，而是在必要情况下实现两岸统一。
第六章新加坡为什么如此成功：经济增长的未来 你可以保留你原来的名字，只要你来了，加入了我们，你就是美国人。
我们最终确定了以英语为第一语言、以汉语为第二语言的格局。</description>
    </item>
    
    <item>
      <title>哲学100问</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6100%E9%97%AE%E5%A5%97%E8%A3%85%E5%85%B13%E5%86%8C/</link>
      <pubDate>Wed, 28 Sep 2022 13:14:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6100%E9%97%AE%E5%A5%97%E8%A3%85%E5%85%B13%E5%86%8C/</guid>
      <description>书杰
自序　人，诗意栖居 叔本华的“痛苦的智慧”； 尼采的“酒神精神”； 克尔凯郭尔的“孤独”； 柏格森的“绵延”； 弗洛伊德的“性本能”； 维特根斯坦的“语言游戏”； 胡塞尔的“现象学还原”； 海德格尔的“诗意栖居”； 萨特的“存在先于本质”； 加缪的“对抗荒谬”； 马克思的“人的解放”；
这些鲜活的哲学命题都围绕着“人的话题”——人的情感、欲望、语言、存在以及人类的政治和现代文明而展开。
“人，诗意地栖居”是德国著名诗人荷尔德林的诗句。后来海德格尔对其进行哲学阐发，“人，诗意地栖居于大地上”，成为海德格尔倡导的生活方式。
01　叔本华：为什么人生如此痛苦 生命是一团欲望。欲望不能满足就会痛苦，满足了就会无聊。人生，就像是钟摆，在痛苦和无聊之间摇摆。
人生是一趟痛苦与无聊的旅行，没有快乐和幸福可言。世间的一切都被蒙上了一层灰色的面纱。人存于世，注定要遭受无尽的苦难。
1788—1860年）
开创了非理性主义哲学的先河，是唯意志论的创始人和主要代表之一，认为生命意志是主宰世界运行的力量。
非理性主义的奠基者。
法国大革命失败后，死神成了战争的唯一胜利者。
叔本华认为：人生的本质便是痛苦。
在他看来，人之所以承受痛苦的折磨，是因为欲望使然。人的欲望是痛苦的根源。人又是千百种欲望的综合体，所以人总是不自觉地受到痛苦的折磨。
当人的欲望得到满足后，人便会陷入无聊和疲惫中，此时一个新的、更大的欲望又会产生，人又要投入对新欲望的追逐中，从而不断填补新的不同的欲望。
10　尼采：上帝死了 尼采区分了两种道德：奴隶道德和主人道德。他要批判的是危害生命的奴隶道德，要发扬的是肯定生命力的主人道德。
遵守奴隶道德的人，没有自我创造力，生命中缺少激情色彩，混沌度日。
主人道德是强者的道德，是光明而积极的道德，是“强力意志”的体现。
批判戕害生命力的奴隶道德，发扬富有创造力的主人道德。
11　尼采：凡杀不死我的，都使我强大 超人，是一个理想、一种向往，也是对现实人类的超越。
尼采的“超人”，并不是指无所不能的、具有超凡能力的人，而是一种具有强力意志、超越普通人、在“人之上”的人，它是理想化的人格类型。
尼采始终没有对“超人”做出非常明确的解释，而是通过“末人”——“超人”的对立面来阐述“超人”的内涵。
尼采把普通的人比喻为一种疾病、一条不洁的河流、一个不伦不类的东西，这样的普通人就是“末人”。
“末人”是没有生命创造力、唯唯诺诺、庸庸碌碌的众生，这类人由于长期浸染在传统理性的说教和基督教道德的熏陶中，而丧失生命的激情和活力。
他们个性泯灭、随波逐流、人云亦云，缺乏旺盛的强力意志，缺乏挑战精神，缺乏对未知的渴望，缺乏打破传统的勇气。
“末人”缺乏对生命意义的认同，沉浸在自我麻痹和消极避世之中，苟且偷生！
“超人”具有强力意志和旺盛的生命力，敢于冲破传统的旧思维模式，敢于冲破基督教道德的束缚，敢于和命运抗争，敢于做真正的自己！
在尼采看来，“超人”是人实现了自我超越后，走向一种更高级的种类的人。
“超人”还对传统价值观发起猛烈的进攻。没有什么道德和规则能束缚自己，所有的道德和规则就在自己的行动中产生，“超人”自己就是道德和规则的制定者。
人应该是一种被超越的东西。人自身也仅仅是桥梁，未来通向——“超人”！
13　尼采：不辜负这仅有一次的生命 意义是——去过一种审美的人生。
尼采生前曾说：“我的时代还没有到，有的人在死后才出生。”
只有被致命的摧毁，才能自由地创造。
1900年8月25日，尼采去世。
用尽一生去践行自己的哲学主张，耗尽全部生命热情去热爱生命本身！
如果说康德是一座不可逾越的通往古典哲学的桥，那么尼采则是一座不可逾越的通往现代主义及后现代主义的桥。可见，尼采对现代哲学的深远影响。
每一个不曾起舞的日子，都是对生命的辜负。
15　克尔凯郭尔：人生道路的三个阶段 审美境界、伦理境界和宗教境界
沉溺于感官的刺激中无法自拔，凭借自己的本能去生活，人的全部生活动机就是娱乐，这一阶段的最大特点就是“爱自己”。
伦理之人因为不能遵守道德而产生罪恶之感，人有了罪恶感就有了忏悔。这就到了人生的第三层境界——宗教境界。
人摆脱了世俗的诱惑，摆脱了伦理道德的理性制约，面对的只有上帝
11　杜威：真理是行动的指南 思想和理论是人的行为工具，其是否具有真理性，在于它们能否指引人们获得成功。
从我们日常经验来说，“工具”就是能帮助我们达到某种预期效果的东西。
思想和观念是人基于达到某种预期目的而进行的假设，也是人为了达到某种实践效果的工具。
思想和观念都具有工具性。
观念是指导行为的工具，观念的真理性在于其是否能指导人的实践，并获得实效。
真理是行动的指南。
当一个观念能够有效指导实践时，此观念便具有“真理性”。</description>
    </item>
    
    <item>
      <title>维特根斯坦传：天才之为责任</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E4%BC%A0%E5%A4%A9%E6%89%8D%E4%B9%8B%E4%B8%BA%E8%B4%A3%E4%BB%BB/</link>
      <pubDate>Wed, 28 Sep 2022 13:14:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6%E4%BC%A0%E5%A4%A9%E6%89%8D%E4%B9%8B%E4%B8%BA%E8%B4%A3%E4%BB%BB/</guid>
      <description>瑞·蒙克
序 看上去,对维特根斯坦的兴趣虽然很大,却不幸地分化为两极:独立于他的生活而研究他的工作的人;受到他的生活的吸引,却理解不了他的工作的人。 第一章 自我毁灭的试验场 “撒谎对自己有利的时候,为什么要说实话?” 第三章 罗素的爱徒 世界是一所牢狱,丹麦是一间最坏的牢房”;
冥想的宗教”可提供逃出困住人类生命的牢狱的办法。罗素的“冥想的宗教”指的不是对
上帝或不朽的信仰——即便醉心于极虔诚的奥特琳,他也不能相信那种事。他指的是一种与宇宙的神秘结合,在那种结合里,我们的有限自我得到克服,我们与无限合而为一。
你叫做上帝的东西正是我叫做无限的东西。
伸展出去,触到星辰,穿越时间,到达每一个你的爱为我照亮了世界的地方。
何种东西组成了世界
世界是事实的总和,而非物的总和。”
什么是逻辑”。
几乎肯定会做出许多有用的工作,但不是杰出的工作”——而维特根斯坦“充满了会使他无所不往的沸腾激情”
说自己每个早晨怀着希望开始工作,每个夜晚结束工作时却伴着绝望——当他不能理解事物时,他生出的正是我生出的那种愤怒
必须要么理解要么死,以及打断思考的极度紧张状态的突然蹦出的玩笑。
一面墙把他和真理隔开,他必须设法将其推倒。
他说喜欢哲学的人会做它,别的人不会,到此为止了
既然他有非同寻常的哲学天赋——自己有权这么做。
如果一个人最强烈的冲动是作曲,而且如果完全沉溺于这冲动能够写出崇高的音乐,那么他不只有权听从冲动而行动,他还背负着这么做的责任。
无论世界上发生什么,没有任何坏的事情能发生在他身上。他独立于命运和环境。
如果一个人的灵魂是纯粹的(对朋友不忠诚是一件令它不纯的事情),那么无论什么事“从外部”发生在他身上——即便是妻子跟别的男人跑了——都不能动他的自我分毫
于是最应该关心的不是外部事务,而是自我。
第七章 在前线 《逻辑哲学论》里对伦理、美、灵魂和生活意义的论述,其源头正是叔本华描述的“哲学反思的冲动”,刺激这种冲动的是对死亡、苦难和悲苦的认识。
上帝照亮我。上帝照亮我。上帝照亮我的灵魂。
用尽你的力气帮助自己和别人。而且同时要快活!但自己需要多少力气,别人又需要多少?很难好好活!!!但好好活是好的。但将得行的不是我的,而是你的[插图]意愿。
战争才对我真正开始。”
自己的生命一直处于危险之中,但靠着上帝的仁慈他活了下来。
几乎在岗的每一夜他都准备去死,并祈求上帝不要抛弃他,赐予他不畏惧地、直率地睁眼看死亡的勇气。只有那时他才能肯定自己体面地活着:“只有死亡给予生活意义。”
“一个真正信仰者的心理解一切。
一旦你觉得自己在恨他们,就转而努力去理解他们
因为他们永远误解。这些人不是愚蠢,而是狭隘。在他们的领域里他们足够聪明。但他们缺乏品质,从而缺乏宽度。
最后,他断定自己不恨他们——但他还是那样厌恶他们。
整个现代世界观念建于一个错觉之上:所谓自然法则是对自然现象的解释。
于是今日人们停在自然法则那里,视之为不可违背的,就像过去的时代看待上帝和命运一样。
而事实上两者都对也都错:尽管现代系统努力显得自己解释了一切,而古代的观点就其有一条清楚和公认的界限而言更为清楚。
对上帝和生命的目的我知道点什么?”
我知道世界存在。我处于其中,就像我的眼睛在眼睛的视域中。有关它的某事是成问题的,我们称之为它的意义。这意义不在它之中,而在它之外。生活就是世界。
我的意志渗入世界。我的意志是善的或恶的。于是,那善和恶与世界的意义有某种联系。生活的意义,即世界的意义,我们可称之为上帝。而与此相联系的是,把上帝比作父亲。祈祷就是思考生活的意义。我不能令世界里发生的事情屈服于我的意志:我是完全无能的。我只能让自己独立于世界——从而在一个特定意义上控制世界——通过拒绝对发生的事情施加任何影响。
个人的事和哲学的事融合起来了;伦理和逻辑——“对自己的责任”的两个方面——终于走到了一起:不只是同一个人目标的两个方面,而是同一哲学工作的两个部分。
面对死亡时的恐惧,是一种虚假的(即一种坏的)生活的最好标志。
现在,在自己经历过战争的全部恐怖之后,他似乎不仅需要一种宗教信仰,也需要一种哲学。
他不仅需要信仰上帝——向之祈求勇气和光照;他需要理解自己信仰的是什么。当他祈求上帝时,他在做什么?他在对谁祈祷?他自己?世界?命运?看起来他的回答是:三者都是:
事物如此这般(how things stand),是上帝。上帝是,事物如此这般
既指事物在世界中如此这般,也是指事物在自我中如此这般
自我是世界的小宇
宙
维特根斯坦对逻辑的思考和对生活意义的思索,这两者之间的联系将在他先前作出的说出和显示的区分中觅得。
生活问题的解答要随着这问题的消失而现身。这不就是之所以如此——在长久的怀疑之后明白了生活的意义的人却说不出这意义在于什么——的原因吗?
这是真的:人是小宇宙:我是我的世界。
占据他心思的是战争,还有他认识的参与战争的人遭受的苦难
无论收到什么,只要说明你还活着,我总是很高兴。
每一枪打来,我的全部存在都缩成一团。我多想活下去。
忘掉那个自我,被一种本能的、动物性的存活意志压倒是怎么回事,在这种状况下道德价值是不相干的:
那时我处于欲和怕的支配之下。
为什么你不去做?因为你是不理智的。坏的生活是不理智的生活。”
他向上帝祈求跟自己的软弱本性作斗争的力量
第二十三章 这个时代的黑暗 他随身带回了《西方哲学史》手稿,这本书虽然取得了巨大的商业成功(许多年里都是罗素收入的主要来源),但没有提高他作为哲学家的声誉。
维特根斯坦保持着对罗素智性之敏锐的钦佩,但厌恶罗素20世纪20年代以来出版的通俗著作。“
写数理逻辑的书用红色——每个哲学学生都应该读;写伦理和政治的书用蓝色——任何人都不得读。 罗素不会再拼命做哲学了</description>
    </item>
    
    <item>
      <title>苏菲的世界</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C/</link>
      <pubDate>Wed, 28 Sep 2022 13:14:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C/</guid>
      <description>乔斯坦·贾德
马克思 一世人劳苦奔忙有何益？到头来终究须把眼儿闭。
我们是活在一个长篇故事当中，一个由文字虚构的现实世界里。
共产主义 只有地位相当的人才能谈得上公平。
在他之后，哲学走到了一个新的方向，不再有庞大的思考体系，取而代之的是我们所称的‘存在哲学’与‘行动哲学’。
马克思的思想有一个实际的或政治的目标。我们可以说他不只是一个哲学家，同时也是一个历史学家、社会学家和经济学家。
在实际的政治方面，当然没有一个哲学家比他的影响力更大。但是我们要小心，不要把每一种自称是‘马克思主义’的学说都当成马克思自己的思想。
唯物论 我们的思考方式有一大部分受到社会中的物质因素的影响。此外，这类物质因素无疑也左右了历史的发展。
历史的发展是受到两种相反事物之间的紧张关系的驱动，因为这种紧张关系后来一定会被一个突然的改变消除。
黑格尔把推动历史前进的力量叫做‘世界精神’或‘世界理性’。
他想证明物质的变化才是推动历史的力量：‘精神关系’并不会造成物质的改变，而是物质的改变造成了新的‘精神关系’。
促成改变并因此把历史向前推进的，其实是一个社会的经济力量。
马克思将这些物质、经济和社会方面的条件称为社会的基础，并将社会思想、政治制度、法律规章、宗教、道德、艺术、哲学和科学等称为社会的上层构造。
马克思相信物质条件‘支持’着一个社会里的每一种思想和看法。事实上，一个社会的上层结构正好反映那个社会的基础。
社会的基础与它的上层结构之间有一种互动关系。如果他否认了这种互动关系的存在，那他就是一个‘机械论的唯物主义者’。但正因为马克思体认到社会的基础与它的上层结构之间有一种互动的辩证关系存在，我们才说他是一个辩证的唯物主义者。
最‘根本’的一个阶层就是一个社会的‘生产条件’，也就是这个社会可以利用的自然条件与资源。
‘生产条件’之外的另一个阶层就是一个社会里的‘生产工具’。
社会基础的下一个阶层，也就是那些拥有生产工具的人。
一个社会的政治情况与意识形态是由它的生产模式决定的。
一个社会的是非标准主要是由那个社会里的统治阶级来决定的，因为‘人类社会的历史就是一部阶级斗争史’
历史所牵涉的主要就是一个谁拥有生产工具的问题。”
马克思明白社会上层结构与社会基础之间可能有互动的关系，可是他否认社会的上层结构能够有其独立的历史。
阶级斗争 人与自然之间有一种互动或‘辩证’的关系
当人改造大自然时他本身也被改造了。
人在工作时，就是在干涉大自然并影响大自然，可是在这个过程中，大自然同时也干涉人类并影响他们的心灵。”
我们的工作方式影响我们的心灵，但我们的心灵也影响我们的工作方式。可以说这是人手与人心的一种互动关系。因此你的思想与你的工作是有密切的关系的。
从某个角度说，一个失业的人就是一个空虚的人。
对于黑格尔和马克思而言，工作是一件具有正面意义的事情，并且与人类的本质有密切的关系。”
在资本主义制度下，工人是为别人工作。因此他的劳动对他而言是外在的事物，是不属于他的。工人与做的工作之间有了隔阂，同时与自我也有了隔阂。他与他自己的现实脱节了。马克思用黑格尔的话来说，就是工人被疏离了。
如果她讨厌自己的工作，从某一方面来说，她也一定讨厌她自己。
在资本主义社会的工厂制度中，工人实际上是为另外一个社会阶级在做牛做马。在这种制度下，工人把他的劳动成果以及他的整个生命都转移给中产阶级。”
工作原本应是人类光荣的标记，但在当时工人却变成了牛马。
资本主义者把事实上是由工人创造的价值放进了自己的口袋。这就叫作剥削。
资本主义者又把一部分的利润拿来作为资本，将工厂加以现代化，以期生产成本更低廉的商品，并借此增加他将来的利润。
资本主义是一种自我毁灭式的经济制度，因为它缺少理性的控制。
他购买新的机器后，就不再需要这么多员工了。他这样做是为了提高他的竞争力。
工厂所需的工人愈来愈少，表示失业的人愈来愈多，社会问题将因此而增加。
如果所有的资本主义者都像你一样聪明（事实上他们也是），工人们就会变得很贫穷，以至于买不起东西了。这样一来，购买力就降低了，而这种情况会变成一种恶性循环。
有一段时期会出现新的‘阶级社会’，由无产阶级以武力镇压中产阶级。马克思称此为无产阶级专政。
我们这个时代 人是注定要受自由之苦的…
意识是什么？它难道不是宇宙的一个大谜题吗？记忆又是什么？是什么东西使我们“记得”我们所看到、所经验到的每一件事情？
导出于 2022-09-28 13:14:31</description>
    </item>
    
    <item>
      <title>西方哲学十五讲</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8D%81%E4%BA%94%E8%AE%B2/</link>
      <pubDate>Wed, 28 Sep 2022 13:14:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8D%81%E4%BA%94%E8%AE%B2/</guid>
      <description>张志伟
第一讲 智慧的痛苦 人们通常将世界上的哲学形态分为三种主要类型：西方哲学、中国哲学和印度哲学。
按照“哲学”这个概念的起源和比较严格的意义，哲学就是西方哲学。
实际上，作为西方哲学两大源头的希腊哲学和基督教思想，都起源于世界的东方。
哲学与意识形态的关系太密切了，以至于一说到哲学问题，几乎就变成了政治问题，人们只好三缄其口。
哲学是自由思想，条条框框的限制不可能出哲学家，这也就是为什么我们现在没有真正意义上的哲学家的主要原因之一
哲学是什么。
有多少哲学家就有多少种关于哲学的定义，而且相互之间从来没有达到过起码的共识。
哲学简直就是“一切人反对一切人的战场”
哲学不具有任何科学的基本特征，因而哲学不是科学，这是批评哲学的人的一件百试不爽的致命武器。
按照哲学的本性而论，哲学不是让人有智慧，而是让人知道自己没有智慧因而去追求和热爱智慧的学问。
哲学问题并不是世界本身产生出来的问题，而是人产生出来的问题，不过它们并不是哲学家闲极无聊制造出来显示自己智力的东西，其实都来源于我们的日常生活。
看起来我们都知道“我是谁”，然而“我”在哪里呢？“我”究竟是心灵还是身体，抑或是心灵与身体的统一？心灵在成熟，身体也在生长，这是不是说“我”也始终在变化呢？如果“我”是变动不居的，“我”与“我”自己有没有同一性呢？
实际上，日常生活中许多看上去不证自明的东西都是经不起追问和推敲的。
第十二讲 社会政治理论 1755年他的第二篇论文《论人类不平等的起源和基础》
卢梭在哲学上的主要贡献是他的社会政治学说，围绕着“社会不平等的起源和基础”与“克服社会不平等的途径”这两个主题，他通过《人类不平等的起源和基础》与《社会契约论》阐发了独具特色的思想。
处在“自然状态”中的自然人或野蛮人是孤独的，相互之间没有交往和联系，因而不需要语言；两性的结合是完全偶然的，没有固定的居所，不存在家庭；没有农业和工业，没有战争，除了生理上的差异而外彼此自由平等，因而处在和平状态之中。这样的野蛮人的全部欲望表现为肉体的需要，这就是食物、交媾和休息。在自然人的心灵中有两个最原始的原则：自我保存和怜悯。自然法的一切准则都是从这两个原则产生出来的。人类在不知道社会、私有制和家庭，因而没有“你的”和“我的”的观念的状态下度过了许多世纪。
更重要的是，导致人类不平等的根源，即私有制终于产生了。
使人文明起来，而使人类没落下去的东西，在诗人看来是金和银，而在哲学家看来是铁和谷物。
谁第一个把一块地圈起来并想到说：这是我的，而且找到一些头脑十分简单的人居然能相信了他的话，谁就是文明社会的真正奠基者。
正是由于私有制的产生，人类从此便由自由平等的自然状态陷入了没有自由和平等的社会痛苦之中。
在人类中有两种不平等，一种是自然不平等，即生理上的不平等，一种是社会不平等，即精神上或政治上的不平等。
第十四讲 费希特和谢林 德国古典哲学有四位主要代表人物：康德、费希特、谢林和黑格尔。
哲学史上有时将从康德到黑格尔的哲学运动称为“德国唯心论”，他们的哲学思想应该是一脉相承的。
人们一方面将费希特、谢林和黑格尔看做是康德的继承者，另一方面亦意识到他们的思想在许多方面是如此的不同，以至于把康德与他之后的德国哲学是否归属于同一个哲学思潮，总令人有些犹豫不决。
应该怎样看待康德之后的德国哲学与康德哲学之间的关系？
想想看，一个名不见经传的年轻人写出来的文章居然被误认为是康德的著作，还有谁比他更理解康德哲学？
一是在主体之外有一个不可知的自在之物（物自体），作为感觉经验的根据；一是在主体之中有一个同样不可知的先验自我，作为一切先天综合知识的逻辑根据，而实际上这个先验自我也就是《实践理性批判》中道德的意志本体。
哲学的任务是说明一切经验的根据，因而哲学就是认识论，费希特称之为“知识学”（Wissenschaftslehre）
导出于 2022-09-28 13:14:31</description>
    </item>
    
    <item>
      <title>论婚姻与道德</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E8%AE%BA%E5%A9%9A%E5%A7%BB%E4%B8%8E%E9%81%93%E5%BE%B7/</link>
      <pubDate>Wed, 28 Sep 2022 13:13:34 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E8%AE%BA%E5%A9%9A%E5%A7%BB%E4%B8%8E%E9%81%93%E5%BE%B7/</guid>
      <description>伯特兰·罗素
第一章 导言 在定义一个社会时，无论是古代的还是现代的，必须关注两个紧密相关的要素：经济制度和家庭制度。
一个将一切归因于经济，另一个则认为家庭或性是一切的根源，前者是马克思学派，后者是弗洛伊德学派。
经济在本质上与获取食物密切相关，但人类获取食物极少只是为了食物获得者个体的利益。
如果国家取代了父亲的作用，那么国家实际上就成为唯一的资产拥有者。
如果国家成为唯一的资产拥有者，那么家庭将无法存在。
第一个层面是法律规定的内容。
接下来的层面是法律并不干预但公众态度起重要作用的内容
最后一个层面是由个体自行决定的内容，这种自行决定即使在理论上没有明确的规定，在实际中却已付诸实践。
最好的性道德在不同气候的国家不尽相同，在不同饮食习惯的国家也大有差别。
性道德的影响是多方面的——个人、夫妻、家族、国内、国际。
大部分人认为，相较于纯肉欲的性关系，心理因素占一定比重的性关系是更合适的。
大部分现代人认为爱应当是一种平等关系，因此一夫多妻制自然不可能被认为是一种理想制度。
性道德的最初动机是为了确保女性的贞洁。
第五章 基督教伦理 婚姻根植于家庭，而非家庭根植于婚姻
婚姻的存在不仅仅是为了繁衍后代，也是为了阻止淫乱之罪。
哥林多前书
丈夫当用合宜之份待妻子，妻子待丈夫也要如此。
倘若自己禁止不住，就可以嫁娶。与其欲火攻心，倒不如嫁娶为妙。
他认为基督的再次降临近在眼前，世界将很快走向末日。
圣保罗认为性关系是人们获得拯救的某种障碍，即使是婚姻中的性关系亦如此
婚姻能使意志薄弱的教友们抵抗住诱惑
在他的思想中，私通占据核心位置，他所有的性伦理都围绕于此。
基督教谴责所有私通行为
人们鄙视有婚外性行为的女人，但男人却不受指责，除非对方是有夫之妇。在这种情况下，男人被指责是因为他侵犯了别人的财产。
所有的性行为，即使是婚内的，都令人遗憾。
心智正常的人看来，这种违背生物学事实的观点是一种病态的精神失常。
为了修复死亡带来的破坏，自然赋予人类婚姻这种关系。
性却总被视为亚当堕落的恶果，婚姻也总被放在最低的位置。
女性象征着地狱之门，也象征着所有人类病毒的根源。
女性本质上的从属地位一直延续下来。
第六章 浪漫的爱情 古代世界是邪恶的，但并不残忍。
女修道院像妓院，里面有大量的杀婴事件；乱伦这一恶疾在教士中盛行，因此教会必须一遍遍地发布最严格的戒律来禁止教士和自己的母亲或姐妹生活在一起。
教会贡献了知识、哲学、教会法规、基督教世界统一的理念，所有这些都是地中海古代传统的不断延续。凡人则贡献了习惯法、世俗政治体制、骑士精神、诗歌和罗曼史。其中最令我们关注的是浪漫的爱情。
浪漫爱情的关键是将深爱的对象看成是极难拥有且极为珍贵的，因此要付出巨大的努力才能得到所爱之人的心，这种努力或是诗歌、歌谣，或是武力，抑或是其他任何会令所爱之人感到极度愉悦的方式。
当浪漫的爱情在中世纪出现时，它所指的对象并不是那些男人们可与之发生合法或非法性关系的女人，而是那些高高在上、被不可逾越的道德或传统鸿沟隔离开的女性。
第十章 婚姻 婚姻不同于其他性关系，它是一种法律制度。
动物们实践的是一种事实上的婚姻
首先打破原始社会一夫一妻制的可能是经济因素，无论这个因素是否对性行为产生任何影响，它都一定是灾难性的，因为它用一种奴役或是购买的关系取代了基于本能的关系。
与有夫之妇发生性行为依然被视为对其丈夫的冒犯，但任何婚姻之外的性行为则被视为对上帝的冒犯，在教会看来后者是更严重的问题。
在大多数野蛮民族中25岁的女性已经是老年了，不可能指望她们到了那个年纪还保持一丝美丽的痕迹。
女人是家畜
文明程度越高，人就似乎越不可能在一个伴侣身上获得终生的幸福。
人与人之间的区别越少，婚姻就越容易。当男人与男人之间、女人与女人之间没有什么不同，就没有理由遗憾另娶或是另嫁了他人。
我想不受约束的现代人，无论男女，通常在本能上都是倾向于多配偶的。
在没有宗教约束的情形下，机会促成了想法，想法催生了欲望，欲望导致了行动。
相反，妻子必须是贞洁的，如果丈夫知晓了妻子的外遇行为，那婚姻就破裂了。
如果一个人把自己的心灵关闭在婚姻之内，拒绝任何来自别处的爱，他的感受性、同情心，以及获得与他人有价值交流的机会都将降低。
哪怕婚姻没有成为幸福的阻碍，它也必须以某种新的方式被重新认识。人们常常建议的一种解决方式是简易地离婚，这在美国已经被大量尝试。
对于没有孩子的婚姻，即使夫妻双方都尽可能地循规蹈矩，离婚往往是正确的解决方式。但如果婚姻中有了孩子，它的稳定是十分重要的。
婚姻如果是基于热烈的爱情，并且孕育出双方都渴望和珍爱的孩子，这种婚姻一定会在夫妻之间产生一种紧密的联系。即使性的激情逐渐退去，甚至某一方或双方都对其他人有了性冲动，但双方依然能感受到在对方的陪伴中所获得的某种尤为珍贵的东西。
一段历经多年、共度风雨的陪伴包含着丰富的内涵，这是那种爱之初体验无法拥有的，无论后者是多么令人感到愉悦。任何明白岁月能提升价值的人都不会为了新的爱情轻易地抛弃这种伴侣关系。
夫妻双方都感受到完全的平等，不干涉彼此自由，身心完美地融合，价值观相似。
丈夫和妻子都把自己看成是监督对方的警察。
要使婚姻实现其最好的可能，丈夫和妻子都必须明白，无论法律如何规定，在个体生活中他们必须是自由的。
第十一章 卖淫 只要社会将高贵女性的品德视为十分重要的事，婚姻制度就不得不需要另一种制度的补充，那就是卖淫业。
妓女是家庭圣洁及妻女纯真的守护者。
对妓女的需求源于这样一个事实，一些未婚男性或是远离妻子行走在旅途之中的男性不愿禁欲，但在传统的道德社会中他们无法找到高雅的女性来满足自己的生理欲望。
妓女的优势不仅在于她随叫随到，而且由于她在这份职业之外别无生路，因此可以毫不费力地隐藏自己。
对这个可怜的女人而言，尽管她提供了毋庸置疑的服务，尽管她捍卫了妻女们的贞洁和教会执事们的美德，她却受到众人的鄙视，被认为是个异类，除了性交易外无法与普通人交流。</description>
    </item>
    
    <item>
      <title>历代经济变革得失</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E5%8E%86%E4%BB%A3%E7%BB%8F%E6%B5%8E%E5%8F%98%E9%9D%A9%E5%BE%97%E5%A4%B1/</link>
      <pubDate>Wed, 28 Sep 2022 13:12:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E5%8E%86%E4%BB%A3%E7%BB%8F%E6%B5%8E%E5%8F%98%E9%9D%A9%E5%BE%97%E5%A4%B1/</guid>
      <description>吴晓波
洋务运动不是一场“迟到的运动” 在中国开始洋务运动的19世纪60年代中期，后来成为全球最强经济体的三个国家——美国、德国以及日本——也刚刚完成了国家的统一，并相继开始它们的现代化之旅。 国民党的经济主张 与北洋政府相比，国民党政府最大的区别是有主义、有信仰，对国家治理有系统性的思考和道统上的自信。
发展国营经济，节制民间资本
国民党政府的计划经济思想来源于“国父”孙中山。
第十一讲 改革开放（上）：没有蓝图的改革 它实际上是一场且行且思、边做边改、“没有蓝图的改革”。
西欧人和日本人不像苏联人那样“无私”，中国脆弱的工业基础和虚弱的消费能力让他们畏而却步。
意识形态的顽固抵抗、旧体制的低效率、找不到新的资金和人才，更可怕的是，没有成熟而合适的经济理论、改革经验可依据和借鉴。
第三种社会主义经济模式 其一，斯大林—毛泽东式的命令型计划经济模式。
其二，市场社会主义模式。
陈云是公认的“计划经济大师”，他晚年的思想近似于市场社会主义，提倡“鸟笼经济”，即在计划的“大笼子”内，给予国营企业以充分的经营自主权，对于私营资本集团的复活，他一直持谨慎和警惕的姿态。
邓小平更加务实和功利。只要能够使经济发展起来，他愿意尝试一切新的可能性。
他说“不争论”，表明新的改革措施在意识形态领域遭遇到了空前的阻力，无法在原有的社会主义理论体系内自圆其说，因此必须“干了再说，错了再改”。
在经济领域推动变革的同时，邓小平与陈云也对政权的稳定和共产党执政地位的维持达成了高度的共识。
坚持“四项基本原则”和“稳定压倒一切”，这两句话划出了本次经济改革的政治边界，即维持现有的威权及大一统的政治治理模式。
本次改革的几个基本特征：功利务实、被动渐进、非均衡、不彻底。
增量改革：由农民发动的工业化运动 数以百万计的没有受过任何工业化教育的农民崛起于草莽之间，成为了计划经济的“掘墓人”。
土地出产之少，主要不在于土地肥沃程度，而在于居民是否享有自由。
以承包制的方式把土地“还”给农民，是一次不彻底的土地改革，它没有触及土地性质，为日后的土地纠纷埋下种子。
包产到户让农民从土地的束缚中解放出来，在土地严重缺乏而观念较为领先的东南沿海地带，大量闲散人口开始从土地中“溢出”，
民营经济在1956年“绝种”之后的再度复活，它们在制造、流通及金融三大环节对铁桶般的计划经济体系实施了“蚂蚁咬堤”式的侵蚀和破坏。
中央政府的角色：放权与非均衡战略 20世纪80年代的改革是一场政府放任自流、无为而治的民间经济运动。
真实的情况是，国民经济的恢复是“中央充分放权、地方大胆主导，民间积极参与”的过程，中央政府和地方政府分别扮演了促进者和主导者的角色。
放权让利的对象是国营企业和地方政府，其目标则是刺激经济要素的复苏和减少中央财政支出。
在整个20世纪80年代，非均衡成为一种基本的改革思路，特区、开发区模式是资源配置上的一次非均衡，“东南优先”是区域经济发展的一次非均衡，“让一部分人先富起来”是财富分配的一次非均衡，给予外资以土地征用和税收上的“超国民待遇”是企业经营上的非均衡，企业试点是政策配置上的非均衡，价格双轨制则是对国营企业实施价格保护的非均衡。
经济权力的次第下放以及非均衡战略的实施，意味着自由贸易精神的回归，它在对计划经济体系构成冲击的同时，一定会对大一统的思想体系也形成挑战，在这一方面，决策层表现出强硬的一面。
这两位领导人尽管在经济思想上有不少的分歧，但在共产党执政地位的维护和思想的控制上，两人的立场和态度基本一致。
地方政府的角色：积极参与和冒险支持 他甚至认为，“今天的中国，主要的经济权力不在村，不在镇，不在市，不在省，也不在北京，而是在县的手上”。
地方政府公司主义
在大一统的集权制度下，中央政府与地方政府有各自的行政诉求，他们在经济发展的过程中存在着博弈和互相补充的关系，政府从来没有放弃对经济的干预与掌控。
“哪里是改革的主战场” 一派意见认为，改革的主战场应是企业制度的股份制创新，是为“企业主体改革派”，代表人物为北京大学的厉以宁教授。
在中国经济学家中，厉以宁是最早提出企业改革必须走股份制道路的人之一，因此，他被称为“厉股份”。
另一派意见认为，中国的经济改革靠企业制度的“单兵突进”难全其功，因此必须整体思考，配套进行，是为“整体协调改革派”，代表人物为国务院发展研究中心的吴敬琏。
在吴敬琏的构思中，改革不仅是一场破除旧体制的深刻革命，而且是一项建设新经济体系的宏大工程。这个体系主要是由自主经营、自负盈亏的企业，竞争性的市场体系和主要通过市场进行调节的宏观管理体系三者组成。
既然中国改革的正确方向是建立市场型经济，应当追求的分权就只能是经济性分权，而不能是行政性分权。
单搞企业改革，无论什么方案，都是不足够的，因为“如果企业不是在竞争性市场的约束下进行经营活动，没有竞争压力，无论建立怎样的产权制度，企业都不可能真正具有活力”。
吴敬琏、厉以宁基本上都是在经济体制改革的范畴内思考出路，
经济体制改革要以政治体制改革为条件，必须从制度上采取措施，才能保证不再回到旧轨道上去。归根结底，改革是政治和社会问题。
物价闯关：转折点上的“意外失利” 价格
双轨制的弊端彻底暴露，非法倒卖物资的活动猖獗，国有企业的承包制改革始终未见大成效，亏损补贴和物价补贴相当于财政收入的三分之一，企业经营困难，财政负担加重。
“管住货币、放开物价”的意见，决意冒险“闯关”，让物价迅速地进入市场调节的轨道之中。
“物价闯关”被认为是中国告别命令型计划经济的关键性一役，若此战成功，则意味着国家把定价权还给了市场，随着价格管制的彻底解体，计划经济体制将无凭借之地
社会心理决定了人类的永久的经济问题”
1988年的物价闯关失败，是1978年改革以来最大的一次经济失控，也是新中国经济改革史上最让人沮丧的事件之一。
“闯关”失利使得中国与全球的民主化浪潮擦肩而过。
1989年春夏之际，社会矛盾空前激烈的中国发生了一场政治大动荡。
80年代：“一切改革都从违法开始” 就历代经济变革而言，20世纪80年代堪与西汉“文景”、唐初贞观以及民国初期相比，是国史上少数的民营经济得到鼓励发展之时期，
随着民间财富增加和有产者阶层的再度归来，中国似乎在一夜之间成为一个世俗社会，人们对物质的追求变得越来越炽烈，信奉“时间就是金钱”，金钱可以像时间一样衡量一切价值。
在放权让利的过程中，历史上一再出现过的景象也毫无悬念地重现，那就是权威旁落，中央财政长期处于窘迫的赤字状态
苦乐不均的结果，自然造成各自为政、“诸侯经济”泛滥的混乱局面，妨碍了国内统一市场的形成和市场经济的发展，各省俱以邻为壑，为争夺资源打得不可开交，
正是在这样的背景下，“弱中央、强地方”、“弱政府、强民间”的模式遭到质疑，经济集权主义成为必然性的选择。
第十二讲 改革开放（下）：集权主义的回归 自此之后，改革目标已转移为加强执政集团的领导能力，增强控制力以及在发展中获得更多的利益，于是，中央向地方收权，政府与民间争利，集权主义再度归来。
在他的治理下，经济变革呈现出鲜明的集权化特征。
分税制：从增量改革到整体改革 必须把改革的对象与重点放在体制之内，使之与蓬勃发展中的、市场化的体制外力量形成制度性的匹配。
将沿用多年的财政包干制改造为新的分税制，从而改变中央政府与地方政府的财政及税收关系。
以分税制取代财政大包干制，目的就是改变中央政府在收入分配上的被动局面。</description>
    </item>
    
    <item>
      <title>论中国</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E8%AE%BA%E4%B8%AD%E5%9B%BD/</link>
      <pubDate>Wed, 28 Sep 2022 13:12:47 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E8%AE%BA%E4%B8%AD%E5%9B%BD/</guid>
      <description>亨利·基辛格
中国人的实力政策与《孙子兵法》 在漫长的动荡历史中，中国的统治者认识到，不是所有的问题都能得到解决，过分强调对具体事件的完全驾驭有可能会打乱大同世界的平衡
潜在的敌人比比皆是，帝国永远不可能享有绝对安宁
在陷于冲突中时，中国绝少会孤注一掷，而依靠多年形成的战略思想更符合他们的风格
西方传统推崇决战决胜，强调英雄壮举，而中国的理念强调巧用计谋及迂回策略，耐心累积相对优势。
《孙子兵法》为文言文，介乎诗歌体与散文体之间。该书问世已两千余年，然而这部含有对战略、外交和战争深刻认识的兵法在今天依然是一部军事思想经典。
孙子为此跻身世界最杰出的战略思想家行列。甚至可以说，美国在亚洲的几场战争中受挫，一个重要原因就是违背了孙子的规诫。
不战而屈人之兵，善之善者也。故上兵伐谋，其次伐交，其次伐兵，其下攻城。攻城之法，为不得已。
魏源的蓝图：“以夷制夷”，师夷长技 中国既要对付拥有先进技术的欧洲列强的侵略，又要对付野心勃勃的俄国和日本。
面对强敌及其贪得无厌的要求，中国的外交家认识到，他们守定的虽是屈辱的条约，却可限制洋人无休止的勒索。
大权旁落：内乱外患 过去70年来中国对西方国家关系准则的抵制现在演变为一场真正的危机。外交拖延的手法已经用尽，动武又遇到比自己更强大的武力。
俄国的总体目标远不止于传教或在沿海一带通商。俄国从清朝的衰落中看到了肢解中华帝国，重新吞并其“外疆”的机会。
它尤其垂涎于管辖薄弱、边界划分模糊的、广袤的满洲（位于中国东北部的满洲腹地）、蒙古（位于中国北部的大草原，当时是半自治的部落）和新疆（中国西部广阔的山脉和沙漠，当地居民主要是穆斯林）。为达此目的，俄国有计划地沿以上疆界逐步扩张，对当地王公封官授爵，贿赂收买，同时又用一支强大的骑兵部队示以威胁，诱逼他们效忠俄国
，在一个中国积贫积弱的时代，“以夷治夷”也是要付出代价的。
应对衰落 在这数千年的历史长河中，征服者要么被迫接受中国文化，要么逐渐淹没在被征服者的海洋中，而中国人的耐心遮掩了他们务实的特点。
以和好为权宜，以战守为实事。”￼
虽然英国构成了眼下的实际威胁，然而就对中国国家完整的长期威胁而言，恭亲王在奏折中把英国置于末尾，而将俄国置于首位：
日本与西方初次相遇时，已经走上工业化道路并显示了社会凝聚力。而李鸿章却无法选择这条路，他自己的国家因一场起义山河破碎。为了镇压这场起义，他需要外国的帮助。再者，李鸿章也不会放弃自己的儒家传统，无论这样做能带来多大的好处。
李鸿章和同时代任何一位大臣一样，笃信中国道德价值观的优越性和帝国传统特权的正义性
目前时局，外须和戎，内须变法。倘若依旧固守成规，不思变革，国家日衰矣。各国一变再变而蒸蒸日上，独中土为守法为兢兢，即败亡绝而不悔。￼ 中国面对的一个迫在眉睫的挑战，就是东北亚均势中又多了一个新成员——正在迅速工业化的日本。
日本的挑战 日本是一个岛国，距亚洲大陆最近处不过百十英里，在长期隔绝中形成了自己的传统和独特的文化。
因此日本和中国一样，认为自己远不是一个普通的国家
在中国的宇宙观里，人类只有一个皇帝，他的御座在北京。
如果说中国的例外主义是一个自诩驾驭万邦的帝国的体现，日本的例外主义则源于一个岛国的不安全感
日本领导人沿袭了这一最具中国特色的体制，作为与中国分庭抗礼的手段。￼
日本政治家的优越感不在中国朝廷之下，但认为日本犯错误的空间远比中国小
日本的外交政策因而在以下两者之间摆动，有时变动突如其来，要么与亚洲大陆不即不离，要么兴兵征伐，以求取代以中国为中心的秩序。
日本人眼看中国这个庞然大物日益外强中干，开始谋划取代中国，称雄亚洲。
朝鲜 中华帝国虽疆土辽阔，但并不指手画脚地去干预他国事务。它要求他国纳贡并承认中国的宗主国地位，然而朝贡的象征意义大于实质意义，且中国行使宗主国权力时，允许藩属享有近乎独立的自治地位
日本同样把外国对朝鲜的控制视为一个潜在的威胁，朝鲜半岛好似从亚洲大陆插向日本的一把尖刀
多亏一个日本刺客的子弹，中国才免于更屈辱的结果。在谈判地点，子弹擦着李鸿章的面颊而过。日本政府出于羞愧，放弃了几条更苛刻的要求。
义和团运动和军阀混战的时代 在华角逐的诸列强中，只剩下了一个，然而却是对中国独立构成威胁最大的一个——日本。中国的力量不足以保卫自己，而又没有任何一国可以在军事上制衡日本
日本现在陷入昔日征服者的境地。征服如此庞大的一个国家已属不易，若不借重这个国家的一些文化观念去统治它则更不可能。而日本认为自己的体制独一无二，绝不会求助于中国的文化观念
只要中国能够挺过第二次世界大战，它就可以走出帝国主义阶段，再次实现统一
苏联选择了承认国民党政府，但又向共产党提供武器，脚踩两只船
政治家都需要在过去的经历和未来的需要之间寻求平衡，最能证明这一点的莫过于刚刚执掌中国的毛泽东和共产党
第四章 毛泽东的革命 在数千年的中国历史中，朝代更替节奏鲜明。旧朝的没落始于它不能再奉天命，保平安，泽苍生。通常不是一次大灾难，而是一系列祸国殃民的行径使得民间积怨，当朝天子在百姓眼中无德再膺天命。新朝则成为天命的承启者，其实只是因为它坐了江山。
在中国跌宕起伏的历史中，这样的动荡屡见不鲜，但没有一个新皇帝想过要把整个社会的价值制度推翻。
他们沿用过去的官僚制度，目的无非是治理这个世界上人口最多、最富庶的国家。正是这个传统推动了汉化的进程，并把儒家学说确立为治国之本。
毛泽东及其大同的理念 革命他所深恶痛绝的繁复的官僚体系——毛泽东几次起来把这种体系打碎了，但随后又
不得不重新建立起来
如果继续革命的理论不打折扣地完全实行的话，那么这个国家就会动荡不已，甚至可能陷入战乱之中。重视稳定的国家会联合起来反对它。但如果它试图构建一个对别国开放的国际秩序，或加入现存的国际秩序的话，那么与献身于继续革命的人的冲突就在所难免。这个难题困扰了毛泽东一生，最终也没能解决。
毛泽东的国际关系学：空城计，中国式威慑和心理战 苏联是新中国意识形态上的盟友，起初，中国也需要苏联作为战略伙伴来制衡美国。但是，中国的领导人没有忘记过去的100年间沙俄通过一系列“不平等条约”夺取了远东沿海的领土，占有了从满洲到新疆的特别势力区；他们也没有忘记苏联依然声称它在1945年谈判战时协议时迫使蒋介石就中国北方领土做出的让步继续有效。
收复台湾与其说是出于共产主义意识形态，毋宁说是因为它自古以来就是中国的领土。
但他宣布新中国对19世纪的“不平等条约”下割让出去的领土——比如1860年和1895年条约中割让给沙俄的中国远东领土——拥有主权。
令外部世界惊诧的是，任何国家或国家集团，无论属于哪个意识形态阵营，只要中国政府认识到它在中国周边布下了太多的“棋子”，毛泽东就要冲破包围圈。
尽管毛泽东的许多思想和做法在中国历史中都有迹可循，但历史上从来没有哪一个执政者能像毛泽东那样集传统、权威、冷峻和全球视角于一身。
“文化大革命”和中国人民 毛泽东的追求最后导致他在社会主义社会里发动了一系列的政治革命运动，尽管针对的是他自己一手建立的制度。
为确立中国的历史独特性，还需要不断改变党内秩序和社会秩序
毛泽东强调，社会主义中国绝不能发生和平演变
无论世界风云如何变幻，中国人民都能坚持其民族精神不坠。
现代技术的本质是普及同化，这对任何社会的独特性都是威胁，而中国社会恰恰以独一无二为标榜。为了维护这个独一无二的特点，中国在19世纪拒绝效仿西方，结果几近沦为殖民地，饱受列强凌辱。
第五章 三角外交和朝鲜战争 其实斯大林并不想帮助中国恢复经济，他还没有忘记南斯拉夫领导人铁托的叛离。铁托是欧洲唯一靠自己的力量，而不是靠苏联占领获得政权的共产党领导人
中国共产党在内战中胜出为苏联所始料不及，而且胜利还是在无视苏联劝告的情况下取得的。尽管毛泽东宣布在国际事务中，中国会“一边倒”——倒向苏联，但是，在所有的共产党领导人中，他是最不必仰息苏联的，因为他掌管着人口最多的社会主义国家。
这时的斯大林已经不再理会意识形态，而是根据他对苏联民族历史的残酷解读，靠无情、多疑的马基雅维利主义的统治方法治国。</description>
    </item>
    
    <item>
      <title>三体（全集）</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E4%B8%89%E4%BD%93%E5%85%A8%E9%9B%86/</link>
      <pubDate>Wed, 28 Sep 2022 13:12:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E4%B8%89%E4%BD%93%E5%85%A8%E9%9B%86/</guid>
      <description>刘慈欣
第三章 射手和农场主 射手”假说：有一名神枪手，在一个靶子上每隔十厘米打一个洞。设想这个靶子的平面上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律：“宇宙每隔十厘米，必然会有一个洞。”它们把这个神枪手一时兴起的随意行为，看成了自己宇宙中的铁律。
“农场主假说”则有一层令人不安
的恐怖色彩：一个农场里有一群火鸡，农场主每天中午十一点来给它们喂食。火鸡中的一名科学家观察这个现象，一直观察了近一年都没有例外，于是它也发现了自己宇宙中的伟大定律：“每天上午十一点，就有食物降临。”它在感恩节早晨向火鸡们公布了这个定律，但这天上午十一点食物没有降临，农场主进来把它们都捉去杀了。
第七章 疯狂年代 在中国，任何超脱飞扬的思想都会砰然坠地的，现实的引力太沉重了。 第八章 寂静的春天 人类真正的道德自觉是不可能的，就像他们不可能拔着自己的头发离开大地。要做到这一点，只有借助于人类之外的力量。 第十章 宇宙闪烁之二 越透明的东西越神秘，宇宙本身就是透明的，只要目力能及，你想看多远就看多远，但越看越神秘。
也许是全世界的彻底毁灭，在这个变态的宇宙中，那倒对谁都是一种解脱…
第十一章 大史 所有这一切，都有且只有一个后台，它想把科学研究彻底搞垮。” “谁？”
破坏科研设施，杀害科学家；或让你们自杀，让你们发疯……但主要还是让你们往歪处想，这样你们就变得比一般人还蠢。”
“不过谁都有怕的东西，那个狠角色也有；越厉害的角色，它怕的东西对它就越致命。”
但最有效的办法还是扰乱你们的思想，人死了还会有别人，但思想乱了，科学就完了。”
第十二章 三体、墨子、烈焰 文明的种子仍在，她将重新启动，再次开始在三体世界中命运莫测地进化，欢迎您再次登录。 第十四章 红岸之三 发送信息应通过多学科严格审查，确保不会包含任何太阳系在银河系中的坐标信息。在三个发射频率中，尽量减少12000兆赫、22000兆赫的高频段发射，以减小被定位的可能性。 第十五章 红岸之四 宇宙中真的只在地球上有智慧生命？”
地球生命真的是宇宙中偶然里的偶然，宇宙是个空荡荡的大宫殿，人类是这宫殿中唯一的一只小蚂蚁。
有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。
第十七章 三体问题 空不是无，空是一种存在，你得用空这种存在填满自己。 第二十章 三体、爱因斯坦、单摆、大撕裂 如果连三体这样极其简单的系统都处于不可预知的混沌，那我们还怎样对探索复杂宇宙的规律抱有信心呢？”
上帝是个无耻的老赌徒，他抛弃了我们！
第二十二章 地球叛军 消灭人类暴政
人类社会已经不可能依靠自身的力量解决自己的问题，也不可能凭借自身的力量抑制自己的疯狂；所以，应该请主降临世界，借助它的力量，对人类社会进行强制性的监督和改造，以创造一个全新的、光明完善的人类文明
降临派有自己的秘密纲领，它就是：人类是一个邪恶的物种，人类文明已经对地球犯下了滔天罪行，必须为此受到惩罚。降临派的最终目标就是请主来执行这个神圣的惩罚：毁灭全人类！”
你们截留了主发给组织的信息，你们向组织传达的，只是收到的信息中极少的一部分，而且经过篡改；你们还通过第二红岸基地，向主发送了大量未经组织审核的信息。”
第二十三章 红岸之五 义吗？” 第二十四章 红岸之六 她拒绝忘却，而且是用理性的目光直视那些伤害了她的疯狂和偏执。
如果人类得到了那些力量中的一种，世界可能在瞬间被汽化，在疯狂面前，理智是软弱无力的。 对人类本质的思考，使叶文洁陷入了深重的精神危机。她首先面临的，是一种奉献目标的缺失，她曾是一个理想主义者，需要将自己的才华贡献给一个伟大的目标，现在却发现，自己以前做的一切全无意义，以后也不可能有什么有意义的追求。这种心态发展下去，她渐渐觉得这个世界是那样的陌生，她不属于这里，这种精神上的流浪感残酷地折磨着她，在组成家庭后，她的心灵反而无家可归了。
在静静的午夜，宇宙向它的聆听者展示着广漠的荒凉
你可以沿着它向前向后走无限远，但永远找不到归宿。
人类第一次读到了来自宇宙中另一个世界的信息，其内容出乎所有人的想象，它是三条重复的警告： 不要回答！ 不要回答！！ 不要回答！！！
这个世界收到了你们的信息。 我是这个世界的一个和平主义者，我首先收到信息是你们文明的幸运，警告你们：不要回答！不要回答！！不要回答！！！
你们的方向上有千万颗恒星，只要不回答，这个世界就无法定位发射源。 如果回答，发射源将被定位，你们的行星系将遭到入侵，你们的世界将被占领！ 不要回答！不要回答！！不要回答！！！
在以后的四个多小时中，叶文洁知道了三体世界的存在，知道了那个一次次浴火重生的文明，也知道了他们星际移民的企图。
到这里来吧，我将帮助你们获得这个世界，我的文明已无力解决自己的问题，需要你们的力量来介入。
第二十五章 叛乱 其实，对于无比强大的主来说，我们做的一切都丝毫没有意义，我们只是做自己想做的事。”</description>
    </item>
    
    <item>
      <title>旧邦新造（第二版）</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E6%97%A7%E9%82%A6%E6%96%B0%E9%80%A0%E7%AC%AC%E4%BA%8C%E7%89%88/</link>
      <pubDate>Wed, 28 Sep 2022 13:12:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E6%97%A7%E9%82%A6%E6%96%B0%E9%80%A0%E7%AC%AC%E4%BA%8C%E7%89%88/</guid>
      <description>章永乐
导言 这是一场让人猝不及防的革命：1911年10月10日武昌城的一声巨响，迅速在中国南方引发遍地烽烟。
革命者自己都没有做好充分的准备，他们没有严密的组织，只有一个松散的跨省革命联盟。
中国并未像第一次世界大战之后的俄罗斯帝国、奥斯曼帝国与奥匈帝国那样，在“走向共和”的同时也走向了解体，而是大致保持了清朝的疆域与人口。这是一个世界历史奇迹。
革命并未成功建立起有效的国家治理秩序。
夫去一满洲之专制，转生出无数强盗之专制，其为毒之烈，较前尤甚。于是而民愈不聊生矣！
更重要的是法统分裂背后的军阀割据与混战的事实：不仅南方若干省的军阀与执政的北洋集团分道扬镳，就连执政的北洋集团，自从1916年袁世凯死后也已经四分五裂。
军阀们并不寻求脱离中国建立新国，他们中的强者希望能凭借自己的武力来完成统一，而其他人则抗拒强者的统一。
民国国歌《五族共和歌》
东亚开化中华早，揖美追欧旧邦新造，飘扬五色旗国荣光，锦绣山河普照，我同胞鼓舞文明，世界和平永保。
第一，国家主权的同一性与政府继承
革命前后的中国是同一个中国，发生的是政府继承（succession of governments），而非国家继承（succession of states）
第二，政治正当性话语
第三，政体形式
清王朝具有“复合君主制”（composite monarchy）的某些特征，其君主虽然具有“皇帝”这一对治下臣民普遍有效的身份，但在面对不同区域和族群时，经常在“皇帝”身份之上叠加其他身份
皇帝同时也是蒙古人的可汗38、满人的八旗共主，在藏传佛教中还常被视为曼殊师利菩萨
清朝一定程度上推行民族隔离政策，致使不同族群无法通过日常交往形成共同的集体认同。
清朝皇帝绝不仅仅是政治统治体系的顶点，他也是将这个庞大的王朝国家凝聚在一起的纽带。
但在具有“大一统”传统的中国，革命者们不能不考虑推翻君主之后的国家统一问题。
1911年10月武昌起义发生之后，大批立宪派人士出于对清王朝的幻灭，加入到革命阵营中来，在很大程度上稀释了激进革命派的汉民族建国主义立场，最终形成了“五族共和”的共识。
诏书证明清王朝和民国政府所行使的主权，是同一个中国的主权。这有助于未参与辛亥革命，甚至反对革命的地方区域承认新生的民国政权，有助于新生的民国政权与边疆分离主义及其背后的帝国主义列强作斗争。
辛亥革命受到美国革命和法国大革命的激发，而且和后二者一样，都是消灭君主主权，确立人民主权。
由清政府的“内部人”与外部的革命者联手向君主施加压力，迫使君主下诏，以传统的“天命转移”的话语，交出统治权，以换取民国的优待条件。
由此，在清帝逊位之后，出现的是南北两个对峙的临时共和政府。
从法统上说，北方政府被南方政府吸收；但就实力政治而言，南方政府被北方政府吸收，袁世凯成为统一的民国政府的首脑。这可以说是一个充满戏剧性的“借壳上市”事件。
本书将南北议和、清帝逊位和袁世凯被选为临时大总统的一系列事件称为“大妥协”，加入这场妥协的不仅有清皇室、以袁世凯为代表的北洋集团以及由革命派和立宪派共同组成的南京临时政府，也有像蒙古王公联合会这样的边疆少数民族精英。
如果从国家主权的同一性角度考虑，这一“大妥协”无疑具有一定积极意义。
在这次“大妥协”中，无论是清王朝，还是南方的革命派，都在一定程度上体现出了顾全大局的精神。当然，没有强有力的军队和政权组织，一纸文书并不足以保全一个庞大的多民族国家。
在帝制之下，政权交替的最为直接的正当性基础是“天命”，民意变迁被作为“天命”转移的外在表征，因此可言“民本”，但不可言“民主”。
皇帝的逊位与共和政体的缔造带来了一场政治观念上的大震荡，直接冲击了与帝制相配套的整个纲常伦理体系。这是一场具有深刻社会和文化后果的政治革命。
能详的一个说法是：“共和观念深入人心”，这常被用来解释袁世凯与张勋复辟帝制的失败。
但不可忘记的前提是，在一个识字率极低的社会里，这些报章的受众只是中国人口的极小部分。
民国虽然成立了十年，一般人民并未了解共和是个什么东西，他们自视也不是国民，乃是遗民，他们正待真命天子出现，预备好做太平臣子百姓哩！
谋求清朝复辟的劳乃宣故意将“共和”理解为“周召共和”意义上的共和，是在君主年幼不能视事时的大臣摄政，因此“共和”必然隐含着要还政于君。
在他看来，只要国为公有，无论是否有君，都可以称为共和。
民初公共舆论中的“共和”观念，形式标准是第一位，即必须消除世袭君主的存在；在此基础之上，政权的运作需要进一步体现人民的公意。
革命派实力的弱小，大众的冷漠，使得北洋政权可以在共和建设问题上长期采取“最少主义”，不少北洋将领甚至对于君主复辟也采取机会主义态度，只要有利可图，就不妨投机一把。
在一战结束之前，君主制国家仍然在世界上占据压倒性的多数，正在走下坡路的世界霸权之主英国是君主制国家，挑战英国霸权的德国也是君主制国家，共和制国家中最强的法美两国，一个打不赢君主制国家德国，一个虽然GDP已经达到世界第一，但仍缺乏国际影响力。
1914年第一次世界大战爆发后，中国的政治精英们目睹欧洲人自相残杀，对西方文明的诸多玫瑰色的想象走向破灭，重新从中国传统中寻找救国资源成为新的潮流。
反对帝制的人，大半是反对袁世凯做皇帝，不是真心从根本上反对帝制。
“新文化运动”的目标是在思想和文化上砍掉君主的脑袋，永绝政治上的君主复辟之患。
夫去一满洲之专制，转生出无数强盗之专制，其为毒之烈，较前尤甚。于是而民愈不聊生矣。
在列强环峙、地方势力尾大不掉的情况下，民国政府的治理遇到了极大的困境。
“大妥协”在主权问题上达成了极其重要的精英共识，但并没有完成精英集团的整合，并没有在原则层面就未来的共和建设形成真正的精英共识。
在袁世凯看来，中华民国政府是在清帝逊位后建立的，它源于清帝的统治权让与；而在革命党人看来，中华民国政府是各省通过武力革命建立的，先于清帝的逊位，其正当性基础是人民固有的主权。
从“大妥协”开始，北洋集团与同盟会——国民党一直是两个相互高度不信任的集团，二者在地方层面均掌握一定势力，在中央层面则分掌行政与立法。双方均试图对自身权力进行最大化，最终走向了政治的破局。
1913年，北洋集团与国民党都认识到中国有分裂的隐患，同时也都有主导中国政局的强烈期待，因而在中央地方关系上，都主张单一制而非联邦制，以利掌权之后号令全国。
“二次革命”对国民党的打击尤其沉重，这场革命在法理上有所欠缺（宋案仍在司法阶段，国民党人就发动了武装暴动），未得到渴望国家稳定的有产阶级的广泛支持，最终也导致革命派失去对南方数省的控制权。
1914年宪制改革固然体现了袁世凯的个人野心，但将之纯粹还原为其个人野心，是过于单薄的解读，因为野心本身不可能脱离思想和社会环境而存在。
这次宪制改革宣告了通过议会政治整合中国这一路径的失败，从而采取了以加强中央政府行政权为特征的整合路径。
在清末民初的复杂条件下，回归到传统的军人——官僚政治，是否能迅速实现国家的整合？
袁世凯为集中权力，让自己的家族成员走向政治前台，疏远段祺瑞、冯国璋这些过去的亲密合作者，也在北洋体系内部埋下了分裂的种子。
即便是在旧制度下，王朝的更替都会非常艰难，像王莽及曹操、曹丕父子等人取代前朝，无不经过漫长的准备。
新的政治正当性原则会构成复辟的障碍，真正信奉共和主义的革命派、觊觎最高领导人位置的机会主义者和抗拒国家实质统一的地方军阀都可以征用共和主义话语来为自己作论证。
或许袁世凯个人不乏利用君主制这一传统资源更好地整合中国的主观愿望，但事实是，这次复辟既耗尽了袁世凯多年积累的政治资本，也大大损耗了中国的元气。
1917年，在地方割据势力更大、政治权威更趋碎片化的情境中，张勋试图以比袁世凯更微弱的军事力量来复辟帝制，其成功的可能性更是微乎其微。
清廷担忧自太平天国起义以来军财诸权落入地方大员之手的局面，启动了一场中央集权运动，试图将军权与财权重新收归中央，但在操作中实际上集权于满族亲贵，触动了“满汉之争”的神经，最终引发了革命；
要打破这种恶性的均势，离不开强大的军事力量，但在国土被军阀分割的情势之下，依靠旧有的组织动员方式，已经很难凝聚成优势力量。
“新文化运动”的政治追求，是在政治制度上驱逐旧君主之后，进一步在文化领域中砍掉旧君主的脑袋，并唤起新的政治主体，冲击由官僚、军人与士绅垄断的糜烂政治。
新型政党具有全面改造社会的政治追求，其组织更加严密，对于士绅之外的大众具有更强的动员能力。
北洋时期的中华民国并不是一个平民的共和国，而是一个各民族上层精英的共和国，一个士绅与军人的共和国。
最好是模仿西方列强，先实现上层阶级的政治参与，然后再逐渐扩大选举权。
在康梁所设计的共和宪法中，选举权和被选举权都有一定的财产与知识资格限制，以保证政治权力掌握在政治上比较成熟的阶层手中。这是一个值得尊敬的“士绅共和国”的方案。
失败的根本原因在于，在全国性官僚制度崩溃的军省格局之下，士绅阶层并不是一个政治成熟、能够承担政治领导责任的阶层。士绅阶层的主要力量仍是地主，本来就未能在经济生产过程中产生密切的跨地域的横向联合，其原有的相互认同，是通过参与王朝的官僚体系而形成的。</description>
    </item>
    
    <item>
      <title>可能性的艺术：比较政治学30讲</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E5%8F%AF%E8%83%BD%E6%80%A7%E7%9A%84%E8%89%BA%E6%9C%AF%E6%AF%94%E8%BE%83%E6%94%BF%E6%B2%BB%E5%AD%A630%E8%AE%B2/</link>
      <pubDate>Wed, 28 Sep 2022 11:21:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E5%8F%AF%E8%83%BD%E6%80%A7%E7%9A%84%E8%89%BA%E6%9C%AF%E6%AF%94%E8%BE%83%E6%94%BF%E6%B2%BB%E5%AD%A630%E8%AE%B2/</guid>
      <description>刘瑜
4. 全世界有产者联合起来？全球化的经济后果 右翼民粹主义
为什么特朗普这么“不靠谱”的人都能当选总统？为什么英国在欧盟里好好待了那么多年突然要退出？为什么岁月静好的欧洲居然出现了极右的死灰复燃？
经济全球化虽然给跨国公司带来了巨额利润，给中国、印度这样的新兴市场带来了大发展，却牺牲了西方国家的蓝领工人，尤其是制造业工人。
右翼政治家
西方发达国家，至少西方国家的底层，是全球化的受害者。
当初发展中国家被认为是全球化的牺牲品，发达国家是受益者，短短一代人的时间，居然180度转弯，发达国家变成了全球化的牺牲品，而发展中国家成了受益者。
全球化是什么？某种意义上，全球化就是构建一个“连通器”，它把世界各地之间的关卡都给撤掉了——撤掉之后，高处的水就哗哗流下来了，而低处的水则蹭蹭涨上去了。
冷战的结束打通了东、西两个阵营，两个大水池连成了一个大水池，推动了一波新的全球化浪潮。
这个超级全球化的过程，对一些发展中国家，尤其是亚洲各国，正面的影响毋庸置疑，因为连通器“高处”的资本进来了、公司进来了、就业进来了，把经济给激活了。中国是这个变化的典型。
中国的崛起对美国的传统制造业造成巨大的冲击这一点，却没有很大的疑议。
对于美国的工人来说，本来他们在跟资本家谈判：“我们的工资很多年没涨了，今年的小时工资是不是该涨1美元了？”资本家还在那里头疼怎么回复呢，大洋对岸的中国民工举手了：“我能减10美元干同样的工作。”你说，资本家还会给这些美国工人加工资吗？
全球化一个浪头就把他们打回了“丛林世界”。
制造业受到冲击的其实不仅仅是发达国家，还有一些发展中国家——这是被很多人忽略的一面。
“中国制造”如何导致了南非的去工业化
不管怎么说，全球化的确把饼做大了，但是抢到这块饼的却不是所有人。
资本家阶层当然有理由热爱全球化，因为之前他们是在一个国家挣钱，现在是在100多个国家挣钱。
但是，工人阶层可能正好相反，他们本来可能是和100万人、1000万人竞争工作，现在却变成了和1亿人、10亿人竞争工作。
现在世界的主要矛盾，不再是发达国家和发展中国家之间的矛盾，而是各国的全球主义者站在一起，与四面八方的民族主义者之间的矛盾。
经过这一轮的“超级全球化”，无产者没有联合起来，全世界有产者倒是先联合起来了。
全球主义者和民族主义者之间的矛盾，不仅仅是经济问题，很快也成了政治问题。
中国的民工影响美国的蓝领工人，美国的蓝领工人影响美国的选举，美国的选举影响美国的中东政策，世界就是这样普遍联系的，我们每个人都在发挥我们自己都浑然不觉的蝴蝶效应。
在他们眼中，存在着无数真实的或想象的“不公平”：
你调控汇率，而他们汇率自由，不公平； 你土地国有，可以轻松搞这个那个工业园，他们的土地私有产权受到严格保护，很难征用，不公平； 你要求人家以“技术换市场”，他们觉得这是知识产权的强制转移，不公平； 还有行业垄断、金融国有、产业补贴、出口退税、贷款优惠、环保政策……所有这些元素加起来，构成他们眼中的所谓“国家资本主义”。在他们看来，自由资本主义和国家资本主义相互竞争，不公平。 全球化带来一个“三难困境”，因为全球化、主权国家和民主政治很难兼得。
资本主义的特点是“创造性毁灭”。
一个好的社会的确应当尽量帮助那些蜡烛工人找到新的生计、过上体面的生活。市场竞争是残酷的，但是，当它带来生产率的提高，帮助无数人脱离贫困，激发人的创造性和奋斗精神，它或许又代表了另一种人道主义，一种更深的人道主义。
14. 什么是国家？从墨西哥的毒贩集团说起 国家是阶级统治的暴力工具。
国家是特定疆域内合法地垄断暴力的机构。
暴力的分散化才是自然状态，暴力的垄断化，则是摆脱了自然引力的人为状态。
暴力要从分散走向垄断，面临着两大难题：第一是权力的集中化难题，也就是“谁当猴王”的问题；第二是领土范围的清晰化难题，也就是“猴群的势力范围”问题。
国的繁体字（國），周边是一个框，即一个清晰的边界，中间的“戈”，也就是武器，守卫着口，也就是“人口”。
16. 国家能力从何而来？战争 在很多层面上，战争又是现代文明之母。战争还是现代金融之母。战争甚至还催生了现代民主。
战争加速科技进步、塑造现代金融、催生代议民主，和我们今天的主题相关的则是，战争还缔造国家。
“战争缔造国家，国家制造战争。”（Wars made state, states made wars.）
18. 美国：国家建构的另类道路（1） 战争的压力迫使国家一步步中央集权，在这个过程中，大鱼吃小鱼、小鱼吃小虾，形成一定疆域内的暴力垄断格局。然后，为了维系这个权力结构，国家往往要发展出一个庞大、细密的文官体系，在非战争状态时依然能够将一个巨大的政治体给“兜”住，以抵御“封建回归”的压力，也就是权力走向分散化、离心化的天然倾向。
一个能力强大的国家，就是一个明察秋毫的国家，身份证的存在，帮助政府清楚掌握每个人的行踪。
建立一个全国性的身份证系统，会造成政府侵犯民众的隐私权。
总之，我不想在政府面前成为一个透明人。
右派对国家的怀疑，是认为“国家”这个单位太大了，权力应该分散在各州、分散在社会、分散在市场；而左派对国家的怀疑，则是认为国家这个单位太小了，人权高于主权，全球主义高于国家主义，用公民资格来排斥移民、难民，太狭隘了。
美国是西方国家里唯一允许持枪权的国家。
国家的本质是什么？是暴力垄断。
政府主动放弃暴力的完全垄断权，
是赋予民众武装权以对抗可能侵犯自由的国家权力。
美国也是西方发达国家里唯一没有实行全民医保的国家。
在美国很多保守主义者看来，让政府负责医保，是一只特洛伊木马，表面上政府买单，但是天下没有免费的午餐，国家医保可能带来低效率，可能影响医疗创新，也可能制造大政府。
毕竟，美国这个国家的优势从来不是国家能力，而是个体创造性和社会活力
美国这个国家，由于对国家权力的极度警觉，导致了一种“制度化的混乱”。
联邦党人主张强化联邦政府，反联邦党人认为权力应该更多地交给各州和民众。
战争是国家建构的动力。
南北战争表面上是北方赢了，但是实际上，在战后近100年的时间里，其实还是南方赢了。
政治上是“弱中央，强地方”，经济上则是“弱政府，强市场”。
当时的美国人觉得，这和政府有什么关系？该破产的就破产好了，不破不立，所以政府翻个身接着睡。
的权力结构是分散的、多中心的、蜂巢化的</description>
    </item>
    
    <item>
      <title>政治学通识</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/</link>
      <pubDate>Wed, 28 Sep 2022 11:21:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/</guid>
      <description>包刚升
为什么政治很重要？（代序） 为了我们的孩子们能够自由地研究数学与哲学，我必须研究政治与战争。
解决好政治问题是解决其他问题的前提。
在亚当斯看来，政治的重要性再怎么强调都不为过。
美国是世界上最富有的国家，但他们却有一个最缺钱的政府；奥巴马总统是世界上最具权势的政治家，但他在国内却处处受到掣肘。相
实际上，每个人从摇篮到坟墓都离不开政治。无论是否喜欢，政治总在影响着每一个人的生活：出生的时候，生育当中就有政治；上学的时候，教科书当中就有政治；工作的时候，就业当中就有政治；落户的时候，户口当中就有政治；上网的时候，网络当中就有政治；就医的时候，医疗当中就有政治；投票的时候，选票本身就是政治；最后离开人世时，墓地可能也关乎政治。从摇篮到坟墓，政治对每个人不离不弃，更说明了政治的重要性。
政治学感兴趣的是在政治领域发生了什么、如何发生的以及为什么发生。
第1讲 什么是政治？ 我们认为，不受限制的权力是带有暴力性质的，并且是纯粹的和简单的。 1.1 政治是国家兴衰的关键 人是天生的政治动物。
我们也看到，那些最受尊敬的能力，如战术、理财术和修辞术，都隶属于政治学。
过去的教科书认为，经济决定政治；但从另一个角度看，政治也决定着经济。
政治与经济本身就是一种互动或互相影响的关系
政治权力很大程度上决定了是否能实现经济繁荣。
流寇统治的最大问题是破坏了一个社会的正常激励机制。
流寇统治带来了什么问题呢？种地的是一个人，收获的是另一个人。因此，流寇统治会导致整个社会生产的迅速下滑。为什么长期内战通常会死很多人？并不是说内战中被打死的人有那么多，而是内战破坏了整个社会的激励机制，其生产系统被迅速摧毁了，所以会导致大量人口的死亡。
坐寇为什么可能强于流寇？因为坐寇发现，倘若自己依靠武力以抢劫为生，就没有人从事生产了，老百姓都逃亡了，经济也就完蛋了。经过理性思考，坐寇发现这样是没有出路的，统治无法长期维持。所以，他下令任何军人不得再抢劫任何财物，但同时规定辖区内的每一住户须按一定税率给他缴税
这个统治者由于有税收需要，所以他希望经济能够发展。当经济发展时，他的税收收入也能相应增加。因此，坐寇统治要强于流寇统治。
从逻辑上说，第一个问题是有些坐寇会变得极其贪婪，甚至会极不理性。
对辖区内富有的阶层或较大的企业，统治者可能想征收他们的财产。这样，当统治者变得贪婪时，“统治之手”就变成了“掠夺之手”。
坐寇统治的第二个问题是每个统治者都会死，这就面临坐寇代际更替的问题。
在我之后，哪管洪水滔天”
统治者并非总能做到深谋远虑和审慎节制。
只有把统治者的权力放到宪政民主的框架中，统治者才不会胡作非为，长期持续的繁荣才有保证。
坐寇或统治者的权力必须受到制约，统治者不是想干什么就可以干什么。
宪政的简单理解就是“限政”，
即限制政治权力。
从经验来看，民主政体是否更有利于经济增长和长期繁荣，目前学术界还有争议。
如果统治和统治者的问题不能很好解决，持久的繁荣是不可能的。
在近代欧洲，为什么是英国与荷兰，而不是法国与西班牙，较早地开始工业革命？他
为什么穷国增长年份的比率如此之低？
“国家既是经济增长的关键，也是人为的经济衰退的根源。”这句话后来被称为国家问题的“诺思悖论”。
1.6 理解政治的当代观点 政治是关于“谁得到什么？何时得到？如何得到？”
政治是关于权力的配置和分享。
政治是关于“价值的权威性分配”。
政治是“影响力的运用”。
政治的核心因素是权力，而权力某种程度上就是影响力。
2.1 岛屿的寓言：谁之统治？何种秩序？[18] 首要的是解决如何分配资源的问题。
生存的渴望和对未知的恐惧
首先要解决的问题是建立一种合理的资源分配机制。
我们首先应该选出一个领袖。
最重要的应该是分工和产权，明确分工和界定产权是关键。
到底什么是首要的问题呢？
但这些问题都跟一个更根本的问题有关，那就是构建政治秩序的问题。
如果没有一个基本的政治秩序，其他问题都无法解决好。
那么，可能的统治方式是什么？如何决定由谁来统治呢？
基于传统进行统治，就是遵循“历来如此”的惯例：我们过去怎么统治，现在还怎么统治。
我是不是一个公正的统治者？与智慧、学识、才干、精力相比，一个统治者是否公正可能更为重要。
接下来的问题是，我会不会一直是一个公正而有为的统治者呢？
我们人类社会是否真正能够通过深思熟虑和自由选择来建立一个良好的政府，还是他们永远注定要靠机遇和强力决定他们的政治组织。
无论基于传统、基于卡里斯玛还是基于暴力，政治上都是不可靠的。这几种统治方式都无法带来真正的善治和实现长治久安。
我们岛屿的统治应该要基于法理。惟有法理型统治，才是真正的长久之道。那么，什么是法理型统治呢？
凡是最优良的政治秩序都是法理型统治。
第一个原则是，不管谁统治，首先要建立基本的规则。
第二个原则是，所有岛上公民的基本权利要有切实的保障。
第三个原则是，要通过一种和平的、寻求岛上多数公民支持的方式来选择统治者。
3.9 什么是社会主义？ 社会主义作为一种意识形态的出现，是对资本主义早期发展的反应。
空想社会主义。
欧文、圣西门和傅里叶等人都是空想社会主义的代表，他们强调集体主义和互助，批评资本主义的诸种负面现象
后来，这一派的学说就慢慢地发展为科学社会主义或者叫共产主义，这主要是指马克思和恩格斯的学说</description>
    </item>
    
    <item>
      <title>小岛经济学</title>
      <link>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E5%B0%8F%E5%B2%9B%E7%BB%8F%E6%B5%8E%E5%AD%A6/</link>
      <pubDate>Wed, 28 Sep 2022 11:20:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E5%B0%8F%E5%B2%9B%E7%BB%8F%E6%B5%8E%E5%AD%A6/</guid>
      <description>彼得·D.希夫 安德鲁·J.希夫
推荐序 “凯恩斯主义允许政府摆出一副有能力提高生活水平的模样，只要印钞机运转，什么公开承诺都可以做。
政府成为经济的主导者，成为经济发展的主角。这种困局只有当政府的职能从主导经济向提供公共服务的角色过渡以后，才能真正得以改变
对经济的过度干预，是催生天量货币不断被滥发的根源。政府通过通货膨胀稀释民众的财富，通过悄悄盗
用民众的财富满足所谓的经济干预计划，而这些计划无不是被种种动听的承诺包装着，尽管这些动听的承诺很少真正兑现
很多人似乎只看到了投资建设带来的毫无意义的虚幻的GDP（国内生产总值）数字，却没有看到这种高投资低回报甚至无回报的结果所带来的巨大的财富损耗。
珍藏版序言 然而，量化宽松不过是“印钞票”的一种花哨的委婉说法而已。 序言 为了解决债务危机，我们必须负债更多；为了经济繁荣，我们必须花钱消费
凯恩斯提出了一个类似量子力学的经济学研究视角，创造了两套经济规律，一套作用于微观层面（与个人及家庭生活相关），另一套作用于宏观层面（与国家和政府相关）。
美国的独特之处就在于，它维护个体权利、限制政府权力。
自由市场资本主义的本质就是权力分散，因此这一体制在全球大部分地区都对原有的僵化权力结构构成了威胁。
凯恩斯的核心观点是，在经济不景气时，政府可以通过扩大货币供给和财政赤字缓和自由市场的波动
奥地利学派认为，经济衰退是经济繁荣期所做出的错误决定的必要补偿，经济迅猛发展过后必然会有一个相应的衰退期。
第一章 一个好点子出炉了 所有的产出全都消费掉了！没有未雨绸缪，没有多余的财物可以借出。
难道我的日子就这样了吗？肯定有比现在更舒心的日子。”[插图]
他想做几件更好、更时尚的棕榈叶衣服，他想要一个遮风挡雨的住所，当然他还想执导几部故事片。但他每天忙于捕鱼糊口，这些梦想如何成真呢？
。通过自我牺牲（挨饿），他创造了资本。
消费不足，敢于冒险！
他选择暂时延迟消费（吃鱼），是为了将来消费更多的产品（捕到更多的鱼）
资本指的是一种设备，这种设备的建设和使用本身没有什么意义，其意义在于利用设备建设和制造其他需要的东西。
这张网或许可以给他带来更多的鱼。因此，这张网就是一种资本，是有价值的。
从这样一个简单的行动开始，这座
小岛上的经济开始发生巨大的变化。艾伯提高了生产力，这对每个人而言都是好事。
既然我一天捕到的鱼可以吃两天，那么我可以利用隔天休息的时间做点儿别的事情。可做的事情太多啦
伯的生产力提高了一倍，现在他生产的东西多于自己需要消费的东西。生产力的提高带来了许多益处。
剩余产品就是健康经济
的命脉
所有物种而言（人类除外），经济学其实可以简单理解为日常生存活动
工具改变了一切，使经济的出现成为可能
这些工具提高了我们的劳动效率。我们生产的东西越多，可以消费的东西就越多，我们的生活也就变得越美好
努力使有限的资源（每种资源都是有限的）产生最大的效益以尽可能满足
人类的需求，这就是经济这一概念最简单的定义。工具、资本以及创新是实现这一目标的关键
经济增长的原因：找到了生产人类所需物品的更好方式。
第二章 把财富分享给别人 虽然艾伯从来没有刻意使他人受益，但他的资本无疑帮助了岛上的所有人。
你看这样行不行，我们编织渔网时，你把富余的鱼借给我们吃，那样我们织网时就不用挨饿了。等我们捕到多余的鱼，再把鱼如数还给你。”
你借给我们一条鱼，我们会还你两条。这可是百分之百的利润啊
他这是在窃取别人的劳动成果，靠别人的辛苦劳动获利！
1.他可以把鱼留下，留着自己以后吃——这是最保险的选择
2.他可以放纵一下，不再干活，将自己的储蓄（存下的鱼）消费掉
3.他可以建立自己的渔网出租公司。如果艾伯每天吃掉一条富余的鱼，两天就可以再编织出两张网
他可以把多余的网租给贝克和查理，向他们收取每人每天半条鱼的租金。这样，艾伯每天不必亲自捕鱼就可以得到生存所需的那条鱼了。哈哈
提前退休
4.他可以把两条鱼借给贝克和查理，收取100%的利息。
抉择……抉择……艰难的
艾伯的最终决定取决于个人对风险和回报的偏好。但不管最终方案是什么，他的抉择都会惠及这座小岛的经济，而且也不会给自己的两个邻居增加负担。
，经济增长翻番，前景更加光明
饥饿（其经济术语为“需求”）只是刺激经济增长的必要而非充分条件。
追求更多是人类的本性。不管已经拥有什么，我们总是想要更多。也许不是想要更多的东西，而是更多的时间、更多的乐趣、更多的选择，所有这些需求都需要资本
有了多余的鱼，小岛上的几位居民每天终于可以比原来多吃一些鱼了（原来是每天一条鱼），但是经济并没有增长，因为他们的消费增长了。而他们的消费之所以增长，是因为经济增长了
给老百姓更多的钱花就可以增加需求，但是这种做法并不能改变真正的需求，只会使人们花更多的钱购买已经生产出来的商品。
只有增加供给才能切实满足人们更多的需求
力
贝克和查理的假日时光并不能提高这座小岛的生产能
尽管慈善之举听起来颇有雅量，也会提升艾伯的人气，但这一举动却无法像商业贷款一样推动经济发展。
所有能够增加捕鱼（生产）量的事物都会惠及小岛，鱼越多，大家就越有可能吃到更多东西，也就越有可能做捕鱼以外的事情，或者他们可以什么都不做。
富从来就是一个相对的概念。在原始社会，财富是极少的，
在现代经济学中有一个理论认为，利润是通过少付工人工资产生的，有人称之为“劳动价值论”。
富人致富的原因（至少开始时）是他们为他人提供了有价值的东西
当被压迫阶级认识到自己的劳动果实被人偷走时，就会缩减自己的劳动量
消费贷款 这种商业贷款是资本的最佳用途，因为这样可以扩大生产。
企业失败的原因在于没有意识到事先应当做好所有约定</description>
    </item>
    
    <item>
      <title>有钱人和你想的不一样</title>
      <link>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E6%9C%89%E9%92%B1%E4%BA%BA%E5%92%8C%E4%BD%A0%E6%83%B3%E7%9A%84%E4%B8%8D%E4%B8%80%E6%A0%B7/</link>
      <pubDate>Wed, 28 Sep 2022 11:20:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E6%9C%89%E9%92%B1%E4%BA%BA%E5%92%8C%E4%BD%A0%E6%83%B3%E7%9A%84%E4%B8%8D%E4%B8%80%E6%A0%B7/</guid>
      <description>哈维·艾克
序言 有钱人的思维为一切奠基。
从你的思维入手。
必须给思维纠偏。
如果你富有且快乐，那你上道了。但如果你没有或缺失其中任何一个，那说明你的思维存在问题。
从改变他们与金钱和财富的关系开始，让他们的思考和信念变得能撑起他们的雄心。
只要你有心且正确思考，就并无不同。
尽管这些人出于好意，但你要问问他们富有吗，如果不是，那么他们能教你的仅仅是他们知道的，而这结果，最好也只是平庸的财务水平，而更坏则导致贫穷。
如果你想变得富裕，别听破产者对钱的观点。”他们所能教你的，就是变得像他们。
第一篇 你的财富蓝图 致富其实是一种心理游戏 仅有适当的时间、适当的地点还不够，你必须是在正确的时间、正确的地点出现的正确的人。
你是谁？你如何思考？你的信念是什么？你有哪些习惯和特质？你对自己真正的感觉是什么？你如何与别人建立关系？你对别人的信任有多少？你真的觉得自己值得拥有财富吗？在恐惧、忧虑、挫折与种种不方便的情况下，你的行动能力如何？你在心情不好的时候还有行动能力吗？
你的性格、思想和信念，决定了你的成就能有多高。
成功的关键在于提高你的能量；当你提高了能量，别人自然会被你吸引。一旦他们慕名而来，你就要他们付钱！
你的收入，只能增加到你最愿意做到的程度！
为什么财富蓝图很重要？ 如果你在还没准备好的时候就得到一大笔钱，那么这笔钱极有可能不会待在你身边太久，它们早晚会离开你。
大部分的人都没有足够的内在能力去创造并守住大笔的财富，去面对各种伴随着金钱与成功而来的挑战
大多数人都没有完全发挥自己的潜力，所以无法成功。
种什么因，就结什么果 如果你想改变果实，你首先必须改变它的根；如果你想改变看得见的东西，你必须先改变看不见的东西。
物质世界，精神世界，情感世界，灵性世界。
大多数人不了解，物质世界只不过是其他三个世界的“打印件”罢了。
问题并不是出在“打印件”这个物质的世界，而必须要从“设定”下手，也就是从精神的、情感的和灵性的世界下手。
金钱是一种结果；财富是一种结果；健康是一种结果；生病是一种结果；你的体重也是一种结果。我们活在一个有因有果的世界。
缺钱，绝对、绝对、绝对不是一个问题。缺钱只是一种症状，它透露了表面之下的状况。 缺钱是一种结果，那么，什么是造成缺钱的根本原因？一言以蔽之：唯一能改变你的外在世界的方式，就是先去改变你的内在世界。
你的外在世界，只不过是你内在世界的反映罢了。如果你的外在生活过得不好，那是因为你的内在生活不顺遂。就是这么简单。
宣言：促成改变的强效秘诀 你听到了，会忘掉；你看到了，会记得；你去做了，会了解。
什么是宣言？它是一个大声强调的积极声明。
“宣言”的定义是：“正式表述你想采取某个行动或是某个立场的意愿。”
提出宣言就不是在表明某事为真，而是在陈述我们有心想要做某件事、想成为某种人。这种方式，我们心中那个小声音就愿意接受了。
这是我们想要看到的未来。
“我的内在世界创造了我的外在世界。” 现在，摸着你的头说： “这是有钱人的脑袋！”
财富蓝图是如何形成的？ 想法→感觉→行动=结果
想法产生感觉，感觉产生行动，行动产生结果。
你的财富蓝图，包含了你对金钱的想法、感觉和行动。
第二篇 财富档案 有钱人和穷人不一样的十七种思考方式和行为 “实现程序”：想法产生感觉，感觉产生行动，行动产生结果。
一切都从想法开始，而想法是由心灵产生的。
任何改变的第一步都是“察觉”。也就是说，想要像有钱人一样思考，第一步就要知道他们如何思考。
有钱人对于金钱、财富、他们自己或别人，以及生活中各个方面的想法，都跟其他人不一样。
有了新的档案，就会带来新的选择；
你可以选择那些会鼓励你获得幸福和成就的思考方式，而舍弃那些不能支持你获得幸福的思考方式。
人与人之间的思考方式和行为方式简直有天壤之别，比他们所拥有的财富和他们对社会的重要性的差距更大。
中产阶级的想法通常混合了富人和穷人的思考方式。
如果想要创造更多财富的话，就要像有钱人一样思考。
我们的行动来自我们的感觉，感觉来自想法，所以，每一个致富的行动都是来自一种致富的思考方式。
，不要坚持必须照你自己的方式去做事。为什么？因为你过去所用的方式造成了你现在的状况，除非你想重蹈覆辙，否则就不要延续你原来的方式。如果你还没有达到致富的目标，也许现在是时候了。
，人是习惯的动物。
习惯分成两种：习惯了“去做”，以及习惯了“不去做”。
你现在没有在做的事，都是你习惯了不去做的事。要把不去做的习惯改掉，变成去做的习惯，唯一的方式就是去做它。
如果你真的渴望成功，那么就用行动来证明你的决心，把这本书上所建议的行动都付诸实践。
财富档案1 如果你想要创造财富，就要相信是你自己在掌握人生—特别是在金钱方面—的方向盘。
你必须相信，只有你能造成自己的成功，也只有你能造成你的平庸，只有你能造成自己为钱辛苦或是前途茫茫。不管是出于自觉还是不自觉的原因，你的人生状态都是你自己造成的。
穷人不为自己生命中的一切负责，却选择了扮演“受害者”的角色。
究竟要如何辨认某人是不是在扮演受害者的角色呢？这种人通常有三个明显的特征。
反正，错的永远是别人或是别的事情，一定不是他们自己。
如果你认为钱不重要，那么你根本就不会有太多钱。
任何一个说钱不重要的人，都是没有钱的人！有钱人了解金钱的重要性，了解金钱在社会上扮演的角色</description>
    </item>
    
    <item>
      <title>理财就是理生活</title>
      <link>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E7%90%86%E8%B4%A2%E5%B0%B1%E6%98%AF%E7%90%86%E7%94%9F%E6%B4%BB/</link>
      <pubDate>Wed, 28 Sep 2022 11:20:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E7%90%86%E8%B4%A2/%E7%90%86%E8%B4%A2%E5%B0%B1%E6%98%AF%E7%90%86%E7%94%9F%E6%B4%BB/</guid>
      <description>邢力
以理财视角看消费：能租的东西尽量别买 能租的东西就别买，如果一定要买，就用租的视角来判断买的性价比。
自住房是负债，因为你要支付物业、水、电、煤气的费用，投资房则是资产，因为你能每月收租金。
为什么不把买房的巨款省下来，拿出一点儿小钱每月交租金，剩下的钱拿去钱生钱、改善生活或者开阔眼界呢？
为什么我会选择买本田CRV？ 买房时的思考逻辑是四步走：一选城市，二选板块，三选小区，四选房型、面积、楼层。买车也一样：一选价位，二选车型，三选品牌，四选款式。 价位
我建议你买车的费用不应超过你家庭金融资产的10%或你一年的收入。比如你想买一辆10万元的轿车，那么要么你已攒了100万元的金融资产，要么你一年收入超过10万元，否则从理财角度看，你压根儿没有资格买
车，“地铁公交+共享单车”是最适合你的出行选择
所有会给你带来负的现金流的东西都是负债，所以汽车不是资产是负债，它不是往你口袋里塞钱，而是要你往外掏钱。
年终奖太少，年后要不要跳槽？ 第一种情况是公司经营不善，业绩下滑，大池没水，小池当然就干涸了，所以公司给员工少发年终奖甚至不发年终奖也就在情理之中了。这时，跳不跳槽就取决于你对公司未来发展的预期了。
我们工作的目的是为了赚钱，但我们想要赚到更多的钱，
我到底想做什么？我到底能做什么？我现在有多少钱能经得起折腾？
从你动了辞职的念头，一直到你真的万事俱备递交了辞职信，在这段骑驴找马的过渡期内，你千万不要流露出对公司的强烈不满，更不要消极怠工，故意与领导作对，甚至怂恿别人和你一起辞职。哪怕是离职后，你也不要到处说老东家的坏话。这是一个人基本的职业素养。
人生是一段旅程，每向前走一步，都会留下足迹。任何一段职场经历，不管在你看来有多不堪，也是你生命中无法被抹去的足迹，是你成长
的记号。
为难别人，其实就是在为难自己。尽可能让你人生道路上遇到的每一个人、每一家公司，都成为你自我成长的基石，而不是你终日诅咒的对象。
跳槽方法论 一个是收入待遇清单，另一个是两份工作的劳动付出、人际关系、发展前景和个人志向等各种不能直接用钱来衡量的清单。
是你不能只比较当下收入的高低，而要综合比较其他各方面的得失取舍
如果跳槽与不跳槽的工资待遇相差特别大，比如现在的工资是一个月5000元，跳槽后直接翻倍到1万元，那么这种情况下，你无须太过纠结，当然要跳。
至于你的人生走向，永远需要你自己做出决定，并为你的选择承担一切后果。
未来中国一半人口都会聚集到这几座城市 未来将会出现大武汉≈湖北、大郑州≈河南、大长沙≈湖南、大合肥≈安徽、大西安≈陕西的局面。
这就是趋势的力量，越早行动越主动，越晚醒悟越被动
洪水来之前，你得搞明白哪里是更安全的高地，并在自己的能力范围内，尽可能爬到相对最高的地方。
理财多年，学到的无非这八个字 对普通老百姓来说，理财的核心就是四件事：开源、节流、保障、投资。 攒多少钱，才能实现财务自由？ 我只要赚到了多少多少钱，就能实现财务自由了。
一是你过去积累的存量财富有多大。二是你未来钱生钱的速度有多快。
三是你对物质的欲望有多大。
决定一个人是否实现财务自由的
三个要素中，起到关键作用的是第三
——你的物质欲望有多大。
这不是数学问题，而是心态问题；不是财富规模大小的问题，而是价值观取向的问题。
理财也好，工作也罢，人最终目的是希望自己能过上更加幸福的生活。
事实上你只是实现了当下这个时间点的财务自由，你没有实现永续的财务自由。
所谓永续的财务自由，就是你这点儿钱永远能够跑赢通胀，不管未来物价如何上涨，你的生活水平都不会下降，直到你活到100岁，1000岁，10000岁，都不会下降。
要让复利产生神奇效果，第一要务就是必须保住本金。
大多数人，注定一辈子都无法实现财务自由，他们只能被动等待法定退休年龄的到来，但就算退休了，也没有足够的财力资源能让他们随心所欲地生活。
对他们来说，活着本身就是一种幸运，活着本身就是一种信仰，至于所谓的人生的意义和价值，那或许只是骗骗孩子的吧。 对于已实现财
因为他获得了选择权，获得了可以不需要为了挣钱而被迫工作的选
择权。
不管老板把自己的事业说得多么崇高伟大，也不管你把自己所从事的工作说得多么有意义，说到底，你从事现在这份工作的根本目的就是为了挣钱。
真正崇高伟大或有意义的工作，是不给你钱你也愿意去做的！
实现财务自由只不过是你为了赚钱而去奋斗的那段人生的阶段性终点，它更是你不为了赚钱还愿意去奋斗的新一段人生的起点。
当你有一天离开这个世界时，回首一生，发现自己实现财务自由之前那段人生更精彩更有意义，那或许是一件很悲哀的事。但如果你发现你实现财务自由之后的那段人生更精彩更有意义，恭喜你，你的人生真的圆满了。
猜猜我的财务自由目标是多少钱？ 平均一个月一次两三天的周边游或5天到10天的国内游，四个月一次6天到15天的出境游，我觉得不算奢侈吧。大致算了下，一年费用得8万元左右，平均一个月6000元。
哪怕今天中国突破社会阶层的难度越来越大，底层人的孩子长大了还是底层人的概率非常大，但养孩子这事，富人富养，穷人穷养，任何人都有追求和拥有幸福的权利。
2017年中国富豪最想拥有的排在第一的是健康，第二是家庭生活，第三是时间，最后才轮到学习机会和物质财富。
如何在工作5年内攒到100万元？ 攒钱”则是存量概念，一个人的攒钱能力=（你赚到的钱-你花掉的钱）×投资回报率。
是不是有足够强大的通过劳动赚钱的能力； （2）是不是足够节俭能把辛苦赚到的钱截留下来； （3）是不是有强大的投资意识和能力，让你留下来的钱不断升值。
真正的大富翁不光有强大的赚钱能力，还有强大的投资理财意识，同时往往还具有节俭的习惯。
就在那一年，我意识到我要开始完全承担起家庭的责任，并且在未来漫长的人生道路上，只能完全依靠自
身努力来改变命运。
理财的第一步是学会记账，遏制消费欲望。
对我本人来说，只有遇到单次大额支出，比如旅行、买房、装修、结婚时，才会记账。目的是避免这种大额支出在消费过程中超出预算。而日常消费，我从来不记账。
在我看来，一个人的自信是由内而外产生的。腹有诗书气自华，一个视野开阔、头脑聪慧、具备独立思考能力的人，不会轻易被外界的潮流或风气左右。
正常情况下，30%～70%的支出收入比都是合理的，即你每个月至少拿出30%的钱用于当下消费，同时最少也要拿出30%的钱用于投资。
对于可投资金融资产只有几十万元的普通人来说，我们的投资选择非常有限。
那些年，我的钱基本都投资在各类基金中，主要是指数基金、债券基金和货币基金。
哪怕跌得那么惨，到了2008年年底，我的资产还是重新回到了50万元左右。</description>
    </item>
    
    <item>
      <title>许倬云说美国</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E8%AE%B8%E5%80%AC%E4%BA%91%E8%AF%B4%E7%BE%8E%E5%9B%BD%E7%8B%AC%E5%AE%B6%E5%AE%9A%E5%88%B6%E7%89%88/</link>
      <pubDate>Wed, 28 Sep 2022 11:17:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E8%AE%B8%E5%80%AC%E4%BA%91%E8%AF%B4%E7%BE%8E%E5%9B%BD%E7%8B%AC%E5%AE%B6%E5%AE%9A%E5%88%B6%E7%89%88/</guid>
      <description>许倬云
全世界人类曾经走过的路，都算我走过的路 抗战期间是求死不得，求生不成。
所以我知道，中国不会亡，中国不可能亡。
李白的《忆秦娥》，“西风残照，汉家陵阙”
。八个字，四个时段，每个时段都能描绘出具体的形象来。
我们常民的日子，可以说无处没有诗意，无处没有画景，无处不是跟自然相配，无处不是和人生相和。这种生活不是只有知识分子才有，一般人一样有。
汉朝将国家的基础放在农村里边独立的农家，人才才能出，财富才能出，这是交通线的末梢。城市都是交通线上打的结，商人、官员都在转接点上
明朝跟清朝都有的最严重问题是，有相当一批国家养活的人。明朝要养活的是职业军人，朱元璋养兵，向他投降的兵，得了天下后不用打仗的兵，都养在卫所里面，由国家养。
本来把大家结合在一起的宗教信仰，聚合的族群，都被都市化的关系打散开，散开以后美国无法凝聚。但有转机，两个转机。一个是头脸人物的聚集，吸收新的血液，以及强固他们的团结性。
第二个是好的，是小社区在自己求活。
凝聚慢慢上来，就等于古代的部落，这个小社区和那个小社区结盟，就能共同做更大一点的事情。所以有两条路，一个是上层往下通，一个是下层往上合。
文化脱不开社会，脱不开经济，脱不开政治，也脱不开地理，脱不开天然环境，脱不开我们驾驭天然环境的科学
要有一种教育，养成远见，能超越你未见。我们要想办法设想我没见到的世界还有可能是什么样，要扩展这种可能性。
要有一种教育，养成远见，能超越你未见。我们要想办法设想我没见到的世界还有可能是什么样，要扩展这种可能性。 二十年来的美国 美国既是他安身立命之所在，也是他观察现代西方文明的窗口，更是他剖析一个帝国由盛而衰的根源之最大社会实验室
今日美国民主已经沉沦为“百分之一所有，百分之一所治，百分之一所享”。
特朗普国家安全团队的诸多行径让美国愈来愈像一个“超级流氓大国”（rogue superpower），因为它打破了所有的道德、意识形态与战略考量的底线。
第一章 我的美国六十年 1957年10月，当时苏联发射了“太空伴侣”号（Sputnik）。人类第一次发射卫星进入了太空，这是震古烁今的大事！我们可以想象，假如人类是大海中的鱼类——居然有一条鱼跳出海面，停留在离海面几丈的空间，可以瞭望陆地，也可以回顾海水。这是人类有史以来第一次尝试，而且居然成功地使得卫星离开了大气层。
从那时以来，美国的高等教育和科学研究，逐渐失去了为知识而知识的目的，转变成为了安全，或是为了利润；美国科学的发展，更注重于现实实际的需求和应用。这一转变，就变成先后程序倒置的形势了。
欧洲和东亚都有古老的文化，但是大战结束后，都在兴起最激烈的共产主义运动
第二章 开疆辟土的历程 五月花”号到达美洲，确实是西欧白人第一次成功地长久留在北美。
然而，很少人还记得，从此以后鹊巢鸠居，这些白人反客为主，终于将原住民排挤于边缘。感恩节，说穿了，是个忘恩的节日。
法国人在新大陆经常和当地的印第安人合作，自己并没有开发土地，其主要目的在于取得新大陆的资源尤其是皮毛，运回欧洲获利。
白人还没有进入时，这一大片土地的森林覆盖率很高，有一个比喻说，一只松鼠从匹兹堡开始，在树枝上跳跃，可以一路跳到芝加哥而不用落地。
这个族群并没有明确的土地产权观念，广大的山林、田野都是属于大家的，大家都有使用的权利，没有“占有”的观念。天赐条件如此优良，原住民很容易维持温饱，也就安居乐业而不求上进
纽约港口的自由女神像手举火炬，欢迎新来的移民，号称迎接一切寻求自由、无处可去的人进入这个国家。
他们进入美国并不需要签证，也不需要护照——如此慷慨大方的姿态，与今日特朗普政权的排外相比，怎不令人感慨。
1840年开始，爱尔兰连年灾荒，马铃薯歉收，南部百万饥民来美求生。这是百姓穷困流离失所，不得不移民到北美的典型案例。所以，美国爱尔兰裔人数众多，他们英语娴熟，进入美国政坛后俨然成为一股势力。
这些黑奴贸易的出资者是犹太人，执行者是葡萄牙人，购买者是英国和法国殖民地的白人农场主
华人进入美国的时间并不晚于许多欧洲来的移民，但是在美国一直居于微小的少数就是因为《排华法案》的限制。1
科罗拉多州的熊耳山是印第安人的圣山，山区有一处保留地，居住族群乃是百年前被数度辗转押送到此落脚，现在因为开采页岩油又被逼得迁移他处。
建立这一国家，有多少弱势人群遭受不公不义的待遇。难道人类的历史，就不能逃离如此残酷的矛盾？搔首问天，天也无言。
第三章 农业形态的变迁 开拓内部的活动，表面上是向自然争取生存的天地，实际上，其中不但有原住民的血和泪，也有成千上万的生物（例如野牛）死于白人开拓者的枪管之下。
美国历史就是一部向西开发的历史。
青年自立的时候就应离家创业。这种风俗说明了英、美西方人家族观念薄弱，成年的孩子必须离家自谋生路。这就是英美式的个人主义。没有亲戚朋友、乡党邻里的援助，每个人必须挣扎奋斗，寻找自己的前途。
美国历史就是一部向西开发的历史：向西不断开展，一次又一次将已经稀薄的群体观念继续冲淡。所以美国到今天，个人是主体，从个人到大社会之间没有人情伦理、天然的集合体，只有自愿加入的社会团体。
这是美式文明的重要因素：个人为自己负责，不负担其他人的责任。
在中国文化的理念，这种态度是人情淡薄；从美国文化的发展背景看，这是启动活力的必要之举。
美国的农业是从内部开发，其意义不再是传统农业的生产，而是商品市场结构的一环。
那些强悍的、不肯屈服的黑人，要么在路途上牺牲，要么在学习工作的过程中被淘汰了。只有愿意接受命运的人，几代下来，学到以顺服换取生
存的特性
也许，美国南方的奴隶制度本身乃是一种生物社会学的计划——将本来自由的人类一分子，硬生生培育为被动、顺服的劳动工具：奴隶。
整体言之，南方的黑奴劳力完全被纳入资本主义市场分工的一环，他们不过被视为会说话的牲口，没有机器以前的“机器”。
黑奴农庄上的人均生产量居然并不像想象之中那么低下：黑奴的工作效率其实相当高。
相对于欧洲资本主义初期的18、19世纪，美
国农场上的黑奴劳工的工作条件，比欧洲工厂中童工、女工和一般工人的状况可能还略为好些。
学者们只注意研究数字，并没有注意到一个人丧失了自由权以后如何还是“人”？例如，主人出卖自己的多余黑人劳力时，可以将母子分开卖——母亲卖给一家，幼小的童工卖给另外一家，导致母子分隔、配偶离散。这些经济学和数字无法计算的情形，才是奴隶制度最可耻之处。
北方的工业和南方的农业之间，因为劳力的需求不同，对劳力使用的方式有颇大的差异。南北战争就源于两种经济制度无法
协调之下产生的矛盾
一直到今日，南方和北方基于经济形态而发展出来的人生价值观念都还有相当大差距。
今日，他们毋宁是另一形态的奴工，虽然并没有丧失人身的自由，但是也没有获得应有的公平待遇。这些人工资低薄，工作不稳定，生活也没保障，其实比非洲后裔的美国劳工更为无助。
这些人不是奴工，也并没经历过奴隶制的阶段。他们的心态不同于黑人，而且有共同的信仰——天主教。这些人主要来自中南美各地，不限于墨西哥，但却都是拉丁语民族。共同的信仰、共同的语言，将他们集合为一个共同体。在美国社会中，他们从事最劳累的低收入工作，也因此突显了美国社会的不公。
论经济效益，这种生产方式还是最合算的。然而，这种经营方式有许多内在的缺点：一方面，同一块农田经常种植同一种作物，也就是消耗同一种肥力，农田肥力的更新有极大的困难；另一方面，大农耕作往往依赖机械，后来又依赖化肥和除虫药，为了经济效益而发展的技术，对于农田来说则是无情的蹂躏。
全世界的主要农作物品种，几乎都集中在孟山都这一类大型农化公司
人类自己创造了非凡的新农业，也引发了无可挽回的灾害。
所谓发现“新大陆”，其实是白人掠夺这块印第安原住民家园
的资源。美国利用非裔黑人和拉丁语系劳工作为劳力，则是人类历史上大规模剥削低价劳力的恶劣记录。
人类历史上，处处都充满了人剥削人、人掠夺人的丑恶现象。美国的开拓，是人类值得骄傲的成绩，可也是充满了“人吃人”现象的罪恶。这大片处女地的开发，也留下生态环境的损失、族群之间的冲突。美国独立精神显示了个人主义代表的自由观念，过度发挥则出现人情冷漠、趋利忘义的严重弊端。种种利弊之间，如何加减乘除？实在令人困惑难解。
第五章 多族群社会及其问题（上） 美国曾经坚持这个新的国家是一个“大熔炉”，将许多不同来源的人民融合为一个和谐的整体。实际的情况则是，新来的人都是被融合于以英语为国语的文化，而各种族群自己带来的文化成分，仍旧隐藏在各自社群之内。</description>
    </item>
    
    <item>
      <title>西方现代思想讲义</title>
      <link>https://www.pengjielee.cn/post/read/%E5%88%98%E6%93%8E/%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89/</link>
      <pubDate>Wed, 28 Sep 2022 11:16:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%88%98%E6%93%8E/%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89/</guid>
      <description>刘擎
01 思想有什么现实意义 理解和反思我们生活在其中的这个现代世界。
格外关注思想观念对社会实践的塑造作用，强调思想与现实的内在关联。
思想内在于现实 思想离不开现实
现实离不开思想
如果离开了思想，根本不存在“社会”现实，当然也谈不上去理解现实。
思想观念是内在于社会现实的，观念是驱动实践行为的构成要素。
人类行为的复杂动机结构 思想观念是人的社会实践行动的驱动要素，这在经济领域之外表现得更为复杂多样。 02 什么是现代和现代性 “现代”是一个概念群，包括“现代”“现代化”“现代性”“现代主义”等。 “现代”是一种新的时间意识 在古代人的历史观念中，“当下的时代”不过是以往时代的延续和重复，没有什么新奇之处，也就不值得特别的关注。
“当下的时代”不再是以往的延续和重复，而是前所未有的，是崭新的。
一切固定的东西都烟消云散了，一切神圣的东西都被亵渎了
04 | 路标 韦伯与现代思想的成年 韦伯是现代思想“走向成年的里程碑”。 韦伯的人生 他是百年前德国最大的“公共知识分子”。这是韦伯思想生涯的第一个特点。
他在学术上的涉猎非常广泛，而且都卓有成就，被公认为百科全书式的学者。这是韦伯思想生涯的第二个特点。
1920年6月，刚满56岁的韦伯英年早逝。
我们将再也见不到他的同类，尘世的一切莫不如此。
看清理性化的世界 人到了怎么样的境界可以称为真正的成年？我认为大概有两个标志：第一是明白自己，对自己的过往有真正的理解；第二是反思自己，能看透自己存在的问题。
不只是在过自己的生活，而且能够有意识地反观自省你的生活。
看清现代，反思现代，让现代社会迈入了“不惑”之年。
看清现代，就是真正理解现代社会运作的底层机制。
直到韦伯以“理性化”为核心，建立了一套现代化理论，才第一次全面而系统地解释了现代社会的来龙去脉和运转机制。
反思现代，就是指出现代性最深层的缺陷。
我们现在说的缺陷，是根植于现代化本身的问题。这些问题不会随着社会进步而消失，反而会因为现代社会的发展而越来越严重。学术界将这类问题叫作“现代性问题”。
韦伯到底洞察到了现代社会的什么奥秘？其实就是三个字：“理性化”。
韦伯发现，工业革命、科学革命、地理大发现，这些大事件背后有一个统一的思想动力，就是“理性主义”。
反思理性化的后果 对于有些问题，甚至是极为重要的问题，科学无能为力。
认为科学是通向幸福之路，这是“天真的乐观主义”，只有书呆子才会相信。科学根本就无法回答什么是“幸福”、什么是“意义”这一类的问题。
这是生命意义的问题，超出了科学的边界。科学永远无法回答：我们做出什么样的选择才是“值得”的，我们过什么样的生活才是“有意义”的，我们生命的“目的”究竟是什么。科学也许可以给出最优的“方案”，但永远无法教给我们一个最优的“选择”。
科学和理性如何塑造了现代社会，在政治、经济、精神的深层结构中形成了怎样的“运行方案”。同时他又向我们指明：这些方案和方案背后的理性主义，不仅很难带我们走向真理和意义，还可能会让我们离意义越来越遥远，甚至还会带来许多前所未有的新麻烦。
韦伯真正的贡献不在于阐明了现代的理性化特征，而是揭示了理性化的各种复杂后果，打破了启蒙时代以来对于科学理性的乐观主义错觉。
首先，他不是简单肯定或全盘否定科学理性的意义，而是深入地分辨科学理性能做什么和不能做什么，而且在科学能做到的理性化后果中，同时阐明其正面的成就和负面的问题。
人与自然的关系，人与人的关系以及人与自我的关系，同时切入了现代人的精神信仰领域与现代社会的制度结构领域。
韦伯深刻把握了理性化对现代世界的塑造力量及其巨大成就，也敏锐地觉察到理性化造成的缺憾与弊端。
世界的祛魅”“诸神之争”“现代的铁笼”，以及一个重要概念“工具理性”。
05 | 韦伯I 为什么说“祛魅”是人类的梦醒时分 世界的祛魅”，也有人翻译成“除魅”（disenchantment）。
世界被祛除了魅惑性、神秘性”，人对自然世界的认识发生了改变。
魅惑的古代世界 它意味着人和世界之间是可以建立起某种联系的，甚至是可以沟通和互动的。
让人类与整个宇宙紧密相连为一个整体，构成宇宙秩序（cosmos）。
在这个意义上，古代的人类是“嵌入”在整体宇宙之中的。
理性化与祛魅 祛魅意味着什么呢？简单地说，就是用理性的力量驱散了神秘的魅惑。
祛魅的第一个阶段叫“宗教的理性化”，就是驱逐原始宗教中的各种巫术，用哲学理性来论证宗教的合理性，论证它的救赎意义。
在这个阶段，祛魅并没有瓦解宗教，反而使宗教获得了理性化的发展。
现在世界上没有什么神秘的东西了。
自然世界客观化了，不再具有神性和灵性了，成为可以用冷冰冰的因果规律解释的物理世界了。
古代社会中那种无处不在的意义消失了，那些与世界的联系和沟通也没有了。
我们的时代，是一个理性化、理知化，尤其是将世界之迷魅加以祛除的时代；我们这个时代的宿命，便是一切终极而最崇高的价值，已自公共领域隐没……
世俗的时代，宗教虽然仍然被许多人信奉，但它不再是人类寄托生命意义的默认选项了。
清澈之后的荒凉 在古代社会，人是“嵌入”这个世界里的，是和世界连为一体的。而到了现代社会，他从那么大的“母体”中被剥离出来，从此孤独地、无依无靠地存活在这个世界上。</description>
    </item>
    
    <item>
      <title>第二性（合卷本）</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E7%AC%AC%E4%BA%8C%E6%80%A7%E5%90%88%E5%8D%B7%E6%9C%AC/</link>
      <pubDate>Wed, 28 Sep 2022 11:16:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E7%AC%AC%E4%BA%8C%E6%80%A7%E5%90%88%E5%8D%B7%E6%9C%AC/</guid>
      <description>西蒙娜·德·波伏瓦
第一部 命运 女人吗？这很简单，喜欢简化公式的人这样说：女人是一个子宫、一个卵巢；她是雌的，这个词足以界定她。
。无生气的、不耐烦的、狡猾的、愚蠢的、不敏感的、淫荡的、凶狠的、卑下的，男人把一切雌性动物同时投射到女人身上。
在动物界，雌性代表着什么？在女人身上，表现的是何种特殊类型的雌性？
雄性和雌性是一个物种中出于繁殖目的彼此相异的两类个体，人们只能相应地界定它们。
观察证明，无性繁殖可以没完没了地进行，而不会发生任何退化；
雌雄同体在植物中非常多，在大量低等动物中也可以遇到，其中有环节动物和软体动物。
无论如何，一个系统高于另一系统的概念，牵涉到进化论，便导致最不可靠的理论。
大部分哲学把分成雌雄两性看成既定，却不想加以解释。
女人是一个“偶然出现的”人，这是从男性的观点提出性别偶然产生的特点。
类属在其中像结果一样产生，以抗拒其个体实在性的不相称，又像这样一种欲望，即通过与其物种的另一个体相结合，在这另一个体中重新找到自我感觉，并由此将类属包裹在其本质中，将类属引导到存在。这就是交配。
男人正是在性活动中确定两性和两性之间的关系，正如他们在完成一切职责中创造其意义和价值，但是性不一定包含在人的本质中。
人的存在迫使我们修正必然性和偶然性的概念。
他的命运的本质特点之一，是他的暂时生命之运动，在他之后和在他之前创造出过去和将来的无限性，物种的延续于是就关系到个体的局限；
在大多数物种中，雌性和雄性的机体进行合作是为了繁殖。它
许多所谓深刻的理论建立在这种可疑的玩弄类比上。
第二部 历史 人类不是一个简单的自然物种，并不追求作为物种延续；它的计划不是停滞，它要趋向于自我超越。
为了将世界的财富据为己有，他吞并世界本身。
根据生物学，一个物种只有自我更新才能维持下去，但这种更新只不过是同一生命以不同的形式重复再现。正是通过存在来超越生命，人类才保证生命的重复再现，通过这种超越，人类创造了价值，而纯粹的重复不具有任何价值。
男人在为物种效劳时，是在塑造世界的面貌，他创造新工具，他发明，他铸造未来。他把自己确立为统治者，得到女人的协助，因为她也是一个生存者，超越性驻足于她身上，她的计划不是重复生命，而是超越到另一个未来；她在自己存在的核心确认男性意图。她在庆祝男性的成功和胜利的节日中与男人联合起来。
第三章 性的启蒙 性爱在自然的终结中，在高潮中达到统一。性交有明确的生理目的；雄性通过射精排泄出压抑着他的分泌物；发情之后，雄性获得完全的解脱，肯定伴随以快感。
快感不是唯一目的；它往往紧随着失望，与其说获得满足了，倒不如说需要消失了。
女人的性欲要复杂得多，它反映了女性处境的复杂性。
女人正是通过阴道被插入和受精的，阴道只有通过男性的干预才成为性欲中心，这种干预总是构成一种侵犯。
正常的性交确实使女人从属于男人和物种。
在正常情况下，她总是被男人占有，而他只有在阴茎勃起的情况下才能占有她；阴道痉挛比处女膜更确定地将女人封闭起来；
即使女人没有感到任何快感，受精也可以进行。
父权制文明要求女人保持贞操；人们多少公开地承认男性有满足性欲的权利，而女人要禁闭在婚姻中，对她来说，如果性行为没有受到法规和婚配的许可，就是一种错失、一种堕落、一种失败、一种缺陷；她应该捍卫自己的贞操和荣誉；如果她“屈服”，如果她“堕落”，她就引起蔑视；而即使人们对她的征服者加以责备时，仍然夹杂着赞赏。
对女人来说，夫妻关系是一种“服务”，男人以礼物来感谢她，或者保证养她，但服务就是给自己一个主人；在这种关系中没有任何相互性。婚姻的结构和妓女的生存一样，在于证明女人出卖自己，男人付给她报酬并占有她。
极端种族主义的美国南方人，在风俗上却总是被允许和黑人妇女睡觉，在南北战争以前和今日都一样，他们以领主的狂妄态度运用这个权力，而一个白种女人在奴隶制时期跟一个黑人私通，要被判处死刑，今日她会被处以私刑。
生殖行为在于一个人被另一个人占领，一方面是强加征服者的观念，另一方面是强加被征服事物的观念。
这个行为包含一个人被另一个人污染，给污染者某种自豪，给被污染者某种屈辱，即使后者是同意的。”
大多数少女在未被任何男人的手触到以前，就狂热地盼望抚摸。
我的臀部昨天还像男孩子的形状，如今变圆了，我整个人强烈感到一种期待，在我身上升起的一种召唤，其含义太清楚了，晚上我再也睡不着，辗转反侧，激动异常，又狂热又痛苦。
我不是寻找某个人，而是寻找男人。
第四章 女同性恋者 两性之间不存在严格的生物学区分；相同的体质被基因型确定了发展方向的荷尔蒙作用力所改变，但有可能在胚胎发育过程中发生偏离；结果出现介于男性和女性之间的个体。 第二部 处境 从传统说来，社会赋予女人的命运是婚姻
大部分女人今日仍然是已婚的、结过婚的、准备结婚或者因没有结婚而苦恼。
女性状况在经济上的演变，正在动摇婚姻制度，婚姻变成通过两个自主的个体自由赞同的结合；配偶的缔约是个人的，也是相互的；对双方来说，通奸是对婚姻的违约，离婚可以由双方在同等条件下达成。
无论如何，男性的监护正在消失。
婚姻对于男人和女人，向来都是以完全不同的方式表现出来的。
女人从来不构成一个与男性在平等基础上进行交换和订立契约的等级。
女人受制于生育和家务的角色不能给她保证同等的地位的原因。
某些原始民族中，单身男人往往不能独自保证自己的生计，成为一种贱民；在农业共同体中，一个女合作者对于农民是必不可少的；对于大多数男人来说，将某些苦活推给妻子是有利的；男人希望有稳定的性生活，希望有后代，而且社会也要求他为延续它作出贡献
女人作为奴隶或者仆从被纳入父亲和兄弟支配的家庭群体中，通常由一些男人将她婚配给另一些男人。
结婚是她唯一的谋生手段和使她的生存获得社会认可的唯一方式。
她应该为共同体生孩子；
她也有满足一个男人的性需要和料理家庭的职能。
强加给她的负担，被看做对丈夫的服务，他也要给她送礼，或者给她留下遗产，他要保证供养她；正是通过他，共同体履行了对奉献给它的那个女人的责任。
双方来说，婚姻同时是负担和利益，但他们的处境并不对称；
对少女来说，结婚是融入群体的唯一办法，如果她们“仍然是待字闺中”，在社会上她们就是废物。
他们在婚姻中寻找自己生存的扩大和确认，而不是寻找生存的权利本身，这是他们自由承担的一项义务。
女人在结婚时获得世界的一部分“封地”，法律保证她不受男人任性的支配，但她变成他的仆从。在经济上，这个共同体的首脑是他，因此，在社会看来，体现这个共同体的是他。
她把自己整个人献给了他，她把自己的贞操和忠贞不贰给了他。
既然他是生产者，是他超越家庭的利益，面向社会利益，在参与建设集体未来的同时，为家庭利益敞开未来，他体现了超越性。女人注定要延续物种和料理家庭，也就是说注定属于内在性。
一切生存都同时是超越性与内在性；为了自我超越，它要求延续，为了通向未来，它必须融合过去，与他人交往的同时，它要自我确认。
婚姻正是允许男人将这两者成功地综合在一起；他在自己的职业和政治生涯中，经历了变化和进步，感到自己在时间和世界中扩展；
当他厌倦了这种漫游时，他便建立一个家庭，固定下来，停泊在世界上；晚上，他在家里休整，妻子在家中照料家务和孩子，回想她保存的过去。她没有别的任务，只是纯粹千篇一律在延续生命和抚养子女；她要使物种持久地延续，保证每天一样的节奏和家庭的持久，把门锁好；人们不让她直接控制未来和世界；她只通过丈夫向群体超越。
她会寻找一个地位高于自己的丈夫，或者她希望他能更快地“往上爬”，比她更有发展前途。
认为从女人方面说，性交是她对男人的一项服务；他获得快感，他应该用补偿来交换。女人的身体是一个出售的物品；对她而言，它代表一笔资本，她被允许利用这笔资本。有时她带给丈夫一份陪嫁；她往往提供一定的家务劳动：她要持家，抚养孩子。</description>
    </item>
    
    <item>
      <title>人类简史：从动物到上帝</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E4%BB%8E%E5%8A%A8%E7%89%A9%E5%88%B0%E4%B8%8A%E5%B8%9D/</link>
      <pubDate>Wed, 28 Sep 2022 10:52:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E4%BB%8E%E5%8A%A8%E7%89%A9%E5%88%B0%E4%B8%8A%E5%B8%9D/</guid>
      <description>尤瓦尔·赫拉利
第一章 人类：一种也没什么特别的动物 有比较大的大脑、会使用工具、有超凡的学习能力还有复杂的社会结构，都可说是人类巨大的优势。 第二章 知善恶树 究竟人类的语言有什么特别的地方？
我们的语言发展成了一种八卦的工具。
如果一大群人想合作共处，“说坏话”这件事可是十分重要。
人类语言真正最独特的功能，并不在于能够传达关于人或狮子的信息，而是能够传达关于一些根本不存在的事物的信息。
讨论虚构的事物”正是智人语言
最独特的功能。
虚构”这件事的重点不只在于让人类能够拥有想象，更重要的是可以“一起”想象，编织出种种共同
的虚构故事，不管是《圣经》的《创世记》、澳大利亚原住民的“梦世记”（Dreamtime），甚至连现代所谓的国家其实也是种想象。
智人的合作则是不仅灵活，而且能和无数陌生人合作。
很多时候，公猩猩能坐上首领宝座不是因为身体更强壮，而是因为领导的集团更庞大也更稳定。
他们要怎样才能决定要由谁当首领，谁能在哪里打猎，谁又能和谁交配呢？
只要在150人以下，不论是社群、公司、社会网络还是军事单位，只要靠着大家都认识、彼此互通消息，就能够运作
顺畅，而不需要规定出正式的阶层、职称、规范。
算是大批互不相识的人，只要同样相信某个故事，就能共同合作。
无论是现代国家、中世纪的教堂、古老的城市，或者古老的部落，任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事。
除了存在于人类共同的想象之外，这个宇宙中根本没有神、没有国家、没有钱、没有人权、没有法律，也没有正义。
标致公司只是我们的一个集体想象，这种想象在法律上称为“法律拟制”（legal fiction）。
在法律上，这种公司是独立的个体，而不等于设立者、投资者或管理者。
难点不在于讲故事，而在于要让人相信。
通过文字创造出想象的现实，就能让大批互不相识的人有效合作，而且效果还不只如此。正由于大规模的人类合作是以虚构的故事作为基础，只要改变所讲的故事，就能改变人类合作的方式。只要在对的情境之下，这些故事就能迅速改变。
走上这条快速道路之后，智人合作的能力一日千里，很快就远远甩掉了其他所有人类和动物物种。
第三章 亚当和夏娃的一天 在这样的环境下，我们比前人享有更多物质资源，拥有更长的寿命，但又觉得疏离、沮丧而压力重重。
其实直到现代胚胎学研究发展之后，我们才有了确实的证据，证明孩子只可能有一个父亲。
时间一代一代过去，人和狗也一起演化，能和对方有良好的沟通。最能满足人类需求、最能体贴人类情感的狗，就能得到更多的照顾和食物，于是也更容易生存下来。同时，狗也学会了如何讨好人类，满足它们的需求。
同属一个部落的成员彼此相熟，人们终其一生都和亲友相处在一起，几乎没什么孤单的时刻，也没什么隐私
有时候，与邻近部落的关系实在太良好，最后就结合为一，而有了共同的语言、共同的神话、共同的规范和价值。
狩猎采集的生活方式依地区、季节有所不同，但整体而言，比起后来的农夫、牧羊人、工人或上班族，他们的生活似乎要来得更舒适，也更有意义。
整个动物界从古至今，最重要也最具破坏性的力量，就是这群四处游荡、讲着故事的智人。
第五章 史上最大骗局 大部分的动植物其实无法驯化。
农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过得更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。
人类以为自己驯化了植物，但其实是植物驯化了智人。
生存和繁衍正是最基本的演化标准，而根据这个标准，小麦可以说是地球史上最成功的植物。
种小麦可不容易，照顾起来处处麻烦。第一，小麦不喜欢大小石头，所以智人得把田地里的石头捡干净搬出去，搞得腰酸背痛。第二，小麦不喜欢与其他植物分享空间、水和养分，所以我们看到男男女女在烈日下整天除草。第三，小麦会得病，所以智人得帮忙驱虫防病。第四，不论是蝗虫还是兔子，都不排斥饱尝一顿小麦大餐，但小麦完全无力抵抗，所以农民又不得不守卫保护。最后，小麦会渴，所以人类得从涌泉或溪流
大老远把水引来，为它止渴；小麦也会饿，所以智人甚至得收集动物粪便，用来滋养小麦生长的土地。
从这种角度看来，1000份DNA拷贝永远都强过100份。这正是农业革命真正的本质：让更多的人却以更糟的状况活下去。
营养充足的时候，女性比较早进入青春期，成功怀孕的概率也比较高。而在土地贫瘠、营养不足的时候，女性进入青春
期要来得晚，生育能力也下降。
因为我们无法真正了解各种决定最后的结果。
所有改变都必须点点滴滴累积，经过许多代的时间，才能够改变社会；等到那个时候，已经没有人记得过去曾经有不同的生活方式可选了。
人类发现时，已经深陷陷阱、无法自拔。
有多少年轻的大学毕
业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背着巨额贷款，要付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且觉得生活里不能没有高级红酒和去国外的假期。他们该怎么做？他们会放下一切，回去野外采果子挖树根吗？当然不可能，而是加倍努力，继续把自己累得半死。
我们以为自己省下了时间；然而，我们其实是把生活的步调加速成过去的10倍快，于是我们整天忙忙碌碌、焦躁不安。
人类一心追求更轻松的生活，于是释放出一股巨大的力量，改变了世界的面貌，但结果并没有任何人料想得到，甚至也不是任何人所乐见的。
在传统的想象中，人是先建立起村落，接着等到村落繁荣之后，再在村落中心盖起信仰中心。但哥贝克力石阵显示，很有可能其实是先建立起信仰中心，之后才围绕着它形成村子。
最具侵略性
公羊是人类想控制羊群最大的阻力，所以第一个就宰它们。至于瘦小或是太有好奇心的母羊也是除之而后快。（太有好奇心，就容易走得离羊群远远的，对牧羊人来说可不是好事。）
蛋鸡、奶牛和提供劳力的役用动物有时候能多活上几年，但代价就是过着完全不符合它们天性和渴望的生活。
驯化动物的过程几乎总是会将雄性阉割，好抑制雄性的侵略性，也让人类能够控制挑选牲畜的生育。
但请注意，这位埃及农民也是驼着背做事；这跟牛没什么两样，就是一辈子做着有害身体、心灵和社会关系的劳力工作。）
相较之下，肉牛这个物种虽然在数量上大获成功，却完全无法安慰那些单独个体所承受的痛苦。
每当人类整体的能力大幅增加、看来似乎大获成功，个人的苦痛也总是随之增长。
就演化而言，牛可能是有史以来最成功的动物。但同时，它们也是地球上生活最悲惨的动物。
第六章 盖起金字塔 一般来说，农民就会和房屋这种构造建立起非常强烈的连接。这场革命意义深远，除了影响建筑，更影响了心理。
随着时间过去，他们拥有
东西越来越多，不易搬运，也把他们绑得死死的。
毕竟，如果是那些无法影响的事，就算担心也没用。</description>
    </item>
    
    <item>
      <title>大问题：简明哲学导论</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%A4%A7%E9%97%AE%E9%A2%98%E7%AE%80%E6%98%8E%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA/</link>
      <pubDate>Wed, 28 Sep 2022 10:52:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%A4%A7%E9%97%AE%E9%A2%98%E7%AE%80%E6%98%8E%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA/</guid>
      <description>[美]罗伯特·所罗门
哲学问题 哲学发端于令人困惑的个人问题。
哲学就是去进一步思考这些激动人心的、有时会突然变得极为重要的问题。
简单地说，哲学就是对诸如生命、我们知道什么、我们应当怎样做或应当相信什么这样一些重大问题的探究。
一个人首次试图去思考他以前从未讨论过的一些问题时，其结果很可能是令人尴尬的、愚笨的甚至是令人心灰意冷的。
哲学经常是当两个哲学家或学习哲学的学生相互辩论时凭着意见的不同而有所推进的。
发展了一套基于个人理性进行思维的方法，即除了“明晰的理性之光”以外不承认任何权威。
他的哲学的第一个前提是他自身存在的不可怀疑性。
开篇问题 有一位德国哲学家曾经说过，你羡慕谁就是对你是谁的检测。
我们看待世界的最重要的观念之一就是对善有善报、恶有恶报的信念。当然，事实上并不都是如此。
可朽的人具有不朽的性质，就是靠着孕育和生殖。
生殖是一个可朽的人通往永恒和不朽的最便捷的途径。
开篇问题 你对自己是怎样看的？你最终的目标、期待、希望和恐惧是什么？
生活的意义是什么？这是最难回答、最需要回答同时又是最模糊不清的大问题。
“意义”一词的意义本身就是不明确的。
意义的意义 对于我们当中的大多数人来说，生活意义的问题最可能在我们情绪低落或命运多舛的时候产生，这个时候，我们的头脑大都处于混乱状态。
在日常生活中，当我们不对事情进行哲学思考或一般性思考的时候，生活似乎充满了意义。
“力事皆空”。
我们开始超越生活本身来寻找生活的意义，这也是哲学的最终问题。
如果以这种方式来现解意义，那么我们就可以说，每个人生活的意义就是他的生活所指向的无论什么东西。
人们完全可以反驳说，生活并不指向任何东西，生活就是生活。
也许，问题出在把意义当成它的所指上。
人一切的劳碌，有什么益处呢？一代过去，一代又来，地却永远长存。
己有的事，后必再有；已行的事，后必再行。日光之下，并无新事。
后来，我察看我手所经营的一切事和我劳碌所成的功，谁知都是虚空，都是捕风，在日光之下毫无益处。
指向要涉及语境，生活中也莫不如此。
追问作为一个整体的生活的意义是没有意义的。
有四种回答值得说一说：即认为自己的孩子是生活的意义，认为上帝是生活的意义，认为来生是生活的意义，以及在绝望中忙不迭地认为生活没有意义。
如果生活的意义不在于我们自己的生活，而在于他人的生活，那么什么才能使他们的生活有意义呢？
人们总是试图以这种方式为将来抽象地谋划一个全然安宁快乐的地方——哲学家们称之为乌托邦，这就是他们希望自己的孩子，孩子的孩子，或孩子的孩子的孩子生活的样子。但这又怎样使他们自己的生活有意义呢？对于那些快乐地生活在乌托邦中的远亲来说，生活的意义又是什么呢？
对于那些信仰上帝的人来说，这个问题根本就不成其为问题，在上帝的存在受到怀疑之前，生活的意义从不会成为困惑。
上帝为什么要创造我们？他指望我们什么？他创造我们是为了什么？
如果他是无所不能的，那他为什么还要这样做？是为了证明什么吗？（向谁证明？）是为了满足虚荣心吗
我们为什么要认为，自己之所以被创造出来，是为了实现某种特殊的使命或目的？如果事实的确如此，那么什么才是这个使命或目的？
什么才是我们生活的意义？信仰上帝似乎只能使问题显得更为棘手，而并没有解决它。
在这个无足轻重的今生中，我们应当如何行事才能使来生得到报偿呢？仅凭信仰？善行？尽情享受生活？发掘我们的艺术潜质或社会潜力？使异教徒皈依？学习烹饪？问题又一次在原地打转。
如果今生是如此无关紧要，那么，什么才能保证来生更有意义呢？
生活其实没有任何意义。
生活是荒谬的。
信仰上帝 关键是要理解我自己，理解上帝真正希望我做什么；关键是要找到一条对我来说为真的真理，找到那种我愿意为之生和为之死的理念。
相信上帝存在并不等于信卯上帝。
作为与我们的生活息息相关的事情，信仰上帝并不只是相信上帝存在着，它也是信仰某种特定想义的上帝，这个上帝以某种方式影响着我们，而我们也在某种意义上影响着他。
什么是最真实的？ 从根本上说、本体论就是关于什么是最真实的东西的研究。
“实在”是一个评价性术语，它是一种衡量在我们对世界的理解中什么是最基本的和最真实的方式。
我们完全不相信世界这回事，或者完全不相信我们用于相信世界的心灵的存在，
对实在进行思考的全部目的就是，以某种方式区分出世界上哪些东西是最基本的和最无可置疑的，哪些东西则不是。
哲学上引起最大困难的一个区分就是“现象”与“实在”的区分，事物好像是什么与它究竟是什么的区分。
如果实在并不就是所表现出来的那种样子，那么，我们有没有什么方法知道究竟有没有任何的实在呢？
“什么是真实的？
它从不问“为什么”，它有的只是期待，而不是理论。
外表的运动对我们来说是不够的，我们还想知道内部是怎么一回事。
正是这种在我们所看到的、显得如此的东西和使我们能够解释它的“更深层的”图景之间所做的区分，才迫使我们引入了“实在”这一概念。
不同的本体论对于“真实”的理解是非常不同的。
我们想当然地认为自己的感觉是最可靠的知识来源，并且会把我们的亲眼所见看成相信某种事物的理所当然的依据。
发现事物的名称远远重于事物的本质，这件事曾经使我而且一直使我异常吃力。声誉、名号、外表、效力、事物的一般范围和分量，这些东西在产生时便是错误的，是随心所欲的，像给事物披上一件外衣，而与事物的实质甚至皮相也风马牛不相及，但由于世世代代对这些东西深信不疑，而且这种相信还在不断加深，久而久之，它们在事物中不断壮大，甚至变成事物本身了。表象终于成了本质，并且作为本质在发挥作用！
创造新的名称、评诂和可能性，便足以持续创造出新的“事物”来。
形而上学试图弄清楚实在是怎么一回事，本体论是形而上学的一部分，它研究什么存在；宇宙论是另一个部分，它研究最真实的东西是怎样产生的。
第一种是，最真实的对象是那种其余事物都依赖于它的对象。
第二种是，最真实的对象是那种本身不会被创造或毁灭的对象。
当我们回溯哲学与形而上学的开端时，当人们第一次试图用什么是最真实的什么不是最真实的等说法提出他们对世界的看法时，我们发现这两种检验方式都被用到了。
什么是自由？ 当人们可以自由地做他们想做的事情时，他们往往相互模仿。
自由常常是一个否定性的概念；它是针对某事的回应，我们只有在特定的背景下，才能知道这个“某事”的意思。
它意味着“摆脱……的自由”。</description>
    </item>
    
    <item>
      <title>存在主义咖啡馆：自由、存在和杏子鸡尾酒</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%92%96%E5%95%A1%E9%A6%86%E8%87%AA%E7%94%B1%E5%AD%98%E5%9C%A8%E5%92%8C%E6%9D%8F%E5%AD%90%E9%B8%A1%E5%B0%BE%E9%85%92/</link>
      <pubDate>Wed, 28 Sep 2022 10:52:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%92%96%E5%95%A1%E9%A6%86%E8%87%AA%E7%94%B1%E5%AD%98%E5%9C%A8%E5%92%8C%E6%9D%8F%E5%AD%90%E9%B8%A1%E5%B0%BE%E9%85%92/</guid>
      <description>莎拉·贝克韦尔
第一章 先生，太可怕了，存在主义！ 存在主义到底是什么。
简言之，可以追溯到每一个曾对任何事感到过不满、叛逆和格格不入的人。
西蒙娜·德·波伏娃
让-保罗·萨特
这个男人对你告诉他的每一件事，都感兴趣。
雷蒙·阿隆
现象学”（phenomenology）
传统的哲学家常常从抽象的公理或者理论出发，但是德国的现象学家，却直接研究起了他们时刻正在经历的生活。
事物是否真实”或者“我们如何确定地知道某事
任何问出这些问题的哲学家，本身就已经被抛入了一个充满事物的世界——或者说，至少是一个充满事物外观，也就是“现象”（phenomena，出自希腊语，意为“出现的事物”）的世界
为什么不忽略其他，专注于和现象的相遇呢？那
让哲学家去处理那些更为实际的问题。
埃德蒙德·胡塞尔
回到事物本身（to the things themselves）!
别在事物不断累加的诠释上浪费时间了，尤其是别浪费时间去琢磨事物是否真实了。你需要做的，就是观察把自己呈现在你面前的“这个东西”，且不管“这个东西”可能是什么，然后尽可能精确地把它描述出来。
马丁·海德格尔
他认为，纵观历史，所有哲学家都把时间浪费在了次要问题上，而忘记去问那个最重要的问题——存在（being）的
问题。某物存在的意思是什么？你是你自己意味着什么？
无须理会智识的杂乱，只要关注事物，让事物向你揭示自身即可。
如果你是一个现象学家，你可以谈论这杯鸡尾酒，然后从中研究出哲学来！”
他们注意到它的好了：这是一种把哲学与日常生活经验重新联结起来研究哲学的方式。
有关知识的问题以及没完没了地重新诠释康德著作支配了一切。知识论的问题互相交叠在一起，就像万花筒在一圈圈地旋转后，总是又回到原点
我想我知道某事，但我怎么知道我知道我知道的是什么？
萨特可以去学德语，读现象学家的原版论著，并就近吸收他们的哲学能量。
他厌倦了教书，厌倦了在大学所学的一切，厌倦了尚未成为自己从小就期望的天才作家这一现状。
要写他想写的东西——小说、散文，一切
他知道首先必须去冒险。
他曾想象去君士坦丁堡跟码头工人一起劳动，去阿托斯山同僧侣一起冥想、修行，去印度随贱民一起躲藏，去纽芬兰岛的海岸和渔民一起抵抗风暴
他带回了一种融合之后的新哲学：德国现象学的方法，结合着更早之前丹麦哲学家索伦·克尔凯郭尔以及其他思想，又装点了一味独特的法国调料—
他以一种现象学创立者未曾想见的但却更让人兴奋和个人化的方式，把现象学应用到人们的生活之中，创建了一种兼具国际影响和巴黎风味的新哲学：现代存在主义。
萨特会像小说家一样写作——用不着惊讶，因为他自己就是小说家。
获得自由意味着什么。
自由，在萨特看来，位于人类所有经验的中心，正是这一点，才把人类与其他事物区分开来。
萨特相信，就连人之外的动物，大多数时候也只是在听从塑造了它们那个物种的本能和习性行事。但作为一个人，我根本没有预先被决定的本性。我的本性，要通过我选择去做什么来创造。当然，我可能会被我的生物性影响，或者被我所处的文化和个人背景等方面影响，但这些并不能合成一张用来制造我的完整蓝图
总是先我自己一步，边前行，边构筑自身。
存在先于本质”（Existen
ce precedes essence）。
发现自己被抛入世界中后，我会持续创造我自己的定义（或本性，或本质），但其他客体或生命形式却不会这样。
可能认为你可以用一些标签定义我，但你错了，因为我始终会是一件正在加工的作品。
不断地通过行动创造自身，
它本身就是人类境遇，从有第一缕意识那一刻开始，直到死亡将其抹去为止。我是我自己的自由：不多，也不少。
存在主义的国王与王后。
《存在主义是一种人道主义》（L&amp;rsquo;existentialisme est un humanisme），英译本名为《存在主义与人道主义》（Existentialism and Humanism）。
那么，他应该做对他母亲来说正确的事，让她独享明显的益处，
还是应该冒险去参加战斗，做对大多数人有益的事？
你看见一辆行驶中的火车或电车，正沿着铁轨冲向不远处被绑住的五个人——如果你什么都不做，这五个人就会死。你注意到，如果扳动一根操纵杆，就可以让火车变道至侧轨，但是如果你这么做了，就会杀死一个被绑在侧轨上的人；而你不这么做的话，那个人就是安全的。因此，你是愿意牺牲一人，还是什么都不做，听凭五个人死去？
胖子难题”中，你只能从附近的桥上把一个大胖子扔到铁轨上，来使火车脱轨。这一次，你要亲手去碰你打算杀掉的人，因而就
为你带来一个更直接也更难解的窘境。）
但这里的情况更为复杂，因为事实是，他既不确定自己的英国之行是否真的能帮到任何人，也不确定离开母亲是否会严重伤害她。
基督教的道德思想，只会告诉他要爱邻人、要对他人行善事，但却没有说清楚“他人”是谁——母亲还是法国。
然后，他又试着去聆听内心的声音：也许在内心深处，他会找到答案。然而并没有：在他的灵魂里，这个学生只听见一堆七嘴八舌的声音（
你是自由的人，那就去选择吧——也就是说，去创造（invent）。
在这个世界上，没有天赐的奇迹，
没有哪个古老的权威能够解除你身负的自由重担。你尽可以小心翼翼地去权衡各种道德与实际的考虑，但说到底，你都得冒险一试，去做点儿什么，而这个什么是什么，由你决定。
即使他们的困境没有那个学生那么极端，他们每一个人也都跟他一样自由。
也许你正面临处决，或是被囚禁在盖世太保的监狱里，或是即将坠落悬崖——你也仍然可以自由地在心中和行动上决定如何去看待它
从你现在所处的地方开始，你进行选择。而在选择中，你便选择了你将会成为什么样的人。</description>
    </item>
    
    <item>
      <title>少有人走的路：心智成熟的旅程</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E5%BF%83%E6%99%BA%E6%88%90%E7%86%9F%E7%9A%84%E6%97%85%E7%A8%8B/</link>
      <pubDate>Wed, 28 Sep 2022 10:52:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E5%BF%83%E6%99%BA%E6%88%90%E7%86%9F%E7%9A%84%E6%97%85%E7%A8%8B/</guid>
      <description>M.斯科特·派克
名人名家评论 真正的爱，不是单纯的给予，还包括适当的拒绝，及时的赞美，得体的批评，恰当的争论，必要的鼓励和有效的监督。”
你不解决问题，你就会成为问题。
推迟满足感、承担责任、尊重事实、保持平衡。
第一部分 自律 自律是解决人生问题最主要的工具，也是消除人生痛苦最重要的方法。 抑郁的价值 他们需要在短时间内放弃相当数量的“过去的自我”
放弃某种心爱的事物——至少是自己熟悉的事物，必然会带来痛苦，但这也是心智成熟所必需的。
只有放弃旧的、过时的观念和习惯，才能渡过危机，顺利进入人生的下一阶段。
无需对外界要求作出回应的婴儿状态无所不能的幻觉完全占有（包括性方面）父亲或母亲（或二者）的欲望童年的依赖感自己心中被扭曲了的父母形象青春期的自以为拥有无穷潜力的感觉无拘无束的自由青年时期的灵巧与活力青春的性吸引力长生不老的空想对子女的权威各种各样暂时性的权力身体永远健康最后，自我以及生命本身
总体说来，这些就是我们在人生过程中必须放弃的生活环境、个人欲望和处世态度。放弃这些的过程就是心智完美成长的过程。
坠入情网 首先，坠入情网，通常会产生与性有关的欲望。
人们之所以坠入情网，是因为他们在意识和潜意识里有一种性的冲动。
坠入情网的“爱”不会持续太久，不管爱的对象是谁，早晚我们都会从情网的羁绊中爬出来。
心理学上所谓的“自我界限”。
婴儿在出生的第一年会明白一些基本的常识：我们是谁，我们不是谁；我们是什么，我们不是什么。出生一年后，他们就清楚地知道：这是我的胳膊、我的脚、我的头、我的舌头、我的眼睛，甚至我的视角、我的声音、我的想法、我的肚子疼、我的感觉……此时，他们能区分出自己和外在世界更多的不同，能够认识到自己身材的大小、体能的局限性，这样的认知就是所谓的“自我界限”。
他们渴望突破自身的局限，却又受到自我界限的限制，这通常使他们产生无助的痛苦。
坠入情网，意味着自我界限的某一部分突然崩溃，使我们的“自我”与别人的“自我”合而为一。
突然冲出自我界限的牢笼，情感就像决堤的洪流，声势浩大地涌向所爱的人，于是寂寞消失了，代之以难以言喻的狂喜之感：我们跟爱人结合在了一起！
在某种意义上，坠入情网是情感和心灵的一种退化。
我们感觉爱无比强大，能够征服一切，前途无限光明。但我们没有意识到，这样的感觉是虚幻的，常常与现实脱节。
残酷的现实，迟早会击溃两岁孩子的幻想，同样也会击溃我们的爱情之梦。
坠入情网并不是真正的爱，只不过是爱的一种幻觉而已。
坠入情网并不是自我界限的扩展，而是自我界限部分地暂时性地崩溃。
当最初的激情褪去时，自我界限必然恢复原状，留下的只有失落和幻灭，心灵绝不会因此成长。
坠入情网唯一的作用是消除寂寞，而不是有目的地促进心灵的成长。即使经过婚姻，使这一功用延长，也无助于心智的成熟。
我们忘记了一个事实：我们和爱人的心智其实都还不完善，需要更多的滋养。
坠入情网既然不是真正的爱，那么它的本质究竟是什么呢？仅仅是自我界限暂时的崩溃吗？在我看来，它与人的性欲（性的需求和原动力）有关。坠入情网，是人类内在的性需求与外在刺激发生作用时，所产生出的典型的生理和心理反应，其意义在于增加人类的生殖机会，促进物种繁衍和生存。或者说，坠入情网是人类原始基因对于人类理性的征服，使我们心甘情愿地落入婚姻的“陷阱”。
爱与心理治疗 心理医生应该根据患者的实际情况，采取恰当的治疗手段，而且要基于一个基本前提：医生必须诚实地对待患者，而且要始终如一。 爱的神秘性 真正的爱，其对象一定是人，只有人的心灵才具有成长的能力，可是，我们又如何解释其他形式的美，同样能够带给我们强烈的爱的感觉呢？
真正了解爱的秘密的人，也许是那些潜心研究宗教的人。
导出于 2022-09-28 10:52:51</description>
    </item>
    
    <item>
      <title>当下的力量</title>
      <link>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E5%BD%93%E4%B8%8B%E7%9A%84%E5%8A%9B%E9%87%8F%E7%8F%8D%E8%97%8F%E7%89%88/</link>
      <pubDate>Wed, 28 Sep 2022 10:52:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%BA%BA%E7%94%9F/%E5%BD%93%E4%B8%8B%E7%9A%84%E5%8A%9B%E9%87%8F%E7%8F%8D%E8%97%8F%E7%89%88/</guid>
      <description>埃克哈特·托利
版权信息 你生存在这个世界就是要使宇宙的神圣目标得以实现。你看，你是多么重要。 导读 活在当下 《当下的力量》是教导我们一种新的生活方式，告诉我们如何可以把日常生活中我们受的苦减到最少。
思维其实也不是问题，问题出在我们无法控制自己的思维，反倒成为思维的奴隶，成为自己“强迫性思维”的受害者。
制止不住大脑的思考，是让我们受苦的主要原因。
我们都知道ABC理论，A是引发你情绪的事件，B是你的信念或你对事情的诠释，C就是结果，即你的负面情绪。
B是你唯一可以完全掌控和改变的因素，而且引发C的不是A，而是B
与其去改变外在的人、事、物，不如改变我们自的内心来得省事省力。
大脑的思维不但在日常生活中制造我们的痛苦，我们人类最基本的存在性焦虑和永远在外在世界无法寻得满足的肇因，都来自于大脑的思维。
我们远离了真实的自我，这是我们受苦的元凶。他称真实的自我为本体或存在（being）。
我们的大脑，创造了一个虚假的自我—小我，来让自己有“真实感”。而正因为小我是如此的不真实，所以它不停地在外在的世界寻求认同，追求物质世界的满足来壮大声势。
活在当下。当下有你所有想要的东西，当下也是你唯一拥有的东西。
只要搞定现在这一刻，你就没有问题了。未来就算一定会来临，但是它也一定是以“当下“的方式出现的，不是吗
最怕的就是明明人在这里，可是脑子跑到过去，带来了愤怒、伤心、悔恨、愧疚等情绪。或是人在此刻，脑子跑到未来，于是就产生了压力、焦虑、恐慌。
活在当下，活在每一刻中，作者称之为“临在”（presence，第五章）
前言 过去对我来说几乎无用，我也很少去想它。
所有的一切都感觉如此陌生，如此充满敌意，如此没意义，让我深深地厌恶这个世界。
开悟的最大障碍 你的内在
那些没有找到他们真正的财富，也就是本体的喜悦以及与它紧密联系在一起的、深刻而不可动摇的宁静的人，就是乞丐，即使他们有很多物质上的财富。他们四处寻找成就、安全感或爱情所残余的欢乐或满足，但是他们不知道自己不仅已经拥有了所有的这些东西，而且还拥有了比这些更为珍贵的东西。
它其实就是一种简单的与本体合一的自然状态
它是一种与不可衡量的、不可摧毁的事物相联系的状态。几乎矛盾的是，它其实就是你自己，但又比你更伟大。它找到了超越你名字和形象的真正本质。如果你不能感觉到这种联系，你就会有一种与自己以及与你周围的世界相分离的幻象。你会有意识或无意识地感到自己就像一个孤立的碎片。然后，你内外部的恐惧、冲突和矛盾也随之产生。
我喜欢佛陀将开悟简单地定义为“受苦的终结”（the end of suffering）
它仅告诉你开悟的否定性定义：受苦停止。 但是，当没有受苦存在时，还剩下什么呢？
本体是超越那些受限于生死的各种生命形式而永在的“至一生命”（One Life）。作为无形的、不灭的本质，本体不仅超越了所有生命形式，更深深地根植于每种生命形式之中
作为你最深的自我和真实的本质，你可以在每个当下接触到它
只有当你的思维处于静止时，你才会领会它的真正含义
你的思维处于静止时，当你的注意力完全集中在当下时刻时，你就会感觉到本体，但是从心智上我们永远无法理解它
重新觉知到本体，并保持这种觉知体验的状态就是开悟
上帝”这个词已经成了一个封闭的概念。当人们说出这个词时，他们就会构想一个形象出来，也许不会是一位白胡子的老人，但是仍然还是一个置身于你之外的人或是物，同时不免是个男性或雄性的形象。
本体是一个开放的概念，这是它的优势。它没有将一个无限的、无形的东西缩减成一个有限的实体。人们不可能在头脑中构想出一个关于本体的意象，也没有人能够宣称他独自拥有本体
它是你的本质，只有当你感觉到临在时，你才会立即领会到“我是”的真谛
是认同于你的思维，它使人们进行强迫性的思考。
不能停止思考是一个可怕的烦恼，由于几乎每一个人都遭受着此种痛苦，而我们又无法意识到这一点，所以这就成了一件很正常的事情
这种不停的思维活动使你无法达到内心的宁静状态。同时，它创造了一个虚假的自我，不断投射出恐惧和苦难的阴影
将思考视为存在并且认同于思考。
开悟是一个圆满的境界，合一而和平，与生命以及它所显化的世界合一，同时，与你最深的自我的未显化的生命，也就是本体合一
开悟不仅是痛苦和身心内外冲突的终结，也是思考的终结，这将会是一次不可思议的解放！
思维认同创造了一连串的概念、标签、意象、词语、判断和定义，阻碍了你所有真正的关系
在我们肉身表相看来是与众生分离的情形之下，你其实是与万物合一的。
思维已经变成了一种疾病
准确地说，不是你利用思维的方式不对—基本上你根本没有利用它，而是它在
利用你。这就是一种病态。你认为你就是你的思维、你的大脑，其实这只是种幻觉，这个工具已然控制了你。
无论何时，当你想从思维中解放出来的时候，你能做到吗？你找到了停止思考的那个按钮吗？
你无意识地认同了它，所以你甚至不知道自己是它的奴隶
从思维中解放出来的开始就是认识到你不是一个思考问题的实体—思考者。认识到这一点能使你很好地观察这个思考者
在你观察这个思考者时，一个更高层次的意识就被激活了。然后，你会开始意识到有很大的一片超越思想的智性，思想只是这个智性的一个小方面。你同样还会认识到所有真正重要的事情，如美貌、爱情、创造力、欢乐、内在的宁静等，都是来自于大脑之外的。你开始觉醒了。
从你的大脑中解放出来 这就是所谓不自主的思考过程，你却没有意识到你有阻止这种独白或对话的力量。
那个声音不停地在评论、推测、批判、比较、抱怨、选择好恶等。这种声音可能与你当下所在的情况无关，它可能是关于过去或未来的一些事情，它可能是在回忆往昔，或是在幻想未来可能发生的事情。它经常想象事情可能会出差错，或产生不利的后果
好消息是你能从你的思维中解放出来。这是唯一的真正的解放
倾听你脑袋中的声音并作为一个观察者的临在。
那里有一种声音，而我在这里倾听它，观察它。这是一种自我存在的感觉而不是思维。它超越了你的思维。
当你在倾听思维时，你不仅意识到了这种思维，而且还意识到了你在观察这种思维。这样，一个新的意识层面产生了
当一种思维止息时，你会在自己的心智流（mental stream）中体验到一种思维的中断—思维空白
你同样会感觉到一种来自你内心深处的喜悦。
这种内在的联结之中，你会比思维认同状态下更为警惕，更为清醒，更为临在。它同样会提升赋予你身体生命能量的振动频率。
在这种状态下，你会如此喜悦地感受你的临在：所有的思维、情绪、身体以及整个外部世界，在与你的本体比较之下，都不那么重要了
将你的注意力集中在当下这一刻，全神贯注于当下的时刻。这是一件非常值得去做的事情
在这种空白中，你高度警惕，注意力高度集中，但是你没有在思考。这就是冥想的本质。</description>
    </item>
    
    <item>
      <title>打开：周濂的100堂西方哲学课</title>
      <link>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E6%89%93%E5%BC%80%E5%91%A8%E6%BF%82%E7%9A%84100%E5%A0%82%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E8%AF%BE/</link>
      <pubDate>Wed, 28 Sep 2022 10:52:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%93%B2%E5%AD%A6/%E6%89%93%E5%BC%80%E5%91%A8%E6%BF%82%E7%9A%84100%E5%A0%82%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E8%AF%BE/</guid>
      <description>周濂
052 为了“有所不疑”必先“有所怀疑”：笛卡尔的《谈谈方法》 如果说古代哲学追问的核心问题是本体论问题，那么近代哲学追问的则是认识论问题。
本体论问题？简单说，就是外部世界存在着什么
什么是认识论问题？简单说，就是我们如何知道，以及我们能够知道什么。
在知道外部世界到底存在着什么之前，我们首先要考察能够知道什么。
近代哲学之父
071 国家为什么宁缺毋滥？——洛克的《政府论》（上） 所谓的“自然状态”，就像是实验室里的初始条件，它是一种理论“设置”
社会契约论者的潜台词是，作为一个有理性的人，只要你严格按照我设定的步骤去思考，就一定会接受我的最终结论。
一切人反对一切人”的战争状态
洛克认为政府的权力是有限的，人们只是将部分的自然权利以“信托”的方式交给政府，一旦政府不能履行保护自然权利的职责，公民有权推翻政府，为此不惜重返自然状态。
洛克与霍布斯之间最大的不同在于，他们对自然状态有着非常不同的描述。
对洛克来说，自然状态到底有哪些不方便，会让人们决定要成立国家呢？
第一，自然状态中虽然存在自然法，但自然法的特点是写在人类的理性里，而不是写在字面上，也就是说，它不是白纸黑字的成文法。
第二，在自然状态中，人们一旦发生纠纷，找不到一个具有公信力的和公正无私的裁判者，其结果就是人人都是裁判者。
第三，在自然状态中，即使人们对纠纷做出了正确的裁决，也缺少强有力的组织手段来执行这个裁决
战争状态是一种敌对的和毁灭的状态。
基于“根本的自然法”，每个人都“应该尽量地保卫自己”，“可以毁灭向他宣战或对他生命怀有敌意的人”。
我的基本观点是这样的：霍布斯的哲学重逻辑，洛克的思考偏常理，当我们把逻辑推到极致处，就会发现霍布斯的理论无比强大。
在自然法支配下的自然状态只是有可能而不是必然堕入战争状态，所以我们无须忍受现有的任何政府，一旦政府化身为利维坦，对人们的自然权利构成巨大的伤害，那就可以行使革命权，甚至不惜重返自然状态，尽管存在诸多不便，但事在人为，
洛克明显认为社会出于自然，国家则属人为
社会在逻辑与历史两方面都先于国家而生，故应该由社会决定要什么样的国家，而非由国家来决定社会应该是何模样
社会分立于国家，以及社会优先于国家这两项坚持，后来成为自由主义的骨干。
英国人似乎从来都更青睐与国家对应的社会，与国王对应的乡绅，认为这才是秩序和法律的基础所在。
乡绅所执行并理解的法律，还有英国的地方行政，已经让这个国家的日常生活时时处处都依赖于他们，而几乎一点也不依赖于国王，这是一个简单的事实。
对于国王的权力来说，乡绅是不可或缺的，但是对于乡绅来说，国王却是可有可无的。
贬低社会就抬高了国家，因为社会强大了，国家就弱小了，社会变好了，国家就可有可无了。
社会契约论是关于国家起源的一种“哲学解释”，不是对真实历史的客观描述。
因为社会契约论是一种思想实验，思想实验跟科学实验最大的不同在于，思想实验是启发性的、引导式的，它的功能在于帮助我们去澄清一些原本就接受，但出于某些原因隐而未现的观念。
当两个政治哲学理论互相竞争的时候，往往不是因为谁更符合经验事实而获胜，而是因为谁更能改造人们的观念、更能调动起人们的激情而获胜。
自我实现的预期
既然自然状态从未在历史上出现过，而现代国家已经是既成的事实，那么对于我们来说，自然状态就不是过去时而是将来时。
在这个前提下，如果你相信它是“一切人反对一切人”的战争状态，那么你就会为此做各种准备工作；如果你相信它是一个虽然有些不方便，但仍然拥有“和平、友善、互助互保的状态”，你就会为此做另外一些准备工作。在很大程度上，这会是一个自我实现的预期。
为什么需要国家，以及什么样的国家才是合法的？前者问的是国家的必要性，后者问的是国家的合法性。
必须要有国家，而且必须是由绝对的主权者主导的专制主义国家。
国家宁缺毋滥，如果必须建立国家，只有建立在同意基础之上的混合宪政才是合法的。
只要有人被认为独揽一切，握有全部立法和执行的权力，那就不存在裁判者
072 人类的第一桶金是如何赚到的？——洛克的《政府论》（中） 如果你是一个效益主义者或者德性伦理学家，那么你很有可能会支持安妮得到这支笛子，因为这会实现效益最大化，让笛子的潜能真正得到实现，
如果你是一个平等主义者，你就会支持鲍勃的主张，因为这将缩小人与人之间明显的不平等
不管你是马克思主义者，还是自由市场资本主义的支持者，在这个问题上会暂时地站在同一个立场上，因为你们都会认为是卡拉的劳动创造了这根笛子，所以卡拉最有资格得到这根笛子。
90%以上的人毫不犹豫地认为卡拉最有资格得到笛子。
它不仅是混合宪政国家的经典论述，还为私有产权的论证和资本主义的发展奠定了理论基础。
绝大多数人认为卡拉最有资格得到笛子，是因为卡拉为此付出了劳动，劳动创造价值这个观念最早可以追溯到洛克。
洛克会支持私人财富无限累积和存在着巨大贫富差距的社会吗？
在狭义的意义上使用“财产权”，这时候指的就是大地上的果实、土地、不动产等对象
广义意义上使用“财产权”，这时候就把人的生命权和自由权都包括在内。
所谓财产权，最核心的含义就是“未经本人同意不能被夺走”，
这个小婴儿不拥有财产权，因为财产权必须通过“与人的本性（nature）相关的行为才能获得。
任何人都必须通过做某些与他的本性相关的事情，才有可能拥有财产权，具体地说，这些事情就是“劳动”。
占有（possession）和所有（property），占有是一种“事实状态”，所有是一种“法律状态”。
在自然状态中，人们最初是如何从事实上“占有”某物变成法律上“所有”某物的？这个转变到底是如何发生的？换个说法，人类的第一桶金是如何获得的？
最初世界是为人类所共有的，上帝赋予所有人类以理性，让他们为了生活和便利的最大好处而利用这个世界。
人们虽然没有对于外物的所有权，但却拥有对自我的所有权，每个人都排他性地拥有自己的人身。
我们可以把洛克的基本逻辑概括如下： 第一，每个人都有权拥有他自己的人身； 第二，每个人都有权拥有他自己的劳动； 第三，每个人都有权拥有把自己的身体的劳动混入的东西。
如何理解“混入”这个说法？什么样的行为可以被称为劳动？
如果我把自己制作的番茄酱倒入大海之中，那我到底应该拥有大海的多大一部分呢？
某人随身带了100面小旗，每走一公里就插一个小旗，插了100公里，请问，这100公里的土地都属于他了吗？
我的意思是说，当某人在土地上耕作之后，他就不仅拥有了从土地上生长出来的庄稼，还拥有了对这片土地的所有权？
073 马云和比尔·盖茨有权拥有他们的巨大财富吗？——洛克的《政府论》（下） 第一个条款叫作“损坏条款”（Spoilage Proviso），意思是说，上帝把世界赐给人类的目的，不是让人们浪费资源，而是享用资源。</description>
    </item>
    
    <item>
      <title>独裁者手册</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E7%8B%AC%E8%A3%81%E8%80%85%E6%89%8B%E5%86%8C/</link>
      <pubDate>Wed, 28 Sep 2022 10:52:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E7%8B%AC%E8%A3%81%E8%80%85%E6%89%8B%E5%86%8C/</guid>
      <description>布鲁斯·布鲁诺·德·梅斯奎塔 阿拉斯泰尔·史密斯
版权信息 人们有时可以支配他们自己的命运。要是我们受制于人，亲爱的勃鲁托斯，那错处并不在我们的命运，而在我们自己。
为什么民主的美国在别国往往会扶持独裁者而非民选总统？
为什么美国民主党欢迎非法移民却反对给高技术移民提供特别渠道？
为什么越是非民主国家，越容易出内奸？
引言 统治的规则 错处并不在我们的命运，而在我们自己？
政治的世界是受规则支配的。
暴君们为何能长久掌权？为何成功的民主领袖任期这么短？为何那些经济政策误入歧途、拙劣不堪的国家能长久生存？为何那些容易发生自然灾害的国家总是在灾难面前措手不及？以及那些自然资源丰富的国度如何倒让人民忍饥挨饿？
我们被统治与被组织化背后的机理和缘由
毕竟，即使政治不过是领导人玩的一种游戏，如果我们了解了规则，它将成为我们能赢的游戏。
了解事物是其所是的方式和理由，是使其改善的第一步和至关重要的一步。
贝尔的无尽悲歌 那些掌权者与我们不同：他们能设计出有利于自己的规则，使自己更容易达成目的。
首先，政治就是获得和维持政治权力。
其次，确保政治生存的最好方式是只依靠少数人来上位和在位。
第三，当这个同伙小集团明白外面还有大把人排队等着取而代之大吃公家饭，最高领导层就具有了如何花钱、如何征税的巨大自由裁量权。
第四，依靠一个支持者小联盟，领导人可以放手大肆提高税率，正如贝尔市那样。
人们奋起抗争并终结里佐的统治很容易，因为他们拥有至关重要的基本权利：言论自由和集会自由。
顶层发挥效力的东西通常损害了底层，由此我们震惊诧异于有如此多的高层人物犯下了如此多的劣行
凡是在事关政治的地方，意识形态、国籍和文化远没有那么要紧。
在对待政治时，我们必须使自己习惯于思考和谈论具体的、有名有姓的领导人的行为和利益，而不是思考和谈论那些含糊不清的理念如国家利益、共同福祉、普遍福利等。
政治，正如所有的生活，是关于个人的，每个人都致力于去做对自己有利的事，而不是对他人有利的事。
大思想家的困惑 出于对大众的恐惧，霍布斯将君主政体视为通往秩序与良治的自然路径。 第一章 政治的法则 没有哪个领导人是单枪匹马的。
我们必须停止认为独裁者可以为所欲为。
没有哪个皇帝、哪个国王、哪个酋长、哪个暴君、哪个首席执行官、哪个族长能够独自统治。
从词源学来讲，“君主制”（Monarchy）一词也许指的是“一人统治”，但这样的统治方式从来不曾也绝不可能存在。
没有哪个领袖——无论多令人敬畏或尊崇，无论多残忍或邪恶——是孤家寡人。
我们大多数人将国家破产视为财政危机，但透过政治生存这一棱镜我们可以清楚看到，这更是一场政治危机。
对领导人来说，真正的麻烦不在于必须削减公共开支，而在于他丧失了必要的资源去换取核心支持者的政治忠诚。
通过提拔众多新人，路易建立了一个对他感恩的新阶层。
在考虑需要收买谁时，法国大众并不在路易十四的算计当中，因为他们没有对他构成立即的威胁。
只要他们支持他比支持别人更有利可图，这些人就会一直忠诚于他。
路易十四的策略就是把他继承下来的由关键支持者组成的“致胜联盟”替换成他更靠得住的人。
通过扩大进入核心集团的候选人范围，他使那些已经处于核心集团的人的政治生存面临更激烈竞争。
面临扩大了的候选人范围，如果他们不能证明自己足够值得信赖和对国王忠诚，很容易就会被别人取而代之。相应地，他们将丧失通往财富、权力和特权的机会。没什么人会愚蠢到冒这个险。
与所有领导人一样，路易十四与他的核心集团建立起一种共生关系。
没有人能独自统治；没有人具有绝对权威。差别只在于有多少人需要豢养，又有多少资源能够拿出来进行豢养。
政治的三个维度 对领导人而言，政治情势可以被分解为三种人群：名义选择人集团、实际选择人集团和致胜联盟。
名义选择人集团包含了所有在选择领导人时至少具有某些法定发言权的人。
正如每个美国公民肯定都意识到的，虽然拥有选举权很重要，但归根结底，没有哪个个人在谁领导国家上有太多发言权。
名义选择人集团刚刚触及到政治的门槛，仅此而已
第二个政治阶层由实际选择人组成。真正选择领导人的是这个集团。
最重要的集团是第三种，它是实际选择人集团的一个子集，构成了一个致胜联盟。他们的支持对于一个领导人的政治生存至关重要。
在美国，致胜联盟的规模远远大得多。
对路易十四来说，致胜联盟由一小群法官、军官和高级公务员组成，没有他们，路易国王恐怕早被别人取而代之了。
从根本上讲，名义选择人就是领导人的潜在支持者；实际选择人则指那些其对领导人的支持确实有重要影响的人；而致胜联盟只包括那些领导人不可或缺的关键支持者。这三种人可简单概括为：可相互替代者、有影响者以及不可或缺者。
像东北亚的某个国家，有规模巨大的名义选择人集团，每个人都能投票——当然这是个笑话——有规模很小的实际选择人集团，以及一个也许不超过几百人的致胜联盟，但没有这个联盟的话甚至当年他们的第一任领导人都早已灰飞烟灭。
想想你所在的公司吧。谁是你的领导人？谁的支持对他或她来说是不可或缺的？哪些人尽管对你的首席执行官来说并非不可或缺，但在公司治理结构中仍然很有影响？
在所有或大或小组织里的政治运作都是以这三个集团的区分为基础。
在不同国家、不同企业或任何其他组织里，这三种人群的规模差异几乎决定了政治里发生的一切——领导人能做什么，什么事是他们能或不能逃脱追究的，他们必须对谁负责，在他们的领导之下每个人享有的相对生活质量（或者说，常常不享有）。
三维政治的特点 这三个维度支配了世界上所有形形色色的统治体系
“独裁制”这个术语在我们这里的真正意思是，政府建立在极少数不可或缺者的基础上，而他们是从数量非常庞大的可相互替代者以及通常相对较少的一群有影响者当中产生出来的。
当我们提到民主制，我们的真正意思是政府建立在数量庞大的不可或缺者和可相互替代者的基础上；同时，有影响者的数量几乎与可相互替代者一样多。
君主制或军事独裁制，我们的意思是可相互替代者、有影响者、不可或缺者的数量都很少。
以不可或缺者、有影响者和可相互替代者这样的概念来看待各类组织的优点是，这些范畴使我们能克制自己，避免在各种政府形式之间武断地划线，宣称这个国家是“民主国家”，那个国家是“专制国家”
我们必须谨记，像“民主制”或“独裁制”这样的标签是一种方便之物，但也仅是方便之物。
支配统治者的规则 政府收入也能以损害公共福利为代价，被拿去收买一小撮核心党羽的忠诚。
理解政治真正如何运行的第一步是询问领导人都把钱花在哪类政策上。
对任何精明的政治家来说，问题的答案取决于他需要保持多少人的忠诚——也就是致胜联盟里不可或缺者的人数。</description>
    </item>
    
    <item>
      <title>穿透：像社会学家一样思考</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E7%A9%BF%E9%80%8F%E5%83%8F%E7%A4%BE%E4%BC%9A%E5%AD%A6%E5%AE%B6%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 28 Sep 2022 10:52:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E7%A9%BF%E9%80%8F%E5%83%8F%E7%A4%BE%E4%BC%9A%E5%AD%A6%E5%AE%B6%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/</guid>
      <description>严飞
序言 那天下班，他才发现自己的家没了——社会学的想象力 个体若想理解自己的体验，估测自己的命运，就必须将自己定位到所处的时代；他要想知晓自己的生活机会，就必须搞清楚所有与自己境遇相同的个体的生活机会。”
我们必须理解那股力量；并且在有可能的情况下，参与行动，改变那些要比我们个体庞大得多的东西。
重点在于我们凭什么指认这是社会的问题？什么叫做“社会”？又该如何解释一个人的具体处境，与社会结构和历史力量之间的关系？
社会进化论： 为什么达尔文的进化论可以解释社会？ 我们从进入学校的第一天起，似乎就开始进入到一个不断竞争的环境中。
整个社会，就好像是一列高速前行的列车，火车司机不断踩下油门，轰鸣地一路往前，生怕落后一点，就会被别人超车。
在社会学中，社会进化论是一种主流的社会学理论吗？
适者生存”（Survival of the Fittest）
在没有限制的条件下，人口以几何数列增长，生活资料以算术数列增长，其结果必然引起灾难和战争。只有通过优胜劣汰的方式，譬如战争、瘟疫、穷人不得结婚等方式，才能抑制人口增长，实现人口和生活资料的均衡。
社会进化论。
由简单到复杂，我们可以观察到人类社会是由最简单的部落形式，逐步发展到复杂多元的国家形态；由不确定到确定，我们可以看到人们最早是受到习俗、礼仪的约束，那这样的约束因为没有强制效应，所以具有很大的不确定性，后来习俗发展成法律，各种行为准则就在法律框架的约束之下，变得更加明确；由同质到异质，一个最好的例子就是从传统农村走向现代都市的发展，在乡土社会中，由于大家都是从事相同的农业生产，再加上人口流动小，所以家家户户的同质性很高。
人和人之间的差异性也相应增加，这就是一种异质性的体现。
斯宾塞将社会类比为有机体，
生物有机体是靠皮肤维系起来的，而社会有机体是通过语言媒介保持团结的。
动物的各部分形成实在的整体，社会的各部分构筑成抽象的整体
社会有机体能通过另一方法保持合作，社会成员不用接触就能通过情感语言和口头或者书面语言超越空间而保持合作，这就是说语言具有身体刺激所没有的媒介功能。
在斯宾塞看来，政府的活动应该加以限制，越少干预人民的事务越好，一切让之自然发展，自然就会理出一条最好的解决之道。政府越是出台一些新的政策，干涉人民的生活越多，就越会将社会弄得一团糟糕，鸡飞狗跳，民怨载道。
但从长期总体方向看来，社会进化总是向前进展的，社会在向一个建立在友爱、利他主义、专业化而看重个人成就的未来社会迈进。
除了宣扬“进化论”外，严复对赫胥黎的原著加以改造和评论，更主要的是加入了斯宾塞的社会达尔文主义。
我们后面提到的涂尔干，就提出社会进步的动力，是在社会整合基础之上的有机团结；
韦伯则指出理性和价值是指引社会发展，促进社会进步的源动力；滕尼斯则强调我们的社会，是一个大的共同体，人们以和平的方式相互共处。
第二章 金钱是我们时代的上帝 如果没有喜悦和满足，那获得的又是什么？
但事实上在我们社会学领域，特别是在古典社会学领域，马克思和法国社会学家涂尔干、德国社会学家韦伯一起并称为社会学的三巨头。
马克思为我们提供了一种认识世界、解释世界的基本方法和框架，这样的方法首先就是从社会出发的。
社会是人们交往方式的产物。有什么样的社会交往方式，有什么样的人和人之间的互动方式，就会有相对应的经济交换方式、生产方式、生产资料的再分配方式。
最适合马克思的还是社会学家。
在马克思看来，劳动是人类的本质活动。劳动应该是一种有着主观能动性和自我意识的活动。人因为劳动而更富有创造力。人是通过劳动才可以不断地去改造世界、建造世界的。
他认为在劳动的过程中，人的本性是一种自由、自觉的活动，用通俗的话说就是人会自觉自愿地进行劳动，并没有受到别人的强迫。
当劳动成果展现在我们面前时，人可以获得极大的喜悦和满足。
到了工业化的时代，工人们在现代的大型工厂里就失去了自主性，变得越来越厌恶劳动但是又不得不劳动。
什么是异化呢？
异化是人类自己创造的力量，作为外部力量又反过来支配人类。
异化就是人们自己创造出来的东西，成了不受自己控制的一种外在力量，反过来又来统治人。这种力量不断地支配人类，从而导致人和人之间除了赤裸裸的利害关系、冷酷无情的现金交易，就再也没有任何别的联系了。
第一，异化首先是发生在劳动者与其劳动产品之间，或者是说工人与其创造出来的劳动产品之间的一种异化。
在劳动的生产过程中，工作不再是由工人自己决定，因为生产工具是被垄断在工厂主或者是说雇主手上，因此工人的工作就变成了与个人生活相脱节，但是为了生存，工人又没有办法和工作相分割开来。于是，工人的劳动就失去了原本的一种自主性，就变成必须依附在工厂里，必须依附在生产车间之上才能进行的生产劳动。人就成了工厂和生产车间这些机器的附属品，而机器成了主体。
劳动者与其劳动产品之间产生了异化。
第二，不仅劳动者和他的劳动产品之间发生了异化，就连整个劳动过程本身也发生了异化。
劳动对工人来说是一种外在于他的东西，是不属于他的东西，工人们根本不知道自己在做什么，也不知道自己在生产整个过程当中究竟处于什么样的角色和地位。
在整个劳动的过程当中，工人们并没有感到幸福，而是感到不幸，不是在肯定自己，而是在不断地否定自己，也不是自由地在发挥自己的智力和体力，而是不断地使自己的肉体受到折磨，精神受到摧残。
这种劳动满足的不再是人们的劳动需要，劳动成了工人们迫不得已的生存手段，一方面痛恨无休无止的劳动，但另一方面又不得不参与劳动，
第三，在整个劳动的生产过程当中，人和人之间也发生了异化
本来相亲相爱的工友之间，在整个劳动的过程当中变成了最熟悉的陌生人，工友和工友之间，正式工和临时工之间，早班工人和晚班工人之间，更多的是彼此之间不断竞争的一种关系，比较谁生产出来的劳动产品更加的多，谁更可以讨上级的欢心。
劳动从人的一种自觉自愿的本性变成了对人的一种折磨，劳动伙伴之间的合作关系变成一种折磨的关系和状态，这就是马克思所提出来的第三种异化。
那我们在今天又应该以怎样的眼光看待异化？随着社会变得越来越复杂，异化的程度到底是减轻了还是加重了？
所谓异化实际上就是我们所创造出来的东西，反过来又统治着我们、束缚着我们的生活。
我们有多少人是真正为自己而活着的？我们的人生是否真的可以自己说了算，可以自己做主呢？
为了指标、业绩、利润的增长，大家都在拼命地工作，同事和同事之间也挤破了头，在办公室政治中钩心斗角。但是有多少人是真正因为喜欢和热爱这份工作而去投入其间的呢？
我们根本没有办法做到真正的身心放松和自由，回想起来还真不一定知道自己这一天里面到底做了什么，或者是说这样做的意义和价值何在。这就是我们被异化的生活。
我们是否值得过上更好的生活？那种可以不被工具或者目的所主宰，不被上级和领导所驱使，有自由选择人生、决定人生权利的生活？
使用价值与交换价值： 知识是一种可以买卖的商品吗？ 在马克思看来，工人劳动制造出来的物品，有着内在的“使用价值”。这个内在的使用价值指的是一个物品的可用性，越有用的东西就有越高的“使用价值”。
使用价值”是内在于物品本身，而不是依靠市场的供求关系决定的。
如果想把物品进行交易，就得创造出另一种价值作为交易中介，这就催生了“交换价值”。
“交换价值”是出现了盈余和匮乏之间的失衡，才有了交换的需要。
价格来自交易，也只存在于物与物之间的交易关系中，并不等同于“使用价值”。
知识价值是知识对于人类社会的存在和发展，以及丰富个体精神生活所具有的价值。随着人类社会的发展，人们的精神需求也日益丰富，人们对知识的追求，是人类精神需求的重要方面。
在什么情况下你才会拿100元的面包去换100元的网络课程呢？一定是在你心目中，网络课程的使用价值高过了面包的使用价值，你需要这门课程的程度超过了面包，你才会拿面包去换这门网络课程。
交易实现“使用价值”。
经济活动越频繁，就增添越多整体的“使用价值”。
经济决定论： 婚姻里真的是谁收入高，谁就更有话语权吗？ 经济基础与上层建筑的关系，经济代表的是物质的基础，上层建筑代表的是精神层面的东西。</description>
    </item>
    
    <item>
      <title>中国近代史（下册）</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E4%B8%8B%E5%86%8C/</link>
      <pubDate>Wed, 28 Sep 2022 10:10:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E4%B8%8B%E5%86%8C/</guid>
      <description>徐中约
第二十三章 国民政府：挑战重重的十年1928-1937年 在一个病态的社会里，个人的努力都是徒劳无益的，只有联合的行动才能改善穷人的生活。 第二十四章 中日战争1937-1945年 这是一种日本式的『门罗宣言』（Monroe Doctrine），显示了日本人由来已久的统治亚洲的渴望。
从一开始，共产党就把它看作是一种纯粹为了执行共产国际的指示、避免国民党的进攻并在抗战期间积蓄力量的手段而已。为了不使党内的任何成员误解这些秘密的目标，毛泽东告诫干部要充分利用抗日战争的时机壮大自身。他说：『我们确定的政策应当是百分之七十作扩张，百分之二十对付国民党，百分之十抗日。』干部们被要求根据这个原则相机行事，即使在与党中央失去联络时也应如此。
既然要充分利用统一战线，毛泽东便设计了一套分三步走的策略：第一步，与国民党妥协以求保护中共的存在；第二步，与国民党分庭抗礼；第三步，向华中渗透，建立一个新的根据地以便发起反攻，夺取国家的最高权力。
延安道路的核心是完善群众路线和在农村加强革命的民族主义，这成为毛泽东思想的两大支柱。
他还阐述了『三三制』，该项制度将参加边区政府和参议会的中共党员限制到三分之一，将其余三分之二的席位让给左派进步分子和中间分子及其它人士。至少在表面上，统一战线政策给边区一种民主的色彩。
这样，在政治、经济、战争和革命各方面开展的群众路线方法，在领导人和人民之间锻造了一条紧密的纽带，成为延安经验的核心。
1938年他曾几乎没有间断地工作九天九夜写就了《论持久战》一文，当脱稿时他已筋疲力尽。
在大约两年的时间里，他撰写的论著有200页是关于战略方面，165页关于政治，55页关于哲学。[5
1949年7月他写了另一部重要的著作：《论人民民主专政》。
1936年7月，斯诺（Edgar Snow）冲破国民党的新闻封锁进入共区。
斯诺批驳了所谓中共不过是从属于莫斯科之傀儡的看法，断言中国人已发展了一种独一无二的、土生土长的共产主义。
在这部书中，斯诺把共产党人描述成俭朴的爱国者，而国民党人则是腐败的不可信赖者。
大多数外国记者都怀有对国民党反感和对中共倾心的感觉，只有一个天主教神甫比较明显地例外。
前者代表着『旧中国』——死气沉沉、颓废衰微、自私自利、逆来顺受、对普通百姓漠不关心、贫穷落后、不讲人道，任人唯亲，而后者则代表[新中国』——满怀希望、朝气蓬勃、效率卓著、斗志昂扬、纲纪严明、热情洋溢。
他报告说中共是在第二次世界大战影响下中国境内最有活力的力量，建议华盛顿应利用中共来平衡苏联在中国和东亚的影响。
他得出结论说『他们是一些出色的游击战士，但就大规模作战而言……他们决无能力与强大的日军硬碰硬地较量并打正规战。
毫无疑问，日本与美国市场的关系，直接和间接地支持了它在中国的战争行动。
袭击珍珠港改变了中国战争的性质，也改变了外来援助的结构。
盟军黯然失色的表现与中国的长期抗战形成了鲜明的对照，中国的抗战现在赢得了西方新的尊重。
战争对中国、日本和东亚产生了深远的影响。
中国通过长期的反侵略斗争，取代了日本的主导国家地位，从战前的半殖民地状态一跃而为五大国之一及联合国的创始国，拥有了安理会常任理事国席位和一票否决权。
始于十六世纪的欧洲在亚洲之殖民主义时代终于走到了尽头。
美国凭借其在打败日本中发挥的主导作用，崛起为最强大的太平洋国家。
在1945年战争结束时，230万日本的海外派遣军中有120万被钉在了中国。
在交战中首当其冲的国民政府在物质上和精神上的消耗非常惨重，导致无力应付战后时代新的挑战。
通货膨胀最终损害了军队的士气，打击了行政效率，破坏了平民的生活，并使中产阶级沦为贫民。
尽管通货膨胀是维持战争的一个必不可少的弊病，但它在战后时期便成了一种祸根，损毁了政府根本的经济基础。
内战的阴霾再一次不祥地笼罩了神州大地，令这个筋疲力尽的民族之未来继续充满了动荡。
第二十五章 内战1945-1949年 然而更可怕的是东北的局势，苏联军队已深入到那里的腹地，并拒绝随日本的投降而停止推进。
在日军投降后的两星期之内，中共的地盘从116个县扩展到了175个县。
为压倒中共的地理优势，蒋请求美国支助，将部队空运和海运至沦陷区。
8月15日，蒋亲自命令冈村宁次在沦陷区内维持秩序及控制所有军事装备。8月22日，冈村进一步受命只允许政府军队进驻沦陷区。这位日本司令官完全服从了这些指令。
苏军深深渗入至热河和察哈尔腹地，以便帮助中共部队进军东北。苏联人将相当数量投降日军的武器交给了中共军队。然而，苏军并没有让中国共产党接管东北。
1945年8月28日，毛泽东飞赴重庆。充满盼望和感到困倦的中国人民，全神贯注于这次历史性的会谈，期盼会谈达成一个和解的结局，从而可以避免一场内战。
蒋除了拥有对其敌手的巨大军事优势[62]外，还得到了美国的援助和支持，并与史太林签订了一项友好同盟条约。蒋对毛泽东此刻愿意达成的某种和平『临时协议』毫无兴趣。
苏军洗劫了东北的工业厂矿，将价值二十亿美元的设备当作『战利品』运往俄国。[65]他们采用了各种各样的借口，以阻挠国民政府部队进驻东北。
蒋否决了这项建议，把最精锐的近五十万部队投入东北——他日后将为这个决定而后悔不已。
其目的是期待一个『强大、统一和民主的中国』之出现
中国共产主义是一场经历了三十年之久、有着巨大生命力的内部力量，外国的干涉不太可能改变它的方向。
当美国国内已确定了部队复员和回复正常生活秩序之时，美国军人能在中国驻守多久？
华府觉得共产主义中国的兴起虽然不合意但还能容忍，因为中国人不会对美国的安全在几年或甚至几十年内构成威胁。调停的失败使美国人别无选择，只得接受中国局势的现实。
由于欧洲是战后全球关注的核心，美国人便想到用最低限度的资源投入来达到他们在东亚的目标。这样一种政策要求与该地区的一个大国结成坚强的同盟。
他倾向于将复兴的日本看作是美国中意的选择对象——如果证明中国不能充任它在美国战略中指定的角色的话。如果中国能够符合他们的设想，就值得美国予以支持；如果不符合，一个复兴的日本也可以充当美国在东亚利益的支撑者。
美国的长期目标，是鼓励发展一个有能力抗衡苏联，并对美国资本渗透开放的相对强大而友好的中国。
无论是一个共产党统治的中国，还是一个将招致俄国渗透的虚弱的中国，都不能完成这些目标。
国民政府倒台的最重要的近因是八年抗战，这场战争在军事上、财政上和精神上彻底消耗了国民政府的元气。如果没有抗日战争的话，中国的局势也许就完全不同了。
国民政府赢取抗战胜利所付出的代价，也是导致最终垮台的首个原因。
这支军队在抗战最后阶段已经显示出了疲倦的迹象，只是靠着民族主义、爱国主义和对盟军即将胜利的憧憬勉力支撑着。
相反，共产党却在抗战期间大大扩充了军事力量。
通货膨胀和财政失措毁坏了千百万中国人的生计，并彻底破坏了政府的信誉。人民大众不仅反对国民政府统治，甚至还期盼改朝换代，这是不足为怪的。
他们以征服者的姿态回来，轻蔑地对待沦陷区的民众，好像民众都曾是汉奸和叛徒似的。
沦陷区的人民等待了八年，盼望国民政府统治的重返，但却遭遇了这样残酷的压榨和轻蔑的对待，以至于他们困惑地想象，在日本人统治之下生活，是不是还要更好一些。
首先，如果在战争头四年即1937-1941年间美国对华援助的力度更大一些的话，或可使国民政府的财政加强到在较早时期就遏制住通货膨胀的地步。
其次，如果美国坚持那项通过中国大陆打击日本的初始战略，美国士兵将在中国的沿海省份登陆，从日军那里抢夺领土，再将收复的领土交给国民政府。
国民政府不理解农民，看不到解决农民困苦的紧迫性，对农民的疾苦也就漠不关心。讽刺的是，国民政府官员继续生活在儒家关于劳心者与劳力者之区别学说的阴影下，将农民鄙视为毫无生气、无足轻重的人，所以看不到农民大众的革命能力，因而也从未尝试去组织他们。恰恰就在这个被忽视的区域，毛泽东的天才得到了最高度、最成功的发挥。一块造屋者抛弃的石头变成了另一个人的房屋之柱石。
第二十六章 中华人民共和国：第一个十年 大星象征中国共产党的领导，四颗小星则代表工人、农民、小资产阶级和民族资产阶级四个阶级的联盟。1
一天后得到了苏联的承认，其它一些共产主义国家也很快地相继表示承认。[80]承认新中国的非共产国家有印度、缅甸、巴基斯坦、锡兰、英国和法国。
1949年的《组织法草案），非常明确地规定了中华人民共和国不是像苏联那样的『无产阶级专政』，而是一种由中共领导的、以四个阶级联盟为基础的『人民民主专政』。四</description>
    </item>
    
    <item>
      <title>中国近代史（上册）</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E4%B8%8A%E5%86%8C/</link>
      <pubDate>Wed, 28 Sep 2022 10:10:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E4%B8%8A%E5%86%8C/</guid>
      <description>徐中约
出版者言 可是近半个世纪以来，因为中国政治动荡，以中文撰写一册公正不阿的近代史著述实在困难。 郭序 中华民族猛然醒觉，愤而寻找重生的道途。
过去二三百年西方文化影响整个世界，替世界历史定位。
徐中约教授在1970年首版的The Rise of modern China，成为一本极具深远影响的经典力作。
在1970年问世，次年获得美国加州之[共和奖]（Commonwealth Prize）。此后每五、六年有一新版，2000年第六版完成。自1976年起，此书的国际版开始广泛地在东南亚洲流行，成为一本研究近代中国必读的史书。1978年牛津大学出版社纪念五百周年（1478-1978）发表之文告，列举数十名著，徐著为其中之一。
原著者中文版序 纵观四百年来的中国近代史，其最大特征即为中西文化之冲击、适应、及和平共存。
汉唐元清盛世，国人向以为荣，但该时之天下，只是指以中国为中心的东亚而已！二十一世纪之中国，具有庞大潜力，足以推进中国更上层楼，今日中国以科学和教育改革提升人名素质，并同时推动工业、科技、及资讯等三方面革命，到二十一世纪三十年代至五十年代，此三大革命大致可望完成，届时中国亦可成为一个世界超级大国。
第六版序 探寻一条在新的世界中体面地生存下去的道路，是推动近代中国发展的一个主要动力。
一个世纪以来，中国内部的腐败和外来帝国主义的羞辱性掠夺，如同一对孪生恶魔，给它带来了长时期的衰落。
1998年6月17日，美国的三位前总统和二十四位前高级官员在一封致国会的信中称：[中国注定要在二十一世纪中成为一个伟大的经济和政治强国。]中国在新的世界中如何行动，将对全世界产生关键性影响。
美国与中国的关系将制约未来的半个世纪。
从文化的意义上来说，中国可以被看作是中华文明的继承者，而美国则是西方文明的现代化身。
只要双方和平共处、容忍差异、增进协调和谅解，就会出现一个史无前例的和平昌盛的新纪元。在太平洋两岸都需要有睿智贤明的治国之道。
第一版序 萧一山的巨著《清代通史》 第一章 『近代中国』的概念 在近代以前，中华文明基本上是土生土长地自行发展的，这一方面是由于中国人的独立精神，另一方面也是由于中国孤立于其它一些重大的文明之外。
1839-1842年的鸦片战争看作近代中国的起点。
这场战争标志着外国帝国主义侵入中国的起点，此后的中国历史便主要是一部帝国主义侵华的历史。
这场战争意味着外国在华活动的加剧，这些活动打破了中国的孤立局面，并在中国开创一个革命性变化的时代。
这场战争是资本主义和帝国主义之凶恶的缩影，它把『半封建』的中国拖入了『半殖民地』的深渊。
从影响方面来看，十九世纪西方的冲击在促使传统中国向近代中国转型上所起的作用，肯定比十六、十七世纪欧洲探险家和传教士到来所起的作用更为巨大。
西方海权国家从南面向上推进，而陆上大国俄罗斯则从北面向下挺进，它们形成了一种钳形势态，目标直指中国的心脏北京。
其政体是一个由皇室统治的王朝；经济基本上是自给自足的小农经济；社会以士绅阶层为核心；支配性的意识形态是儒家学说。
在十九世纪之前的二千多年里，中华文明和西方文明的主流是朝着相互分离的方向发展的。
只有当其中的一个文明获得了足够的力量和技术、并为着自身的利益扩张到另一个文明地区时，这两个文明才得以会合。
很明显，中国历史与西方历史的交会不可能发生在地理大发现时代之前，而这两个文明的直接碰撞也不可能发生在工业革命以前。
首先，自然是政府的政策和制度，它们在很大程度上决定了国家命运的兴衰。
朝廷最为关注的，是如何维持其自身的权力。
所有这些以及其它许多政策措施，都旨在确保大清江山的长治久安。
到了1949年以后的共产党执政时期，我们则看到了一种企求实现社会主义改造、迅速实行工业化和争取大国地位的强烈动力。
确实，在清朝这样一种不允许有任何合法反对派政治团体存在的专制制度中，秘密活动不时地对历史的开展起着非常重要的作用。
欧洲殖民列强在二十世纪头二十年成为中国革命的主要对象；三十年代和四十年代前半期的主要对象是日本，五十年代后期起则是俄国——应予注意的是，中国国民党和中国共产党同样强烈地憎恨俄国。
在整个近代中国三百多年的时期内，反对外来因素的民族或种族抗争，构成了一个清晰的历史主题，它时而浮现到表面，时而转入地下。
近代中国的历史可被视为一部民族主义革命的历史。
第三种动力是在新的天地里寻求一条求生之道，
它加速了旧秩序的瓦解，却没有提供替代它的新秩序，这给中国人留下了在旧秩序废墟上构建一个新秩序的艰巨任务。中国人背负着传统的重负，对西方世界的本质又一无所知，他们在黑暗中摸索，探求一条适应时代巨变的生存之路。著
为了使中国得以继续存在，并在国际社会中赢得一席之地，旧中国的多少成分应予抛弃，近代西方的多少东西应予采纳。
对一种新秩序的探求涉及一场极其艰难的观念之争，需要排除那种过度的自尊意识和对外来事物的藐视之情，抛开那种认为富庶的中华上国毋需借鉴化外蛮夷、也毋需与彼等结交的根深蒂固的信念。
他认为靠一次不全面的改良来医治中国的病痛是无济于事的，只有通过一场彻底的革命才能解决问题。
他在社会的边缘区域开展活动，赢得了秘密会社、下层阶级和海外华侨的支持，但却没有得到士大夫阶层的拥护，他们普遍地追随着康有为和梁启超。
亥革命成功之后的第二年，一个西方式的共和国建立了，在四千年的中国历史上，第一次废除了由帝王统治的王朝。
政府改头换面了，但它的精神实质还与过去一样；贪污腐败、军阀割据、恢复帝制的妄想和混乱失控的情况比比皆是。
如果不进行一场彻底的思想变革，就不可能有良好的政府和进步的社会。
杜威的那套信奉以渐进手段进行社会改良的实用主义哲学，由他的弟子胡适介绍过来；而崇尚革命手段的马克思主义思想则在布尔什维克革命的影响下，由陈独秀和李大钊等人大力宣传。
首先是影响器物的技术；而后是关于国家和社会的原理；最后则是触及精神生活核心的观念。同治朝的自强运动、1898年的维新变法和1919年的五四运动各自标志了这三个阶段的思潮要点。
现代中国的主题是国民党与共产党之间争夺国家最高权力的斗争。
中共军队进行了史诗般的二万五千里（实为6000英里，合9000公里或18000里）长征，到达西北地区，在那里再次站稳了脚跟。
这两类人是买办和军阀，他们代表着新的财富和新的权力。
个人起来坚持自己作为国家的成员而非作为家族的成员之地位时，宗族社会便瓦解了。
而所有变革中最激烈的变化，也许是农民从一种惰性的实体转化为一种积极型的国家成员。
变化的动态表明，近代中国历史的特征并非是一种对西方的被动反应，而是一场中国人应付内外挑战的主动奋斗，力图更新并改造国家，使之从一个落后的儒家普世帝国，转变为一个在国际大家庭中拥有正当席位的近代民族国家。
中国近代史的这四个时期据称构成了『旧民主主义革命时代』，与之相对的是从1919年到1949年之间的中国现代史时期，它构成了『新民主主义革命时代』。
编写中国近代史应做到既反映中国学界的见解，也反映外国学者能够从外部进行观察而得出的那种客观性——鉴于中国与西方交往的密切，这种做法即使并非绝对必要，也至少是大合时宜的。这样的综合可望对近代中国获得一种准确的历史透视。
第十章 太平天国革命、捻军叛乱及回民叛乱 其兴起蓬勃激昂，而其衰亡亦哀婉可悲。
他们的宗教理念既背弃了中国人，也背弃了西洋人。
当他将革命从属于宗教之时，他玷污了自己作为一个民族主义革命家的形象，使自己沦落到白莲教起义者那样的『教匪』档次。</description>
    </item>
    
    <item>
      <title>邓小平时代香港版</title>
      <link>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E9%A6%99%E6%B8%AF%E7%89%88/</link>
      <pubDate>Wed, 28 Sep 2022 10:10:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E4%B8%AD%E5%9B%BD/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3%E9%A6%99%E6%B8%AF%E7%89%88/</guid>
      <description>傅高义
导 言 这个人和他的使命 政治体系控制到每家每户的做法搞过了头，造成了恐惧和主动精神的丧失；对经济体系的控制也搞过了头，导致的是失去活力的僵化。中国的领导人究竟怎样才能做到既维持国家稳定，又为社会松绑？
邓小平在1978年时已74岁，
在长征结束前，邓小平有幸成为毛泽东信任的人。
有人认为他独断专行，不尊重别人的意见。知识分子对他在1957年反右运动中压制大胆敢言的人很反感。有人认为他过於急躁，太想冲在前面，太想强调纪律。就像任何出色的军人一样，他希望下属有令必行。他欢迎别人提出能够解决问题的建议性意见，但是外国人和政治异见人士对党的批评则会让他勃然大怒。
到邓小平1904年出生时
毛泽东是个魅力十足、有远见和智慧的杰出战略家，也是一个精明狡猾的权谋家。
毛泽东原本有机会给中国带来富强，然而他却把国家拖入了想入非非的乌托邦，导致严重的食品短缺，致使数以百万计的民众非正常死亡。
第5章 在毛时代终结时靠边站：1976 先是康生，秘密警察头子，专替毛泽东做见不得人的事，在他布置下有数百名被控背叛革命的干部遇害；
他於1975年12月去世。接着是总理周恩来，他死於1976年1月8日凌晨。然後是朱德，红军缔造者，早期军队领袖；他死於1976年7月。1976年9月，高居万民之上的毛主席撒手人寰。
一个被奉若神明的革命家只手就能撼动整个国家的时代结束了。
他试图借机抑制群众对周的怀念，对周一生的成就只给予了以党的标准而论尽可能低的评价。
可是毛这些手段的效果适得其反。很多中国人非但不服气，反而为深得他们敬仰与爱戴的周恩来没有得到应有的评价而愤愤不平。
他确实给周恩来送了一个花圈，但除此之外没有参加任何追悼活动。
在群众的眼中，周恩来自1973年以来一直受到不公正的对待。民众自发流露的哀痛，堪与1945年罗斯福去世或1963年甘乃迪遇刺在美国引起的反应相比。
一些在文革中受过迫害的领导人，对周恩来如此心甘情愿地与毛泽东合作深感不满；但是在群众眼里，是周恩来使他们躲过了毛泽东的极端做法。
半个世纪以来，邓小平的生活与周恩来难分难解，两人都在毛手下兢兢业业干了几十年，也都在毛手下受过罪。
在那里，工人将骨灰送上一架飞机，从空中撒向他奉献了一生的中国大地。
他不想单独听邓小平说什麽，因为邓小平很容易事後不认账。
华在文革前就是高干，因此那些刚恢复工作的老干部容易接受他。「四人帮」也接受他，因为他们乐观地以为此人性格温顺，易於操纵。
华国锋属於那种邓小平考虑提拔下级干部时也会寻找的人：他是一步一步被提拔起来、能够解决问题的实干家。
华最初的任务之一是领导反击「右倾翻案风」运动，即批判邓小平为许多老干部恢复工作的做法。
毛泽东不想冒任何风险，让受到批判的邓小平和叶帅有可能与军队领导人联手跟他作对。
但北京的干部明白，毛泽东仍希望邓小平回心转意，这是在给他机会。[插图]然而邓小平没有任何软化立场的表示。
当年当过红卫兵的人愤怒了，把他们过去在批判江青的对手时学到的本领反过来用在了江青身上。
3月26日，南京爆发示威活动的次日，邓小平被叫到政治局扩大会议上，被批判为名声扫地的党内资产阶级的头子，并被谴责要抢班夺权、另立中央、最终复辟资本主义。
这次人民悼念周恩来的活动，比我见过的任何国家葬礼都要感人。这种政治示威与我在中国见过的任何事情大相迳庭。⋯⋯大批人群的行动是发自於信念⋯⋯表达着多年来暗流涌动的思想感情。这是⋯⋯对周恩来去世後所受待遇的愤怒，是反抗毛泽东的精神，是对中国未来的忧虑，是对那些肯定会惩罚示威者的人的蔑视。⋯⋯人民收回了给毛的授权。
王洪文向政治局传达了毛泽东要调动10万民兵镇压示威群众的命令。但是负责民兵工作的倪志福说，顶多可以调动3万民兵，吴德也补充说，这麽多民兵对付不了广场上的大批抗议群众。
没有证据表明毛泽东本人认为邓小平是组织示威的幕後黑手（如公开宣布的那样），但他确实认为，假如邓小平继续掌权，将会把党带上一条错误的道路。[插图]当天晚上，江青也与毛泽东见面，再次要求把邓小平开除出党，但毛泽东仍然没有同意。
对毛泽东来说，4月5日天安门广场上发生的事情是「十分令人沮丧的。⋯⋯以往他总是站在天安门城楼上接受民众的山呼『万岁』，而如今竟成为人们声讨的对象，⋯⋯﹝他﹞身後恐怕也难逃历史的清算。⋯⋯毛泽东内心的沮丧和恐惧的心情可想而知」。
至少在民众政治觉悟最高的北京，毛泽东已经失去民心，周恩来才是百姓心目中的英雄，邓小平也有足够的民意支持成为主要领导人。
对邓小平要「保留党籍，以观後效」。
只要毛泽东一张口，结果从来不会有任何意外。
毛泽东允许邓小平保留党籍，给他留下了重新报效国家的可能，只是现在还为时尚早。
「慢慢来，不要着急，照过去方针办，你办事，我放心。
毛的判断是，华国锋会一直忠实於他和他的路线，他这个判断是正确的。但是他希望华国锋能够团结激进派和老干部的想法却未能如愿。
毛泽东不仅保护邓小平，允许他留在党内，还为他提供了一些特殊的关照。
即使在弥留之际，毛泽东也没有完全放弃邓小平。
如同帝制时代一样，有人认为这场灾难是上天对统治者不满的徵兆。
华国锋想跟「四人帮」搞好关系，可是他们却要唱自己的戏。大体而言，他们是激进派的宣传家，华国锋则是解决问题的实干家。此外，华国锋的晋升也使「四人帮」有理由把他视为劲敌。
高层干部因为他早年取得的成就仍然尊重他，但是他们也在考虑还要在多大程度上服从他。他已经不再能把自己的威名变为实权，像1958年或1966年至1967年那样动员全国了。
其实「四人帮」本是一个以毛主席为首的「五人帮」。
叶帅担心可能有人窃听，便展开右手的四个指头，并把拇指弯向掌心，他的意思是，等毛泽东撒手人寰之後再说吧。
尽管华国锋在4月7日担任了更高的职务，他并没有获得对军队的控制权，这使他不能像邓小平那样行使权力。
上面的决策仍然悬而未决，下面的官僚系统则每日每天继续运行着，尽管缺少大方向；同时不安地等待着毛泽东之後新的权力格局的出现。
并於9月9日零时10分去世。
毛泽东的去世让举国陷入受政府引导的悲痛之中。这是一个领导了中共40年、领导了国家27年的传奇人物；政治上一无所知的普通群众一向接受着热爱毛主席的教育，为他们顶礼膜拜的领袖的去世而落泪，表达着他们的崇敬之情。
毛泽东去世後，她曾骄傲地宣布自己是毛泽东最忠实的一条狗。也许她还应当在「狗」前面加上「会咬人的」，这更能说明她的特长：她在肆无忌惮地毁灭毛认定的打击目标这一点上无人能比。
作为毛泽东最坏的一面的化身，她很容易在中国为千夫所指。
但毛泽东仍然喜欢她的忠诚，关心她的生活，对她加以保护，以备自己的不时之需。
江青从未培养出政治眼光、组织才能或与其他掌权者积极合作的能力，而这都是真正的权力角逐者不可或缺的品质。
江青知道，最能帮上她的就是找到、甚或是修改一些毛的文件，以使她确保更多的权力，并由她来阐释毛的遗志。
任何逮捕「四人帮」的决定，都需要华国锋代主席的果敢领导，和中央军委副主席叶帅及时任中央警卫团（负责保卫党中央）负责人汪东兴的配合。一切都要面对面地商量，而且要行动迅速。
汪东兴从他可以信赖的警卫团中逐个挑选了一小批可靠的人。
它为华国锋提供了阐释毛泽东遗志的重要机会。
「四人帮」被捕两天後，上海的余党因为与他们联系不上怀疑出了麻烦，开始为武力反抗作准备。
但是，对於是否应当逮捕「四人帮」，甚至对於毛泽东是否真心选择华国锋做接班人，党内是有怀疑的。毛泽东事实上从未公开批评过江青，人们先前也从未听说过「四人帮」一词。
华国锋与「四人帮」的斗争後来被一再说成善恶之间的伟大斗争，是追求正确路线的党与「四人帮」反党集团的斗争。就像中国历史文献中记录的很多故事一样，这其实属於成王败寇的老生常谈。不过，这一次就像1949年一样，获胜者确实得到了真诚而普遍的拥护。
华国锋还没准备好让邓小平回来。邓太有经验、太自信，也随时能够掌控大局。叶帅也认为，华国锋需要时间巩固自己的领导地位，还是让邓小平晚一点回来为好。临近1976年年底时，叶剑英元帅和李先念等老干部才提议恢复邓小平的工作。
而实际情况是，华国锋为了巩固自己的地位，又拖了半年才让邓小平恢复工作。
当儒家思想丧失活力时，它虽然仍被供奉於庙堂之上受到人们祭拜，但是它已经和人们的日常生活失去了联系。同样，毛泽东去世和「四人帮」被捕之後，毛仍被供奉在神坛上，到天安门广场中心的毛主席纪念堂参观的人仍然络绎不绝，但是他的激进思想、他的群众运动和阶级斗争，已经不再是中国人日常生活的内容了。
後来的审判「四人帮」成了一次全民观赏的庙堂祭典，这次审判中对毛泽东激进思想的谴责没有针对毛，而是被转嫁给了「四人帮」。
「四人帮」的覆灭标志着一个时代的结束，一种想通过不断革命和阶级斗争去改造世界的希望的破灭。
第6章 在华国锋时期复出：1977–1978 华国锋是个「耳聪目明却平淡无奇的人，他的突出特点是谨慎。他对材料掌握得还算充分，但没有表现出丝毫超常的智慧或魅力。华看起来是一个理想的过渡人物，在内政外交领域都不太可能采取不同寻常的举措。⋯⋯我怀疑华缺乏长期主政必不可少的眼光和领导能力，⋯⋯我认为将会出现更有能力的新领导人，⋯⋯单调乏味的华国锋先生在完成他的历史使命之後，将被迫靠边站」。</description>
    </item>
    
    <item>
      <title>苏联的心灵：共产主义时代的俄国文化</title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E8%8B%8F%E8%81%94%E7%9A%84%E5%BF%83%E7%81%B5%E5%85%B1%E4%BA%A7%E4%B8%BB%E4%B9%89%E6%97%B6%E4%BB%A3%E7%9A%84%E4%BF%84%E5%9B%BD%E6%96%87%E5%8C%96/</link>
      <pubDate>Wed, 28 Sep 2022 10:02:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E8%8B%8F%E8%81%94%E7%9A%84%E5%BF%83%E7%81%B5%E5%85%B1%E4%BA%A7%E4%B8%BB%E4%B9%89%E6%97%B6%E4%BB%A3%E7%9A%84%E4%BF%84%E5%9B%BD%E6%96%87%E5%8C%96/</guid>
      <description>以赛亚·伯林
献言 共产主义教育工作者的任务……主要是斯大林所谓的（人类灵魂）工程师的任务，亦即，对人进行调试，使得人们只会提出很容易获得答案的问题，让人们在成长过程中因最小的摩擦而顺其自然地适应所处的社会
好奇心本身、个人独立探索精神、创造和思考美好事物的愿望、寻求真理本身的愿望、追求某些目的的愿望（这些目的本身确是人类的目的，能够满足我们天性中某些深层欲望），都是有害的，因为它们会扩大人们之间的差异，而不利于一个整体性社会的和谐发展。
导言 观念起着非凡的作用
思考我们所处的社会、国家和世界所面临的最棘手的问题——并寻求解决之道。
他没有把自己称作哲学家，而是自称为观念史学家。他并没有把自己看作是新真理的传播者，而是把自己当作古老真理的研究者、评论者、综合者和阐释者。
他不仅仅尊重他人的观点，而且尊重现实的复杂性——包括道德的复杂性。
每个人都兼有这两种动物的特质，尽管所占比例和相互影响的程度不同。
对大观念的戒备心，尤其是当这些观念为政治领导人所利用的时候。
一元论主张像我们是谁、我们该怎么办、我们该如何统治和被统治这类问题都有唯一正确的答案。一旦掌权者声称对真善美拥有绝对的解释权，邪恶便会产生。
20世纪的两种极权主义。一个与希特勒的名字相连，另一个则与斯大林有关。
他坚信所谓多元的可能性
俄国二元论中至善的一面终将战胜邪恶的一面
共产党路线巧妙而具有策略的灵活性决不允许“整个制度变得太过疲软而无效，也不会放任其过分紧张而走向自我毁灭”。这是“斯大林元帅的原创，是他对统治术的主要贡献”——也是独裁者的一种生存之道。
只要苏联的统治者继续熟练地掌控着统治机器并不断地从他们的秘密警察那里获得足够的情报，那么令人沮丧的独裁以及对其他人的肆意摆布似乎未必一定会导致政权内部的瓦解，甚至是统治者智力和意志的衰退……尽管这一庞大的统治机器可能困难重重、危机四伏，但我们决不要低估它成功生存下去的能力。它的未来可能还不确定，甚至还不稳固；它可能犯错误，可能翻船，可能循序渐进也可能疾风骤雨，但是除非人性的善良一面得以彰显，否则它未必注定会失败。
它们最终必须找到自己的出路，要么解体，要么苏维埃政权变得日益成熟”
一个伟大的民族，他们拥有无穷的创造力，一旦获得自由，说不准他们会给世界带来什么样的惊喜呢”
斯大林统治下的俄罗斯艺术 由于各种原因，俄罗斯在各个历史时期一直与世界上的其他国家保持某种程度的隔绝，因而也从未真正成为西方传统的一部分。
时而表现为一种希望融入并成为欧洲生活主流的狂热而毫不餍足的渴求；时而又表现出对西方价值带着怨恨（“西徐亚人式的”）的轻蔑
这种交织着爱与恨的情绪渗透在几乎每一位著名的俄罗斯作家的作品中
十月革命使俄国更为彻底地与世隔绝，她的发展也势必变得更加自怜自艾，与邻国的发展大相径庭。
全神贯注且不厌其烦地沉浸于对社会和道德问题的思考，或许是整个俄罗斯艺术和思想的一个最为引人注目的特征；
论战的一方主要是那些艺术上的叛逆者，他们指望革命能够实现他们最激进的“反资产阶级”的主张
另一方主要是那些务实的政治家，他们希望所有的艺术和知识活动都能够直接服从于革命的社会和经济目标。
严格的书报检查制度只允许发表经过仔细筛选的作者的作品和观点
新的正统随着1928年托洛茨基的垮台而最终建立起来，从而彻底结束了这段苏联艺术的孵化期。
这个以其冷酷的简单性和粗鲁的狂热新世界观而自诩的无产阶级文化，正是由一直在痛苦挣扎但却高歌猛进的苏联孕育出来的。
国家控制贯穿始终。
1934年，布尔什维克政权通过采取分级监控的办法进一步强化了这项古老的制度——首先通过作协，然后经相应的国家委任的人民委员，最终由党的中央委员会作出决定。
作家们不得不锻炼他们把握分寸的能力，在不打破正统的框架或招致直接的罪名和惩罚的前提下来表达他们非正统的观念。
高尔基直到1935年才逝世；而只要他还健在，就会利用其巨大的个人权威和声望保护一些杰出的引人注目的作家免受过分的监管与迫害；他自觉地扮演着“俄国人民的良心”的角色，延续了卢那察尔斯基（甚至是托洛茨基）的传统，保护着有前途的艺术家免遭官僚统治机构的毒手。
猎巫运动开始了；异端邪说，不论是左还是右，不断地被“揭露”出来，那些被指控为异端的人面临着恐怖的结局；然而就是如此残忍的意识形态论争，惴惴不安地不知道会因支持哪一方而被定罪遭到清洗，也给知识界带来了一种严酷的生命力
政府显然已经感觉到自己的统治基础不稳固，或是担心在西方，或者可能与西方会有一场大战，于是对那些完全出于假设的“可疑”分子，以及无数的清白无辜者下手，其残忍和极端的程度只有遥远的西班牙宗教裁判所和反宗教改革运动可与之相比。
那个时代最杰出的幸存者如今都默默无闻，战战兢兢，唯恐犯了某条违反党的路线的死罪，至于是什么路线，无论是战前的大批判时期还是之后，都不是很清楚。
对权威的卑躬屈膝达到了前所未闻的程度。
苏联为什么选择隔离自己 我们都知道俄国之所以对西方不信任主要是因为她从未长期融入过欧洲，也不经常与欧洲各国打交道，所以她觉得不安全，低人一等。
经济的落后又大大加深了她的自卑感
俄国人会问，蕞尔小国如何能将自己的版图扩张到覆盖整个地球的表面？那只可能有一种答案：在这小小的岛国之上，聚集了一大帮智力发达、精力充沛的家伙，他们正在努力实现一项长期的、马基雅维利式的计划。
把自己看作是笨拙的巨人、天生感情丰富的糊涂虫的俄国人
苏联的出版社所追求的目标可以说就和学校的刊物一样，是为了更高的一致性
苏维埃社会主义共和国联盟（USSR）不能简单地看成是伊凡雷帝、彼得大帝加上一个东方的价值观。他们的经济社会观念和实践才是最根本的。
当英国人采取了较为文明的举措时，俄国人就按捺不住地看到了帝国主义开始衰败和动摇的苗头——即所谓的克伦斯基主义，认为帝国主义已经不再那么自信，消灭它的时机已经成熟，应该立即展开迅猛的进攻。
英国曾经形成了一套固定的印象，即把俄国人描绘成扩张成性的帝国主义者
两个国家都在利用依据不足的公式来解释对方的态度。
只有让人觉得除了依靠自己的经济和军事力量外别无选择，才有可能做到，因为在这个充斥着为“反动”流氓操纵的白痴的世界上，唯有马克思主义和它所号召的牺牲精神是实际而又有效的防卫武器。
人为的辩证法：最高统帅斯大林与统治术 我听了，我是照他说的做了。可是当我向左走的时候船却向右摆，而我向右走的时候船又向左摆。
能够小心翼翼地让自己的行为与党的辩证运动合拍搭调——对从左向右转这个精确瞬间的把握多半靠的是直觉——那是苏联公民所能学到的最重要的诀窍。如果你不谙此道，即使对这个体制有再深刻的理论认识也无济于事
能出众、精明强干，在建国之初曾经狂热拥护、坚定支持这个政权的人最终却被打倒，已经向我们昭示了这一点。
不能预判变化无常的路线对共产党员来说是最大的失败。轻则打乱他所有的个人计划；重则把他整个人彻底毁灭。
革命形势来临的时候，肃清那些对你已经没有价值的盟友，然后发起进攻，实施打击；在革命形势尚未到来的时候，则通过临时性的结盟、建立人民阵线，利用自由主义者和人道主义者的掩护，引证那些提出可能实现乃至渴望实现相互宽容、和平共处的古老文本来聚集力量。
我们的理论源于这样的假设：任何通过革命建立起来的政权毫无例外地都会受到两种主要威胁。
其一是革命可能进行得过头——过分狂热的革命者可能造成过度的破坏，
甚至那些最终依靠其智慧和才干革命才得以胜利、革命果实才得以保留下来的开国元勋们，也难逃厄运。
第二种威胁恰恰相反：它通常是第一种威胁的自然结果。革命最初的心气一过，热情（包括精力）就会减弱，动力也变得不那么强烈和纯粹，对英雄主义、牺牲精神、献出生命和财产产生厌恶，正常的习惯又重新恢复，一开始那种大胆而又骄傲的试验气魄将慢慢减退，并最终在卑鄙的腐败和堕落中消失殆尽。
所有的革命领袖都不希望看到他的政权被自己点起的烈焰所吞噬，也不愿看到自己刚刚通过革命建立起来的政权又退回到老路上去，因此避免这两种极端的威胁——既要防止雅各宾派自我毁灭式的狂热，又要避免革命后的厌倦与悲观——就成了所有革命领袖的首要任务。
如果不迅速地进行这样的再教育，苏联的整个生活模式——所有集权国家仰仗的都是不停的规训和一刻也不放松的管束，很可能马上面临垮塌的危险。
众所周知这是一切集权政府走向灭亡的开始。
这个国家再次笼罩在无所不包的正统意识形态的巨大斗篷之下。要求全党揭露和开除各种机会主义者和那些在战乱期间混入革命队伍的流氓无赖。
此类运动的危险在于它将权力置于一群狂热分子手中，他们剪除一切旁枝异端，不断地致力于保持教派的纯洁性，如今凡是对生长没有多大促进作用的都成了他们的剪除对象
党和政府一直致力于将独立思想消灭于萌芽状态
按照一般的假设，党是从来不会犯错误的；要错也只可能是因为对路线理解错误或执行不力。
在一个以马克思主义理论为核心教义的体制中，任何触动马克思主义理论基础的举动都是不切实际的。
一个雇佣了成千上万职业鼓动家，并要求他们必须以通俗易懂的语言教育孩子和文盲的体制，不可能允许对它的核心真理有任何的怀疑和含糊不清。
对于一部机器来说放得太松了，如果不开始慢慢地收紧，它将根本无法继续运行下去。如今又重新主张一致性、纯洁和正统；又开始严禁任何的怀疑[插图]，新的循环又开始了。
恐怖施行得太过分（譬如1930年代末叶若夫统治时期那样），结果会把人们吓得什么话也不敢说。人们除了说些最老套的表忠心的套话，谁也不会和人谈论稍微有点“危险”的话题，而且说的时候还非常的节制，因为谁也无法肯定从今天到明天哪些话变得可以说，哪些话又变得不能说。</description>
    </item>
    
    <item>
      <title>论不服从</title>
      <link>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E8%AE%BA%E4%B8%8D%E6%9C%8D%E4%BB%8E/</link>
      <pubDate>Wed, 28 Sep 2022 10:02:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%94%BF%E6%B2%BB/%E8%AE%BA%E4%B8%8D%E6%9C%8D%E4%BB%8E/</guid>
      <description>艾里希·弗洛姆
序言 服从人性和人道社会的目标，不服从各种偶像。
反对盲从因袭，对司空见惯的“陋识”部分持批判的立场，依然应该是我们的主要宗旨。
他所服从的是心智健全的思考方式
对和平和人类生存的殷忧和热忱跃然纸上。
第一章 价值观、心理学与人类生存之道 价值观的真实有效性因人的存在而存在；离开了人，则无价值观可言。人的本性是什么？人类生存的特定条件是什么？哪些需求是根植于这些条件中的？
人类从最初与大自然浑然一体的状态中分离出来，亦即告别了那种动物生存的特性。是时人具备了理性和想象力，意识到自身的孤立和分离，感受到自身的无力和无知以及生死无常。一个人倘使不能与他人建立一种全新关系，以取代之前凭本能调节的关系，便一刻也无法在这种状况下生存。
人与其他生物的区别在于唯有人能够意识到自己既作为创造物存在，又作为创造者存在。
人——无论男人女人——都可以创造，种植、制造物质用品、进行艺术创作、构想意念、和他人相爱。通过创造行为，人即超越了作为创造物的自我，将自己从充满被动性和偶然性的存在中提升出来，进入一个具有生活目的和自由的王国。
人对生存状态还有第三方面的需求，那就是根基需求，人的诞生之日即从自然家园出发之旅的始点，亦即与自然纽带切割的始点。
人一旦断了在自然的根，将向何处去？人又是谁？人独立遗世、无依无靠、无根无基；人难以承受这种绝缘与无助的处境。人会发疯失智。只有当重又续上新的人类之根，才能捐弃自然的根；只有当找到人类根基，才会感到再度回到世间的家园。
对我们大部分人来说，生活的悲剧在于我们还没有充分地完成出生这个过程，就已经走到了生命的尽头。
爱在本质上是神经质的、幼稚的、无理的。
哪里有本我，哪里必须有自我。
我们应该克服二者割裂的概念，在人的身上重建二者的原始统一，并认识到思维和感情、灵与肉的割裂其实正是我们主观臆断的结果，与人类现实不符；
十九世纪告诉我们“上帝死了”；二十世纪告诉我们“人死了
手段变成了目的，物质的生产和消费变成了生活的目标，而生活本身退居从属地位。
生产出来的物品如人般活灵活现，而生产出来的人却如物品般死气沉沉
人从自我异化，倒退为盲目崇拜，即便顶着上帝之名。
用具端坐于鞍，鞭笞人类疾行。
安乐福祉的实现只有一个条件：使人回到马鞍上。
第三章 人本主义精神分析之于马克思理论的应用 马克思主义是人本主义（humanism），它的宗旨是将人的潜力充分发挥出来
马克思学说的出发点是人，他的目标是使人摆脱物质利益的支配控制，使人逃离由协定和契约构成的围住自己的狱墙。
对马克思而言，资本的研究是一项批判工具，用来理解大工业社会中人的“有缺陷的”（crippled）状态。
“人的本质”、“有缺陷的人”、人的“异化”、人的“意识”、人的“激情奋争”、人的“独立”
马克思于1883年逝世，而弗洛伊德在马克思逝世十多年后才开始发表他的论著。
弗洛伊德创立的心理学分支对马克思的分析而言是一种必要的补充
精神分析首先是一种动力心理学。它要分析的是各种精神力，那种使得人们发生行为、动作、感情、念想等的动力。
在一个人所参与的社会活动中，人的需求与社会历史现实不断相互作用的一个进化过程。
马克思主义者因袭了忽略心理学的传统，而弗洛伊德及其追随者只在机械唯物主义的框架下发展他们的理论
最值一提的是马克思人本主义理论的复苏。
马克思理论需要同关于人的心理学理论结合起来；他们同时亦越来越意识到社会主义必须满足人对建立自我定向和奉献系统的需求，也需要回答人是什么、生活的意义和目的何在这类大哉问。
只要为革命（工人国家、历史进步，等等）服务，就是好的
对性欲（libido）理论的重新评估
马克思的理论是以人为中心的，如果它既不想脱离人类现实，但又不引入心理学的要素，是无法作为理论维持下去的。
“社会性格”（social character），即某种群体（比如民族或阶级）共同拥有的性格基体，这个基体有效地决定了其成员的行为和思维。
弗洛伊德将性格看作追求满足各式各样的性欲冲动的一种相对稳定的呈现，也可说是精神能量的呈现——导向实现某些特定目标的、出自某些特定渊源的精神能量。
将人的行为解释成独特的激情奋争的结果。
社会性格的概念指代一个群体共有的性格结构的基体。
平和的、从事农耕的部落成员则反对暴力，所以他们更倾向于互助合作。
资本主义社会，人们渴望工作、遵纪守时、以挣钱为要务，以通过生产和交换获得利润为生活主旨，只有在这种情形下，社会才能兴盛。
十九世纪，资本主义社会需要人们乐于积蓄，到了二十世纪中叶则需要人们热衷花钱和消费。
为什么一个社会能够成功俘获大多数成员的忠心——即便这些成员已经饱受体制之苦，即便理性已经告诉他们效忠这个社会最终会戕害自身？
他们为什么不能看清他们的真正利益，而被那些由形形色色的意识形态影响力和洗脑运动炮制出来的虚假利益所迷惑？
一个社会一旦成功塑造了普通百姓的性格结构，让一个人爱上其不得不做的事，人就会对社会强加的条件无怨无悔。
他想做什么就能做什么，因为他只想那些他能做的事。
在马克思的理论中，对经济基础和上层建筑关系的实质阐述得其实并不充分。
我们不能仅仅看到经济基础在形成社会性格中起作用，而社会性格又创造了某些思想体系；我们还要看到这些思想体系一旦确立，便会对社会性格产生影响，并间接地影响社会的经济结构。
这个中介具有双向调节的作用，既以经济基础构建理想观念，又以理想观念构建经济基础。
说到底，人是最柔韧的自然力之一。人能够被用来满足几乎任何目的；能够被调教得会仇恨或会合作，会俯首帖耳或会特立独行，会安于磨难或会享受幸福。
人可以接受加诸其身的几乎任何事，但仍有一个临界点。人为自由而战的历史最有力地证明了这一原理。
假定“农民性格”被定义为个人主义的、善于囤积贮藏的、顽固的、难以在合作中被取悦的、极少时间观念和守时概念的
社会性格在高度工业化的社会里，已史无前例地普遍成为一种消费人（homo consumens）
消费人的主要目标首先不是拥有物质，而是消费越来越多的物质，以此弥补内心的空虚、怠钝、孤独、焦虑。在一个以巨型企业和庞大的工业、政府和工会官僚政治为特征的社会，失去对工作环境控制能力的个人感到的是无奈、孤立、厌倦、烦躁。
有着盈利需求的大型消费产业通过媒体广告将其变成了一个饕餮之徒，一个对消费贪得无厌的人，把一切都视作消费品，从烟、酒到性生活、电影、电视、旅行，甚至连教育、书籍、讲座都不能幸免。
象。在抑郁症或焦虑症的病例中，不难发现患者以暴饮暴食、疯
弗洛伊德将对消费抱有强烈欲望的某种极端形式称为“口欲接受性格”，
消费人被幸福的幻觉笼罩，在无意识里则深陷无聊和倦怠不能自拔。
消费得越多，就越像一个奴隶，被产业系统制造和操纵的日益膨胀的需求缚住手脚。消费人将刺激和兴奋误作愉悦和幸福，将物质舒适误作生机活力，满足贪求无度的欲望成了生活的意义，为满足欲望而奋斗变为一门新的宗教。消费的自由成了人类自由的核心。
人不追求有很大一笔财富，或用很大一笔财富，但人本身就是很大一笔财富。他要将人从物欲的锁链中解脱出来，这样人可以时刻保持清醒、保持活跃、保持敏感，而不会成为贪欲的奴隶
他要消除极端贫困，因为贫困妨碍人的全面成长；他还要消除极端富裕，因为人会变成贪欲的囚徒。他的目标不是消费的最大化，而是消费的最优化。最优化消费保证人能满足其真正需求，那是使其过上更为完整而丰满的生活的手段。
资本主义精神以满足物欲为目标，而共产主义和社会主义国家实施它们的计划经济，应该可以抑制人的物欲，但历史上的讽刺事件之一，恰是前者正在战胜后者。
社会主义的胜利变成了在社会主义的精神框架内与资本主义采取一样的手法来进行成功的竞争</description>
    </item>
    
    <item>
      <title>改革悖论</title>
      <link>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E6%94%B9%E9%9D%A9%E6%82%96%E8%AE%BA/</link>
      <pubDate>Tue, 27 Sep 2022 17:42:00 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E6%94%B9%E9%9D%A9%E6%82%96%E8%AE%BA/</guid>
      <description>什么是“改革悖论”？ 即改革需要从现有体制中获益最大的政府权力部门及其官员来加以推进，而这种改革最终又可能会“改革掉”该部门及其官员手中的权力。那么，这样的改革真的能有效推进吗？
摘自包刚升《被误解的民主》</description>
    </item>
    
    <item>
      <title>什么是社会主义</title>
      <link>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89/</link>
      <pubDate>Tue, 27 Sep 2022 15:21:17 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89/</guid>
      <description>社会主义作为一种意识形态的出现，是对资本主义早期发展的反应。
社会主义的发展 1、 空想社会主义
欧文、圣西门和傅里叶等人都是空想社会主义的代表，他们强调集体主义和互助，批评资本主义的诸种负面现象。
2、科学社会主义
后来，这一派的学说就慢慢地发展为科学社会主义或者叫共产主义，这主要是指马克思和恩格斯的学说。
马克思和恩格斯主张通过无产阶级革命来建立公有制，实行计划经济，建设共产主义。
3、社会民主主义
马克思与恩格斯之后，社会主义学说后来又有新的发展，被称为改良的社会主义或社会民主主义。
其中一位杰出代表性人物是德国思想家与政治活动家爱德华·伯恩斯坦，他认为应该放弃暴力革命，主张通过议会方式进行民主斗争，并进而改变资本主义国家的经济政策，强化再分配，实现社会平等以及建设福利国家。
今天的发达国家——特别是欧洲大陆的发达国家——其政治经济模式已经融合了自由主义和民主社会主义的因素。
什么是社会主义意识形态的主要特征呢？ 借鉴安德鲁·海伍德的论述，这里把社会主义意识形态视为对若干原则的倡导：
1、强调共同体原则。
在个人与群体的关系上，社会主义强调的是群体，认为脱离了群体的个人是不存在的，个人脱离群体实际上也无法生存。
2、平等主义原则。
社会主义就更重视平等。社会主义的平等观，不只是形式平等和机会平等，同样重要的是实质平等和结果平等。
平等的重要性与优先性，是衡量一种观点是否属于社会主义意识形态的关键标准。
3、博爱原则。
社会主义的最终目标也是要让所有人或绝大多数人都过上一种更美好、更体面和更有尊严的生活。
4、阶级原则。
社会主义秉承阶级分析方法，把社会分成资产阶级和无产阶级，或上层阶级和下层阶级。前者是统治阶级，后者是被统治阶级。
社会主义主张打破既有的阶级结构，以构建更平等的、甚至无阶级的社会作为理想。
5、财产的社会控制原则。
社会主义认为，只要财产控制在私人手里，必定会带来前面提到的不平等和阶级压迫。所以，社会主义寻求的是让财产的私人占有过渡到某种形式的财产的社会控制。
6、满足需求的原则。
社会主义比较注重人基本需求的满足。每一个人都有很多基本需求，每个人应该拥有满足这些基本需求的权利。所以，共产主义的口号是“各尽所能，按需分配”。
摘自包刚升《政治学通识》</description>
    </item>
    
    <item>
      <title>当代中国社会阶层</title>
      <link>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E9%98%B6%E5%B1%82/</link>
      <pubDate>Tue, 27 Sep 2022 13:32:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E9%98%B6%E5%B1%82/</guid>
      <description>所处阶层 阶层 特点 官 商 工 农 上层 1 对全国局势有控制能力 国家级 - - - 上层 2 能影响国家政策 中央级 重要行业龙头企业实际控制人，企业市值通常在百亿级别以上 - - 上层 3 能影响一个地区或行业的发展 省部、副省部 行业重要企业实际控制人企业市值通常在十亿到百亿 - - 中产 4 和上层有千丝万缕的联系 厅局级 行业中型企业实际控制人：企业市值通常在几亿到十亿，通常会上市 大型企业核心管理层、著名专业人士综合年收入千方以上 - 中产 5 有自己的事业 普通初级副处级 中小企业主，企业规模通常在千万到亿级别 中等职业管理人、有名的专业人士，综合年收入百万到千万 - 中产 6 有一定的上升空间 普通科级干部 小企业主，企业规模通常在百万到千万级别 有一定发展潜力的职员，工作四五年收入在能达到20万左右水平，但收入很难突破100万 - 下层 7 能够在大中城市立足 普通办事人员 个体户，生意规模在几十万 普通员工，所处工种年收入在10-20万 富裕衣民，有一定规模的自家产业 下层 8 能够自食其力 外编办事人员 普通员工，所处工种年收入在5-10万 普通农民，有小产业 下层 9 - - - 低收入职员，所处工种年收入在5万以下 低收入农民以出卖劳动力为主 1、中国的上层社会 一级：以在任“政委”、退休常委为代表，对全国局势有掌控能力；</description>
    </item>
    
    <item>
      <title>政治的三个维度</title>
      <link>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E6%94%BF%E6%B2%BB%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%B4%E5%BA%A6/</link>
      <pubDate>Tue, 27 Sep 2022 10:17:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E6%94%BF%E6%B2%BB%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%B4%E5%BA%A6/</guid>
      <description>对领导人而言，政治情势可以被分解为三种人群：名义选择人集团、实际选择人集团和致胜联盟。
1、名义选择人集团 名义选择人集团包含了所有在选择领导人时至少具有某些法定发言权的人。
正如每个美国公民肯定都意识到的，虽然拥有选举权很重要，但归根结底，没有哪个个人在谁领导国家上有太多发言权。
名义选择人集团刚刚触及到政治的门槛，仅此而已。
2、实际选择人集团 第二个政治阶层由实际选择人组成。真正选择领导人的是这个集团。
3、致胜联盟 最重要的集团是第三种，它是实际选择人集团的一个子集，构成了一个致胜联盟。他们的支持对于一个领导人的政治生存至关重要。
在美国，致胜联盟的规模远远大得多。
对路易十四来说，致胜联盟由一小群法官、军官和高级公务员组成，没有他们，路易国王恐怕早被别人取而代之了。
从根本上讲，名义选择人就是领导人的潜在支持者；实际选择人则指那些其对领导人的支持确实有重要影响的人；而致胜联盟只包括那些领导人不可或缺的关键支持者。这三种人可简单概括为：可相互替代者、有影响者以及不可或缺者。
像东北亚的某个国家（是中国吗？自己想），有规模巨大的名义选择人集团，每个人都能投票——当然这是个笑话——有规模很小的实际选择人集团，以及一个也许不超过几百人的致胜联盟，但没有这个联盟的话甚至当年他们的第一任领导人都早已灰飞烟灭。
想想你所在的公司吧。谁是你的领导人？谁的支持对他或她来说是不可或缺的？哪些人尽管对你的首席执行官来说并非不可或缺，但在公司治理结构中仍然很有影响？
在所有或大或小组织里的政治运作都是以这三个集团的区分为基础。
在不同国家、不同企业或任何其他组织里，这三种人群的规模差异几乎决定了政治里发生的一切——领导人能做什么，什么事是他们能或不能逃脱追究的，他们必须对谁负责，在他们的领导之下每个人享有的相对生活质量（或者说，常常不享有）。
摘自《独裁者手册》</description>
    </item>
    
    <item>
      <title>领导人基本法则</title>
      <link>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E9%A2%86%E5%AF%BC%E4%BA%BA%E5%9F%BA%E6%9C%AC%E6%B3%95%E5%88%99/</link>
      <pubDate>Tue, 27 Sep 2022 09:52:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E6%95%B4%E7%90%86/%E9%A2%86%E5%AF%BC%E4%BA%BA%E5%9F%BA%E6%9C%AC%E6%B3%95%E5%88%99/</guid>
      <description>领导人有5个基本法则可用于在任何体制下获得成功：
法则1：让你的致胜联盟越小越好。 一个小规模的致胜联盟使领导人只需依赖极少数人就能保持权位。越少的不可或缺者相当于领导人拥有更多控制权，对支出的自由裁量权也越大。
法则2：让你的名义选择人集团越大越好。 保持一个很大的选择人集团你就能很容易地替换掉致胜联盟里的捣蛋分子，无论是有影响者还是不可或缺者。毕竟，一个很大的选择人集团提供了充足的替代支持者，让不可或缺者时刻谨记必须保持忠诚、规规矩矩，不然就会被别人取代。
法则3：掌控收入的分配。 对一个统治者来说，与其拥有一张让人民可以喂饱自己的更大的饼，永远不如他能够决定谁吃这张饼。对领导人来说，最有效的资金分配方式是让很多人受穷，通过重新分配让挑选出来的支持者发财。
让我们为巴基斯坦总统阿西夫·阿里·扎尔达里喝彩，他的财富估计高达40亿美元，尽管他统治着一个人均国民收入几乎全球垫底的国家。
法则4：支付给你的核心支持者刚好足够确保他们忠诚的钱。 记住，你的支持者宁愿成为你而不是仰赖你。 你的巨大优势在于你知道钱在哪里而他们不知道。给你的联盟足够的钱，以免他们到处寻找取代你的人，但一分钱都不要多给。
让我们为津巴布韦的罗伯特·穆加贝喝彩，他无论何时面临军事政变的威胁，最终总能用钱摆平，在重重困难下始终保持军队忠诚。
法则5：不要从你的支持者的口袋里挪钱去改善人民的生活。 法则4的反面就是不要对你的支持者太抠门。如果你以损害致胜联盟的利益为代价而善待人民，很快你的“朋友们”就会伺机找你的麻烦。有利于普通老百姓的政策不仅未必能让核心支持者产生忠诚，而且太贵。饥饿的人民不可能有精力推翻你，大可不必担心他们。 相反地，失望的致胜联盟成员则会变节，让你深陷麻烦。
让我们为缅甸的丹瑞将军喝彩，在2008年的纳尔吉斯飓风之后他控制了外界提供的粮食援助，让他的军队支持者拿到黑市上去倒卖，而不是援助灾民——至少13.8万人死于那场风灾，有的报告甚至认为死亡人数高达50万人。
摘自《独裁者手册》</description>
    </item>
    
    <item>
      <title>21.调整数组顺序使奇数位于偶数前面</title>
      <link>https://www.pengjielee.cn/post/sword2/21.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link>
      <pubDate>Fri, 27 Aug 2021 13:57:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/21.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid>
      <description>题目 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
示例： 输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示：
0 &amp;lt;= nums.length &amp;lt;= 50000 1 &amp;lt;= nums[i] &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1: 两次遍历
/** * @param {number[]} nums * @return {number[]} */ var exchange = function(nums) { const result = []; //第一次遍历，添加奇数 for(let num of nums){ if(num % 2 != 0){ result.push(num); } } //第二次遍历，添加偶数 for(let num of nums){ if(num % 2 === 0){ result.push(num); } } return result; }; 参考2：头尾双指针</description>
    </item>
    
    <item>
      <title>22.链表中倒数第k个节点</title>
      <link>https://www.pengjielee.cn/post/sword2/22.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 27 Aug 2021 13:43:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/22.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>题目 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
示例： 给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2. 返回链表 4-&amp;gt;5. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2. 返回：4 -&amp;gt; 5
链表长度：5，倒数第2，即正数第 3
JS实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var getKthFromEnd = function(head, k) { // 获取链表长度 const getLength = (head) =&amp;gt; { let length = 0; let curr = head; while(curr) { length++; curr = curr.</description>
    </item>
    
    <item>
      <title>28.对称的二叉树</title>
      <link>https://www.pengjielee.cn/post/sword2/28.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 27 Aug 2021 13:17:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/28.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.</description>
    </item>
    
    <item>
      <title>27.二叉树的镜像</title>
      <link>https://www.pengjielee.cn/post/sword2/27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Fri, 27 Aug 2021 13:17:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/27.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>题目 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入： 4 / \ 2 7 / \ / \ 1 3 6 9 镜像输出： 4 / \ 7 2 / \ / \ 9 6 3 1 示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var mirrorTree = function(root) { if(root === null){ return null; } const temp = root.</description>
    </item>
    
    <item>
      <title>18.删除链表的节点</title>
      <link>https://www.pengjielee.cn/post/sword2/18.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 26 Aug 2021 17:14:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/18.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>题目 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意：此题对比原题有改动
示例 1: 输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9. 示例 2: 输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9. 说明：
题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1:
/** * Definition for singly-linked list. * function ListNode(val) { * this.</description>
    </item>
    
    <item>
      <title>04.二维数组中的查找</title>
      <link>https://www.pengjielee.cn/post/sword2/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Wed, 25 Aug 2021 15:06:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>题目 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制：
0 &amp;lt;= n &amp;lt;= 1000 0 &amp;lt;= m &amp;lt;= 1000
注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var findNumberIn2DArray = function(matrix, target) { const rows = matrix.</description>
    </item>
    
    <item>
      <title>03.数组中重复的数字</title>
      <link>https://www.pengjielee.cn/post/sword2/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 25 Aug 2021 15:05:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3
限制：
2 &amp;lt;= n &amp;lt;= 100000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var findRepeatNumber = function(nums) { const map = new Map(); for(let i = 0; i &amp;lt; nums.length; i++){ if(map.has(nums[i])){ return nums[i] } map.set(nums[i],true); } }; </description>
    </item>
    
    <item>
      <title>67.把字符串转换成整数</title>
      <link>https://www.pengjielee.cn/post/sword2/67.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 25 Aug 2021 15:04:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/67.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</guid>
      <description>题目 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−2^31, 2^31− 1]。如果数值超过这个范围，请返回 INT_MAX (2^31− 1) 或INT_MIN (−2^31) 。
示例1:
输入: &amp;ldquo;42&amp;rdquo; 输出: 42 示例2:
输入: &amp;quot; -42&amp;quot; 输出: -42 解释: 第一个非空白字符为 &amp;lsquo;-&amp;rsquo;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例3:
输入: &amp;ldquo;4193 with words&amp;rdquo; 输出: 4193 解释: 转换截止于数字 &amp;lsquo;3&amp;rsquo; ，因为它的下一个字符不为数字。 示例4:
输入: &amp;ldquo;words and 987&amp;rdquo; 输出: 0 解释: 第一个非空字符是 &amp;lsquo;w&amp;rsquo;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例5:
输入: &amp;ldquo;-91283472332&amp;rdquo; 输出: -2147483648 解释: 数字 &amp;ldquo;-91283472332&amp;rdquo; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</description>
    </item>
    
    <item>
      <title>57.和为s的两个数字</title>
      <link>https://www.pengjielee.cn/post/sword2/57.%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 25 Aug 2021 13:44:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/57.%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>题目 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2： 输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] 限制：
1 &amp;lt;= nums.length &amp;lt;= 10^5 1 &amp;lt;= nums[i] &amp;lt;= 10^6
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let left = 0, right = nums.length - 1; while(nums.length){ const num1 = nums[left], num2 = nums[right]; if(num1 + num2 === target){ return [num1, num2]; } else if(num1 + num2 &amp;lt; target){ left++; } else { right--; } } return [-1,-1]; }; </description>
    </item>
    
    <item>
      <title>64.求1&#43;2&#43;…&#43;n</title>
      <link>https://www.pengjielee.cn/post/sword2/64.%E6%B1%821&#43;2&#43;&#43;n/</link>
      <pubDate>Wed, 25 Aug 2021 13:36:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/64.%E6%B1%821&#43;2&#43;&#43;n/</guid>
      <description>题目 求 1+2+&amp;hellip;+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
示例 1：
输入: n = 3 输出: 6 示例 2：
输入: n = 9 输出: 45 限制：
1 &amp;lt;= n &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qiu-12n-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var sumNums = function(n) { let result = n; result &amp;amp;&amp;amp; (result += sumNums(n - 1)); return result; }; </description>
    </item>
    
    <item>
      <title>48.最长不含重复字符的子字符串</title>
      <link>https://www.pengjielee.cn/post/sword2/48.%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 25 Aug 2021 09:05:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/48.%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例 1: 输入: &amp;#34;abcabcbb&amp;#34; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。 示例 2: 输入: &amp;#34;bbbbb&amp;#34; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。 示例 3: 输入: &amp;#34;pwwkew&amp;#34; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。 提示：
s.length &amp;lt;= 40000 注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { const map = new Map(); let left = 0, max = 0; for(let i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>47.礼物的最大价值</title>
      <link>https://www.pengjielee.cn/post/sword2/47.%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</link>
      <pubDate>Wed, 25 Aug 2021 09:04:11 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/47.%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</guid>
      <description>题目 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
示例 1: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示：
0 &amp;lt; grid.length &amp;lt;= 200 0 &amp;lt; grid[0].length &amp;lt;= 200
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 设 f(i,j) 为从棋盘左上角走至单元格 (i,j) 的礼物最大累计价值，易得到以下递推关系：f(i,j) 等于 f(i,j-1) 和 f(i-1,j) 中的较大值加上当前单元格礼物价值 grid(i,j) 。
f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j) 作者：jyd 链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考1：滚动数组
/** * @param {number[][]} grid * @return {number} */ var maxValue = function (grid) { const rows = grid.</description>
    </item>
    
    <item>
      <title>05.替换空格</title>
      <link>https://www.pengjielee.cn/post/sword2/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link>
      <pubDate>Tue, 24 Aug 2021 15:03:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid>
      <description>题目 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
示例 1：
输入：s = &amp;ldquo;We are happy.&amp;rdquo; 输出：&amp;ldquo;We%20are%20happy.&amp;rdquo; 限制：
0 &amp;lt;= s 的长度 &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {string} */ var replaceSpace = function(s) { let result = &amp;#39;&amp;#39;; for(let i = 0; i &amp;lt; s.length; i++){ if(s[i] === &amp;#39; &amp;#39;){ result += &amp;#39;%20&amp;#39;; }else { result += s[i]; } } return result; }; </description>
    </item>
    
    <item>
      <title>24.反转链表</title>
      <link>https://www.pengjielee.cn/post/sword2/24.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 24 Aug 2021 13:34:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/24.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
示例: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 5000
注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { let prev = null; let curr = head; while(curr) { //获取当前节点的next const next = curr.next; //当前节点的next指向prev curr.</description>
    </item>
    
    <item>
      <title>06.从尾到头打印链表</title>
      <link>https://www.pengjielee.cn/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 24 Aug 2021 13:34:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/06.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制：
0 &amp;lt;= 链表长度 &amp;lt;= 10000
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、reverse()方法，反转数组
/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {number[]} */ var reversePrint = function(head) { const result = []; let current = head; while(current){ result.push(current.val); current = current.next; } return result.reverse(); }; 2、借助栈</description>
    </item>
    
    <item>
      <title>30.包含min函数的栈</title>
      <link>https://www.pengjielee.cn/post/sword2/30.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link>
      <pubDate>Tue, 24 Aug 2021 11:40:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/30.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid>
      <description>题目 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.min(); --&amp;gt; 返回 -2. 提示：
各函数的调用总次数不超过 20000 次
注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * initialize your data structure here. */ var MinStack = function() { //主存储栈 this.mainStack = []; //辅助栈 this.secondaryStack = []; }; /** * @param {number} x * @return {void} */ MinStack.</description>
    </item>
    
    <item>
      <title>09.用两个栈实现队列</title>
      <link>https://www.pengjielee.cn/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 24 Aug 2021 11:37:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword2/09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1： 输入： [&amp;#34;CQueue&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;deleteHead&amp;#34;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [&amp;#34;CQueue&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;appendTail&amp;#34;,&amp;#34;deleteHead&amp;#34;,&amp;#34;deleteHead&amp;#34;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 &amp;lt;= values &amp;lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思考 队列特点：先进先出；
栈特点：先进后出；
JS实现 var CQueue = function() { //辅助栈1：插入栈 this.insertStack = []; //辅助栈2：弹出栈 this.popStack = []; return null; }; /** * @param {number} value * @return {void} */ CQueue.prototype.appendTail = function(value) { //插入时，把元素直接插入插入栈 this.insertStack.push(value); return null; }; /** * @return {number} */ CQueue.</description>
    </item>
    
    <item>
      <title>132</title>
      <link>https://www.pengjielee.cn/post/leetcode/132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2ii/</link>
      <pubDate>Wed, 21 Jul 2021 10:50:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2ii/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>138.复制带随机指针的链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/138.%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 21 Jul 2021 10:50:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/138.%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random &amp;ndash;&amp;gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random &amp;ndash;&amp;gt; y 。
返回复制链表的头节点。
用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2：
输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3：</description>
    </item>
    
    <item>
      <title>191.位1的个数</title>
      <link>https://www.pengjielee.cn/post/leetcode/191._%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 19 Jul 2021 11:32:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/191._%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &amp;lsquo;1&amp;rsquo; 的个数（也被称为汉明重量）。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &amp;#39;1&amp;#39;。 示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &amp;#39;1&amp;#39;。 示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &amp;#39;1&amp;#39;。 提示：
输入必须是长度为 32 的 二进制串 。 进阶：
如果多次调用这个函数，你将如何优化你的算法？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-1-bits 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n - a positive integer * @return {number} */ var hammingWeight = function(n) { let ret = 0; for (let i = 0; i &amp;lt; 32; i++) { if ((n &amp;amp; (1 &amp;lt;&amp;lt; i)) !</description>
    </item>
    
    <item>
      <title>192.统计词频</title>
      <link>https://www.pengjielee.cn/post/leetcode/192.%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91/</link>
      <pubDate>Mon, 19 Jul 2021 11:32:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/192.%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91/</guid>
      <description>题目 写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。
为了简单起见，你可以假设：
words.txt只包括小写字母和 &amp;rsquo; &amp;rsquo; 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。 示例:
假设 words.txt 内容如下：
the day is sunny the the the sunny is 你的脚本应当输出（以词频降序排列）：
the 4 is 3 sunny 2 day 1 说明:
不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。 你可以使用一行 Unix pipes 实现吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/word-frequency 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 cat words.txt | tr -s &amp;#39; &amp;#39; &amp;#39;\n&amp;#39; | sort | uniq -c | sort -r | awk &amp;#39;{print $2,$1}&amp;#39; or cat words.txt | xargs -n 1 | sort | uniq -c | sort -nr | awk &amp;#39;{print $2&amp;#34; &amp;#34;$1}&amp;#39; </description>
    </item>
    
    <item>
      <title>193.有效电话号码</title>
      <link>https://www.pengjielee.cn/post/leetcode/193.%E6%9C%89%E6%95%88%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/</link>
      <pubDate>Mon, 19 Jul 2021 11:32:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/193.%E6%9C%89%E6%95%88%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/</guid>
      <description>题目 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。
你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）
你也可以假设每行前后没有多余的空格字符。
示例：
假设 file.txt 内容如下：
987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码：
987-123-4567 (123) 456-7890 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-phone-numbers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 awk &amp;#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/&amp;#39; file.txt or gawk &amp;#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/&amp;#39; file.txt </description>
    </item>
    
    <item>
      <title>194.转置文件</title>
      <link>https://www.pengjielee.cn/post/leetcode/194.%E8%BD%AC%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 19 Jul 2021 11:32:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/194.%E8%BD%AC%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>题目 给定一个文件 file.txt，转置它的内容。
你可以假设每行列数相同，并且每个字段由 &amp;rsquo; &amp;rsquo; 分隔。
示例：
假设 file.txt 文件内容如下：
name age alice 21 ryan 30 应当输出：
name alice ryan age 21 30 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/transpose-file 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 COUNT=`head -1 file.txt | wc -w` for (( i = 1; i &amp;lt;= $COUNT; i++ )); do awk -v arg=$i &amp;#39;{print $arg}&amp;#39; file.txt | xargs done </description>
    </item>
    
    <item>
      <title>184.部门工资最高的员工</title>
      <link>https://www.pengjielee.cn/post/leetcode/184.%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/184.%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/</guid>
      <description>题目 Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。
+----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Jim | 90000 | 1 | | 3 | Henry | 80000 | 2 | | 4 | Sam | 60000 | 2 | | 5 | Max | 90000 | 1 | +----+-------+--------+--------------+ Department 表包含公司所有部门的信息。
+----+----------+ | Id | Name | +----+----------+ | 1 | IT | | 2 | Sales | +----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。</description>
    </item>
    
    <item>
      <title>180.连续出现的数字</title>
      <link>https://www.pengjielee.cn/post/leetcode/180.%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/180.%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 表：Logs
+-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | num | varchar | +-------------+---------+ id 是这个表的主键。 编写一个 SQL 查询，查找所有至少连续出现三次的数字。
返回的结果表中的数据可以按 任意顺序 排列。
查询结果格式如下面的例子所示：
Logs 表： +----+-----+ | Id | Num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ Result 表：</description>
    </item>
    
    <item>
      <title>181.超过经理收入的员工</title>
      <link>https://www.pengjielee.cn/post/leetcode/181.%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/181.%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</guid>
      <description>题目 Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。
+----+-------+--------+-----------+ | Id | Name | Salary | ManagerId | +----+-------+--------+-----------+ | 1 | Joe | 70000 | 3 | | 2 | Henry | 80000 | 4 | | 3 | Sam | 60000 | NULL | | 4 | Max | 90000 | NULL | +----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。
+----------+ | Employee | +----------+ | Joe | +----------+ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/employees-earning-more-than-their-managers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</description>
    </item>
    
    <item>
      <title>182.查找重复的电子邮箱</title>
      <link>https://www.pengjielee.cn/post/leetcode/182.%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/182.%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</guid>
      <description>题目 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。
示例：
+----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ 根据以上输入，你的查询应返回以下结果：
+---------+ | Email | +---------+ | a@b.com | +---------+ 说明：所有电子邮箱都是小写字母。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/duplicate-emails 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 实现1：
select Email from ( select Email, count(Email) as num from Person group by Email ) as statistic where num &amp;gt; 1; 实现2：
select Email from Person group by Email having count(Email) &amp;gt; 1; </description>
    </item>
    
    <item>
      <title>183.从不订购的客户</title>
      <link>https://www.pengjielee.cn/post/leetcode/183.%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/183.%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/</guid>
      <description>题目 某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。
Customers 表：
+----+-------+ | Id | Name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders 表：
+----+------------+ | Id | CustomerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ 例如给定上述表格，你的查询应返回：
+-----------+ | Customers | +-----------+ | Henry | | Max | +-----------+ 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>195.第十行</title>
      <link>https://www.pengjielee.cn/post/leetcode/195.%E7%AC%AC%E5%8D%81%E8%A1%8C/</link>
      <pubDate>Mon, 19 Jul 2021 10:13:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/195.%E7%AC%AC%E5%8D%81%E8%A1%8C/</guid>
      <description>题目 给定一个文本文件 file.txt，请只打印这个文件中的第十行。
示例:
假设 file.txt 有如下内容：
Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10 你的脚本应当显示第十行：
Line 10 说明:
如果文件少于十行，你应当输出什么？ 至少有三种不同的解法，请尝试尽可能多的方法来解题。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/tenth-line 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 sed -n &amp;#34;10p&amp;#34; file.txt or awk &amp;#39;{if(NR==10){print $0}}&amp;#39; file.txt or grep -n &amp;#34;&amp;#34; file.txt | grep -w &amp;#39;10&amp;#39; | cut -d: -f2 不足10行
row_num=$(cat file.txt | wc -l) echo $row_num if [ $row_num -lt 10 ];then echo &amp;#34;The number of row is less than 10&amp;#34; else awk &amp;#39;{if(NR==10){print $0}}&amp;#39; file.</description>
    </item>
    
    <item>
      <title>196</title>
      <link>https://www.pengjielee.cn/post/leetcode/196.%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</link>
      <pubDate>Mon, 19 Jul 2021 09:58:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/196.%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</guid>
      <description>题目 编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。
+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:
+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+ 提示：
执行 SQL 之后，输出是整个 Person 表。 使用 delete 语句。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/delete-duplicate-emails 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
实现 DELETE p1 FROM Person p1, Person p2 WHERE p1.</description>
    </item>
    
    <item>
      <title>197.上升的温度</title>
      <link>https://www.pengjielee.cn/post/leetcode/197.%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6/</link>
      <pubDate>Mon, 19 Jul 2021 09:51:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/197.%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6/</guid>
      <description>题目 表 Weather
+---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | recordDate | date | | temperature | int | +---------------+---------+ id 是这个表的主键 该表包含特定日期的温度信息 编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。
返回结果 不要求顺序 。
查询结果格式如下例：
Weather +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ Result table: +----+ | id | +----+ | 2 | | 4 | +----+ 2015-01-02 的温度比前一天高（10 -&amp;gt; 25） 2015-01-04 的温度比前一天高（20 -&amp;gt; 30） 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>200.岛屿数量</title>
      <link>https://www.pengjielee.cn/post/leetcode/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</link>
      <pubDate>Mon, 19 Jul 2021 09:09:30 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</guid>
      <description>题目 给你一个由 &amp;lsquo;1&amp;rsquo;（陆地）和 &amp;lsquo;0&amp;rsquo;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
示例 1： 输入：grid = [ [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;] ] 输出：1 示例 2： 输入：grid = [ [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;] ] 输出：3 提示：
m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为 &amp;lsquo;0&amp;rsquo; 或 &amp;lsquo;1&amp;rsquo; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-islands 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。
为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。
最终岛屿的数量就是我们进行深度优先搜索的次数。
作者：LeetCode 链接：https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {character[][]} grid * @return {number} */ var dfs = (grid, r, c) =&amp;gt; { const rows = grid.</description>
    </item>
    
    <item>
      <title>120.三角形最小路径和</title>
      <link>https://www.pengjielee.cn/post/leetcode/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Fri, 16 Jul 2021 15:56:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description>题目 给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
示例 1： 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 示例 2： 输入：triangle = [[-10]] 输出：-10 提示：
1 &amp;lt;= triangle.length &amp;lt;= 200 triangle[0].length == 1 triangle[i].length == triangle[i - 1].length + 1 -10^4 &amp;lt;= triangle[i][j] &amp;lt;= 10^4 进阶：</description>
    </item>
    
    <item>
      <title>119.杨辉三角II</title>
      <link>https://www.pengjielee.cn/post/leetcode/119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92ii/</link>
      <pubDate>Fri, 16 Jul 2021 11:27:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92ii/</guid>
      <description>题目 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。
在杨辉三角中，每个数是它左上方和右上方的数的和。
示例:
输入: 3 输出: [1,3,3,1]
进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pascals-triangle-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} rowIndex * @return {number[]} */ var getRow = function (rowIndex) { //性质2：第 n 行（从 0 开始编号）的数字有 n+1 项 const C = new Array(rowIndex + 1).fill(0); for (let i = 0; i &amp;lt;= rowIndex; i++) { C[i] = new Array(i + 1).fill(0); //性质1：每行数字左右对称，由 1 开始逐渐变大再变小，并最终回到 1 C[i][0] = C[i][i] = 1; //性质4：每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n−1 行的第 i−1 个数和第 i 个数之和。 for (let j = 1; j &amp;lt; i; j++) { C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; } } return C[rowIndex]; }; </description>
    </item>
    
    <item>
      <title>118.杨辉三角</title>
      <link>https://www.pengjielee.cn/post/leetcode/118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</link>
      <pubDate>Fri, 16 Jul 2021 10:54:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</guid>
      <description>题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
在杨辉三角中，每个数是它左上方和右上方的数的和。
示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ]
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pascals-triangle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 杨辉三角具有以下性质：
每行数字左右对称，由 1 开始逐渐变大再变小，并最终回到 1； 第 n 行（从 0 开始编号）的数字有 n+1 项，前 n 行共有 n(n+1)/2 个数； 第 n 行的第 m 个数（从 0 开始编号）可表示为可以被表示为组合数 C(n,m)，即为从 n 个不同元素中取 m 个元素的组合数； 每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n−1 行的第 i−1 个数和第 i 个数之和。 (a+b)^n的展开式（二项式展开）中的各项系数依次对应杨辉三角的第 n 行中的每一项。 依据性质 4，我们可以一行一行地计算杨辉三角。每当我们计算出第 i 行的值，我们就可以在线性时间复杂度内计算出第 i+1 行的值。
作者：LeetCode-Solution 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>109.有序链表转换二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Fri, 16 Jul 2021 10:47:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 将给定的有序链表转换为二叉搜索树的第一步是确定根节点。 如何找出这样的一个根节点呢？我们可以找出链表元素的中位数作为根节点的值。
这里对于中位数的定义为：如果链表中的元素个数为奇数，那么唯一的中间值为中位数；如果元素个数为偶数，那么唯二的中间值都可以作为中位数，而不是常规定义中二者的平均值。
根据中位数的性质，链表中小于中位数的元素个数与大于中位数的元素个数要么相等，要么相差 1。此时，小于中位数的元素组成了左子树，大于中位数的元素组成了右子树，它们分别对应着有序链表中连续的一段。
在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中位数作为根节点，以此类推。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>110.平衡二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 14 Jul 2021 16:51:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
示例 1： 3 / \ 9 20 / \ 15 7 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 1 / \ 2 2 / \ 3 3 / \ 4 4 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 提示：
树中的节点数在范围 [0, 5000] 内 -10^4 &amp;lt;= Node.val &amp;lt;= 10^4
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/balanced-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1：自顶向下的递归
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.</description>
    </item>
    
    <item>
      <title>058.最后一个单词的长度</title>
      <link>https://www.pengjielee.cn/post/leetcode/058.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Wed, 14 Jul 2021 15:08:17 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/058.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目 给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
示例 1： 输入：s = &amp;#34;Hello World&amp;#34; 输出：5 示例 2： 输入：s = &amp;#34; &amp;#34; 输出：0 提示：
1 &amp;lt;= s.length &amp;lt;= 10^4 s 仅有英文字母和空格 &amp;rsquo; &amp;rsquo; 组成
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/length-of-last-word 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {string} s * @return {number} */ var lengthOfLastWord = function (s) { //获取最后一个字符的下标 let endIndex = s.length - 1; //如果下标大于等于0，并且最后一个字符等于空字符串 while (endIndex &amp;gt;= 0 &amp;amp;&amp;amp; s[endIndex] == &amp;#34; &amp;#34;) { endIndex--; } if (endIndex &amp;lt; 0) { return 0; } let startIndex = endIndex; while (startIndex &amp;gt;= 0 &amp;amp;&amp;amp; s[startIndex] !</description>
    </item>
    
    <item>
      <title>057.插入区间</title>
      <link>https://www.pengjielee.cn/post/leetcode/057.%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</link>
      <pubDate>Wed, 14 Jul 2021 13:44:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/057.%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</guid>
      <description>题目 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。
在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
示例 1： 输入：intervals = [[1,3],[6,9]], newInterval = [2,5] 输出：[[1,5],[6,9]] 示例 2： 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 输出：[[1,2],[3,10],[12,16]] 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 示例 3： 输入：intervals = [], newInterval = [5,7] 输出：[[5,7]] 示例 4： 输入：intervals = [[1,5]], newInterval = [2,3] 输出：[[1,5]] 示例 5： 输入：intervals = [[1,5]], newInterval = [2,7] 输出：[[1,7]] 提示：
0 &amp;lt;= intervals.length &amp;lt;= 10^4 intervals[i].length == 2 0 &amp;lt;= intervals[i][0] &amp;lt;= intervals[i][1] &amp;lt;= 10^5 intervals 根据 intervals[i][0] 按 升序 排列 newInterval.</description>
    </item>
    
    <item>
      <title>056.合并区间</title>
      <link>https://www.pengjielee.cn/post/leetcode/056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</link>
      <pubDate>Wed, 14 Jul 2021 13:42:47 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</guid>
      <description>题目 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
示例 1： 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示：
1 &amp;lt;= intervals.length &amp;lt;= 104 intervals[i].length == 2 0 &amp;lt;= start(i) &amp;lt;= end(i) &amp;lt;= 104 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-intervals 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {number[][]} intervals * @return {number[][]} */ var merge = function (intervals) { const result = []; //对区间的左端点进行排序（升序） intervals.</description>
    </item>
    
    <item>
      <title>093.复原IP地址</title>
      <link>https://www.pengjielee.cn/post/leetcode/093.%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Wed, 14 Jul 2021 11:20:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/093.%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>097.交错字符串</title>
      <link>https://www.pengjielee.cn/post/leetcode/097.%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 14 Jul 2021 11:19:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/097.%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。
两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：
s = s1 + s2 + &amp;hellip; + sn t = t1 + t2 + &amp;hellip; + tm |n - m| &amp;lt;= 1 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + &amp;hellip; 或者 t1 + s1 + t2 + s2 + t3 + s3 + &amp;hellip; 提示：a + b 意味着字符串 a 和 b 连接。</description>
    </item>
    
    <item>
      <title>099.恢复二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/099.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Wed, 14 Jul 2021 11:18:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/099.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？
示例 1： 1 / \ 3 null / \ null 2 3 / \ 1 null / \ null 2 输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 左孩子，因为 3 &amp;gt; 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： 3 / \ 1 4 / \ / null null 2 2 / \ 1 4 / \ / null null 3 输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 &amp;lt; 3 。交换 2 和 3 使二叉搜索树有效。 提示：</description>
    </item>
    
    <item>
      <title>016.最接近的三数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/016.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Tue, 13 Jul 2021 16:20:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/016.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例：
输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 提示：
3 &amp;lt;= nums.length &amp;lt;= 10^3 -10^3 &amp;lt;= nums[i] &amp;lt;= 10^3 -10^4 &amp;lt;= target &amp;lt;= 10^4
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum-closest 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number} */ /** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function (nums, target) { if (nums.</description>
    </item>
    
    <item>
      <title>Nextjs使用总结</title>
      <link>https://www.pengjielee.cn/post/fe/nextjs%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 30 Jun 2021 14:00:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/nextjs%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
      <description>1、请求数据 topic.js
export default function Topic({ result }) { const data = result &amp;amp;&amp;amp; result.data || []; return ( &amp;lt;ul className=&amp;#34;list&amp;#34;&amp;gt; {data.map(item =&amp;gt; ( &amp;lt;li key={item.id}&amp;gt;{item.title}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; ); } export async function getServerSideProps(context) { const response = await fetch(&amp;#39;https://cnodejs.org/api/v1/topics&amp;#39;); const result = await response.json(); return { props: { result } }; } 2、自定义服务器 1、安装express
$ npm install express 2、创建server.js
const express = require(&amp;#39;express&amp;#39;); const next = require(&amp;#39;next&amp;#39;); const port = parseInt(process.</description>
    </item>
    
    <item>
      <title>Nextjs定制错误页</title>
      <link>https://www.pengjielee.cn/post/fe/nextjs%E5%AE%9A%E5%88%B6%E9%94%99%E8%AF%AF%E9%A1%B5/</link>
      <pubDate>Tue, 22 Jun 2021 15:54:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/nextjs%E5%AE%9A%E5%88%B6%E9%94%99%E8%AF%AF%E9%A1%B5/</guid>
      <description>定制错误页 import Error from &amp;#39;next/error&amp;#39;; export default function Index({ result }) { const { success, data } = result; if (!success) { return &amp;lt;Error statusCode={500} title=&amp;#34;出错了&amp;#34; /&amp;gt;; } return ( &amp;lt;&amp;gt; &amp;lt;style jsx&amp;gt; {` .list { margin: 30px; } `} &amp;lt;/style&amp;gt; &amp;lt;ul className=&amp;#34;list&amp;#34;&amp;gt; {data.map(item =&amp;gt; ( &amp;lt;li key={item.id}&amp;gt;{item.title}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; &amp;lt;/&amp;gt; ); } export async function getServerSideProps(context) { const response = await fetch(&amp;#39;https://cnodejs.org/api/v1/topics&amp;#39;); const result = await response.json(); return { props: { result }, }; } </description>
    </item>
    
    <item>
      <title>Nextjs注入环境变量</title>
      <link>https://www.pengjielee.cn/post/fe/nextjs%E6%B3%A8%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Tue, 22 Jun 2021 15:35:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/nextjs%E6%B3%A8%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description>安装 cross-env $ npm install cross-env --save-dev 使用cross-env注入环境变量 package.json
{ scripts: { &amp;#34;dev&amp;#34;: &amp;#34;next dev&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;next build&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;next start&amp;#34;, &amp;#34;build:test&amp;#34;: &amp;#34;cross-env BUILD_TARGET=test next build&amp;#34;, &amp;#34;build:prod&amp;#34;: &amp;#34;cross-env BUILD_TARGET=prod next build&amp;#34;, }, }; 创建next.config.js文件，并设置env变量 next.config.js
module.exports = { poweredByHeader: false, env: { NEXT_PUBLIC_BUILD_TARGET: process.env[&amp;#39;BUILD_TARGET&amp;#39;], }, }; 默认情况下，所有通过 .env.local 加载的环境变量仅在 Node.js 环境中可用，这意味着它们不会暴露到浏览器端。
为了向浏览器暴露环境变量，你必须在变量前添加 NEXT_PUBLIC_ 前缀。
使用环境变量 let baseURL = &amp;#39;&amp;#39;; switch (process.env.NEXT_PUBLIC_TARGET) { case &amp;#39;test&amp;#39;: baseURL = &amp;#39;https://test.***.com&amp;#39;; break; case &amp;#39;prod&amp;#39;: baseURL = &amp;#39;https://m.</description>
    </item>
    
    <item>
      <title>Nextjs使用wangeditor</title>
      <link>https://www.pengjielee.cn/post/fe/nextjs%E4%BD%BF%E7%94%A8wangeditor%E7%BC%96%E8%BE%91%E5%99%A8/</link>
      <pubDate>Tue, 22 Jun 2021 15:18:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/nextjs%E4%BD%BF%E7%94%A8wangeditor%E7%BC%96%E8%BE%91%E5%99%A8/</guid>
      <description>安装 $ npm install wangeditor-for-react React中使用 import { useState } from &amp;#34;react&amp;#34;; import ReactWEditor from &amp;#34;wangeditor-for-react&amp;#34;; function Editor() { const [value, setValue] = useState(&amp;#34;&amp;#34;); return &amp;lt;ReactWEditor defaultValue={value} onChange={setValue} /&amp;gt;; } export default Editor; Nextjs中使用 import { useState } from &amp;#34;react&amp;#34;; import dynamic from &amp;#34;next/dynamic&amp;#34;; const ReactWEditor = dynamic(import(&amp;#34;wangeditor-for-react&amp;#34;), { ssr: false, loading: () =&amp;gt; &amp;lt;p&amp;gt;Loading ...&amp;lt;/p&amp;gt;, }); const config = { height: 500, menus: [&amp;#34;bold&amp;#34;, &amp;#34;link&amp;#34;, &amp;#34;image&amp;#34;], showFullScreen: true, customUploadImg: function (resultFiles, insertImgFn) { // 获取上传的文件 const file = resultFiles[0]; // 上传图片，返回结果，将图片插入到编辑器中 insertImgFn(&amp;#39;imgUrl&amp;#39;); }, }; function Editor() { const [value, setValue] = useState(&amp;#34;&amp;#34;); return ( &amp;lt;ReactWEditor config={config} defaultValue={value} onChange={setValue} &amp;gt;&amp;lt;/ReactWEditor&amp;gt; ); }; export default Editor; More wangeditor-for-react</description>
    </item>
    
    <item>
      <title>Nextjs使用react-quill编辑器</title>
      <link>https://www.pengjielee.cn/post/fe/nextjs%E4%BD%BF%E7%94%A8react-quill%E7%BC%96%E8%BE%91%E5%99%A8/</link>
      <pubDate>Tue, 22 Jun 2021 14:53:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/nextjs%E4%BD%BF%E7%94%A8react-quill%E7%BC%96%E8%BE%91%E5%99%A8/</guid>
      <description>安装 $ npm install react-quill --save // or $ yarn add react-quill React中使用 import React, { useState } from &amp;#34;react&amp;#34;; import ReactQuill from &amp;#34;react-quill&amp;#34;; import &amp;#34;react-quill/dist/quill.snow.css&amp;#34;; function MyComponent() { const [value, setValue] = useState(&amp;#34;&amp;#34;); return &amp;lt;ReactQuill theme=&amp;#34;snow&amp;#34; value={value} onChange={setValue} /&amp;gt;; } Nextjs中使用 import dynamic from &amp;#34;next/dynamic&amp;#34;; import &amp;#34;react-quill/dist/quill.snow.css&amp;#34;; const QuillNoSSRWrapper = dynamic(import(&amp;#34;react-quill&amp;#34;), { ssr: false, loading: () =&amp;gt; &amp;lt;p&amp;gt;Loading ...&amp;lt;/p&amp;gt;, }); const modules = { toolbar: [[{ header: 1 }, &amp;#34;bold&amp;#34;, { color: [] }], [&amp;#34;clean&amp;#34;]], }; export default function Editor(props) { const [value, setValue] = useState(&amp;#34;&amp;#34;); return ( &amp;lt;QuillNoSSRWrapper theme=&amp;#34;snow&amp;#34; value={value} modules={modules} onChange={setValue} /&amp;gt; ); } 封装组件 import dynamic from &amp;#34;next/dynamic&amp;#34;; import &amp;#34;react-quill/dist/quill.</description>
    </item>
    
    <item>
      <title>Nextjs配置antd语言包</title>
      <link>https://www.pengjielee.cn/post/fe/nextjs%E9%85%8D%E7%BD%AEantd%E8%AF%AD%E8%A8%80%E5%8C%85/</link>
      <pubDate>Tue, 22 Jun 2021 14:47:23 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/nextjs%E9%85%8D%E7%BD%AEantd%E8%AF%AD%E8%A8%80%E5%8C%85/</guid>
      <description>需求 antd 目前的默认文案是英文，我们需要使用中文。
nextjs自定义 App 创建./pages/_app.js
function MyApp({ Component, pageProps }) { return ( &amp;lt;Component {...pageProps} /&amp;gt; ); } export default MyApp 安装antd $ npm install antd --save # or $ yarn add antd 配置 import { ConfigProvider } from &amp;#39;antd&amp;#39;; import zhCN from &amp;#39;antd/lib/locale/zh_CN&amp;#39;; function MyApp({ Component, pageProps }) { return ( &amp;lt;ConfigProvider locale={zhCN}&amp;gt; &amp;lt;Component {...pageProps} /&amp;gt; &amp;lt;/ConfigProvider&amp;gt; ); } export default MyApp; More antd 国际化
https://ant.design/docs/react/i18n-cn
自定义 App</description>
    </item>
    
    <item>
      <title>Nginx启动出错</title>
      <link>https://www.pengjielee.cn/post/other/nginx%E5%90%AF%E5%8A%A8%E5%87%BA%E9%94%99/</link>
      <pubDate>Fri, 28 May 2021 14:22:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/nginx%E5%90%AF%E5%8A%A8%E5%87%BA%E9%94%99/</guid>
      <description>环境 系统：Mac
查看nginx目录 which nginx output
/usr/local/bin/nginx 检查nginx配置文件语法是否有错 sudo /usr/local/bin/nginx -t output
nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok nginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful 查看80端口占用 sudo lsof -i:80 查看nginx错误日志 查看配置文件
cat /usr/local/etc/nginx/nginx.conf 查看nginx配置的错误日志目录
#user nobody; worker_processes 1; error_log /usr/local/etc/nginx/logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } 打开错误日志文件
vi /usr/local/etc/nginx/logs/error.log 跳到最后一行
shift + g 管理nginx服务 brew services list brew services stop nginx brew services start nginx brew services restart nginx nginx错误日志 1、[emerg] 33511#0: open() &amp;ldquo;/usr/local/var/run/nginx.</description>
    </item>
    
    <item>
      <title>189.旋转数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 26 May 2021 11:00:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 提示：
1 &amp;lt;= nums.length &amp;lt;= 2 * 104 -2^31 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1 0 &amp;lt;= k &amp;lt;= 10^5 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>350.两个数组的交集II</title>
      <link>https://www.pengjielee.cn/post/leetcode/350._%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86ii/</link>
      <pubDate>Wed, 26 May 2021 10:34:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/350._%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86ii/</guid>
      <description>题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明：
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 1、哈希表
由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。
首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersect = function (nums1, nums2) { const len1 = nums1.length; const len2 = nums2.</description>
    </item>
    
    <item>
      <title>217.存在重复元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 26 May 2021 10:19:20 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid>
      <description>题目 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {boolean} */ var containsDuplicate = function (nums) { const map = new Map(); for (let i = 0; i &amp;lt; nums.length; i++) { //如果数不存在，设置默认出现次数为0 if (!map.has(nums[i])) { map.set(nums[i], 0); } //如果数已存在，出现次数+1 const number = map.</description>
    </item>
    
    <item>
      <title>使用curl发送请求</title>
      <link>https://www.pengjielee.cn/post/other/%E4%BD%BF%E7%94%A8curl%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Fri, 21 May 2021 11:48:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/%E4%BD%BF%E7%94%A8curl%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/</guid>
      <description>get请求 curl https://cnodejs.org/api/v1/topics post请求 1、application/x-www-form-urlencoded
curl -d&amp;#39;username=admin&amp;amp;password=123456&amp;#39; -X POST http://localhost:8080/api/user/login 2、application/json
curl http://localhost:8080/api/user/login -X POST -d &amp;#39;{&amp;#34;username&amp;#34;: &amp;#34;100&amp;#34;,&amp;#34;password&amp;#34;:&amp;#34;123456&amp;#34;}&amp;#39; --header &amp;#34;Content-Type: application/json&amp;#34; 设置header curl -H &amp;#39;Authorization:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&amp;#39; http://localhost:8080/api/user/list 参数 -d 参数用于发送 POST 请求的数据体。 -H 参数添加 HTTP 请求的标头。 -X 参数指定 HTTP 请求的方法。 More Curl Cookbook
https://catonmat.net/cookbooks/curl</description>
    </item>
    
    <item>
      <title>ES6之Number</title>
      <link>https://www.pengjielee.cn/post/fe/es6%E4%B9%8Bnumber/</link>
      <pubDate>Thu, 20 May 2021 10:18:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/es6%E4%B9%8Bnumber/</guid>
      <description>Number.MAX_SAFE_INTEGER Number.MAX_SAFE_INTEGER 常量表示在 JavaScript 中最大的安全整数（maxinum safe integer)（2^53 - 1）
console.log(Number.MAX_SAFE_INTEGER); //9007199254740991 console.log(Math.pow(2,53) - 1); //9007199254740991 Number.MIN_SAFE_INTEGER Number.MIN_SAFE_INTEGER 代表在 JavaScript 中最小的安全的integer型数字 (-(2^53 - 1)).
console.log(Number.MIN_SAFE_INTEGER); //-9007199254740991 console.log(-(Math.pow(2,53) - 1)); //-9007199254740991 2^53 是 js 内置的最大的整数值（不安全），2^53 + 1 会被舍入成 2^53：
Math.pow(2, 53) === Math.pow(2, 53) + 1; // true Math.pow(2, 53) === Math.pow(2, 53) + 2; // false Number.isSafeInteger() Number.isSafeInteger() 方法用来判断传入的参数值是否是一个“安全整数”（safe integer）。
一个安全整数是一个符合下面条件的整数：
可以准确地表示为一个IEEE-754双精度数字, 其IEEE-754表示不能是舍入任何其他整数以适应IEEE-754表示的结果。 安全整数范围为 -(2^53 - 1)到 2^53 - 1 之间的整数，包含 -(2^53 - 1)和 2^53 - 1。</description>
    </item>
    
    <item>
      <title>ES6解构赋值</title>
      <link>https://www.pengjielee.cn/post/fe/es6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Thu, 20 May 2021 09:31:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/es6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</guid>
      <description>ES6数组解构赋值 1、基本
let [a, b, c] = [1, 2, 3]; // a = 1, b = 2, c = 3 2、嵌套
let [a, [[b], c]] = [1, [[2], 3]]; // a = 1, b = 2, c = 3 3、可忽略
let [a, , b] = [1, 2, 3]; // a = 1, b = 2 4、不完全解构
let [a = 1, b] = []; // a = 1, b = undefined 5、剩余运算符</description>
    </item>
    
    <item>
      <title>297.二叉树的序列化与反序列化</title>
      <link>https://www.pengjielee.cn/post/leetcode/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 19 May 2021 13:22:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
示例 1： 输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[1,2] 提示：
树中结点数在范围 [0, 10^4] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。
众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。
1、广度优先搜索可以按照层次的顺序从上到下遍历所有的节点；
2、深度优先搜索可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将深度优先搜索策略区分为：
先序遍历 中序遍历 后序遍历 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.</description>
    </item>
    
    <item>
      <title>380.常数时间插入、删除和获取随机元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/380.%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 19 May 2021 11:18:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/380.%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</guid>
      <description>题目 设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。
insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :
// 初始化一个空的集合。 RandomizedSet randomSet = new RandomizedSet(); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。 randomSet.insert(1); // 返回 false ，表示集合中不存在 2 。 randomSet.remove(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。 randomSet.insert(2); // getRandom 应随机返回 1 或 2 。 randomSet.getRandom(); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。 randomSet.remove(1); // 2 已在集合中，所以返回 false 。 randomSet.insert(2); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。 randomSet.</description>
    </item>
    
    <item>
      <title>洗牌算法</title>
      <link>https://www.pengjielee.cn/post/algorithm/23.%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 19 May 2021 09:42:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/23.%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</guid>
      <description>Fisher–Yates shuffle 核心思想是从1到n之间随机取出一个数和最后一个数(n)交换，然后从1到n-1之间随机取出一个数和倒数第二个数(n-1)交换&amp;hellip;
步骤：
写下从 1 到 N 的数字 取一个从 1 到剩下的数字（包括这个数字）的随机数 k 从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位 重复第 2 步，直到所有的数字都被取出 第 3 步写出的这个序列，现在就是原始数字的随机排列 经典实现 步骤：
给定一组待混排的有限序列P 新初始化一个空的序列Q 从P中随机选取一个元素 将该元素放到序列Q的最后面，并从序列P中移除该元素 重复3-4的步骤，直到序列P中元素全部选取到了序列Q中，得到的序列Q即为一组P的混排序列 参考代码：
function shuffle(array) { if (!Array.isArray(array)) { return []; } // 初始化序列 const result = []; for (let i = array.length; i &amp;gt; 0; i--) { //随机生成索引 const idx = Math.floor(Math.random() * i); //将该元素加入序列 result.push(array[idx]); //从数组中移除该元素 array.splice(idx, 1); } return result; }; 流行实现 步骤：</description>
    </item>
    
    <item>
      <title>322.零钱兑换</title>
      <link>https://www.pengjielee.cn/post/leetcode/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</link>
      <pubDate>Tue, 18 May 2021 14:21:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</guid>
      <description>题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
你可以认为每种硬币的数量是无限的。
示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 输入：coins = [2], amount = 3 输出：-1 示例 3： 输入：coins = [1], amount = 0 输出：0 示例 4： 输入：coins = [1], amount = 1 输出：1 示例 5： 输入：coins = [1], amount = 2 输出：2 提示：
1 &amp;lt;= coins.length &amp;lt;= 12 1 &amp;lt;= coins[i] &amp;lt;= 2^31 - 1 0 &amp;lt;= amount &amp;lt;= 10^4 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>300.最长递增子序列</title>
      <link>https://www.pengjielee.cn/post/leetcode/300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Tue, 18 May 2021 13:44:23 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>题目 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1 提示：
1 &amp;lt;= nums.length &amp;lt;= 2500 -10^4 &amp;lt;= nums[i] &amp;lt;= 10^4 进阶：
你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗? 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-increasing-subsequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 子序列和子串：
子序列（subsequence）：子序列并不要求连续，例如：序列 [4, 6, 5] 是 [1, 2, 4, 3, 7, 6, 5] 的一个子序列； 子串（substring、subarray）：子串一定是原始字符串的连续子串。 定义状态：
定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</description>
    </item>
    
    <item>
      <title>062.不同路径</title>
      <link>https://www.pengjielee.cn/post/leetcode/062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 18 May 2021 11:54:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
解决： 示例 1： 输入：m = 3, n = 7 输出：28 示例 2： 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&amp;gt; 向下 -&amp;gt; 向下 2. 向下 -&amp;gt; 向下 -&amp;gt; 向右 3. 向下 -&amp;gt; 向右 -&amp;gt; 向下 示例 3： 输入：m = 7, n = 3 输出：28 示例 4： 输入：m = 3, n = 3 输出：6 提示：</description>
    </item>
    
    <item>
      <title>055.跳跃游戏</title>
      <link>https://www.pengjielee.cn/post/leetcode/055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Tue, 18 May 2021 11:09:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</guid>
      <description>题目 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
示例 1： 输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示：
1 &amp;lt;= nums.length &amp;lt;= 3 * 10^4 0 &amp;lt;= nums[i] &amp;lt;= 10^5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jump-game 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {number[]} nums * @return {boolean} */ var canJump = function (nums) { //数组的长度 const n = nums.</description>
    </item>
    
    <item>
      <title>018.四数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Wed, 12 May 2021 11:06:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
注意：答案中不可以包含重复的四元组。
示例 1： 输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 输入：nums = [], target = 0 输出：[] 提示：
0 &amp;lt;= nums.length &amp;lt;= 200 -10^9 &amp;lt;= nums[i] &amp;lt;= 10^9 -10^9 &amp;lt;= target &amp;lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/4sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number[][]} */ var fourSum = function (nums, target) { const result = [``]; //如果小于4个数，直接返回空数组 if (nums.</description>
    </item>
    
    <item>
      <title>690.员工的重要性</title>
      <link>https://www.pengjielee.cn/post/leetcode/690.%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Wed, 12 May 2021 10:32:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/690.%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>题目 给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。
比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。
示例：
输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 输出：11 解释： 员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。 提示：</description>
    </item>
    
    <item>
      <title>199.二叉树的右视图</title>
      <link>https://www.pengjielee.cn/post/leetcode/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Wed, 12 May 2021 09:50:56 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例:
输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-right-side-view 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、BFS
利用BFS进行层次遍历，记录下每层的最后一个元素。
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var rightSideView = function (root) { const result = []; if (root === null) { return result; } //队列特点：先进先出 const q = []; //入队根节点 q.</description>
    </item>
    
    <item>
      <title>771.宝石与石头</title>
      <link>https://www.pengjielee.cn/post/leetcode/771.%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</link>
      <pubDate>Tue, 11 May 2021 16:50:34 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/771.%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</guid>
      <description>题目 给定字符串 J 代表石头中宝石的类型，和字符串 S 代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J 中的字母不重复，J 和 S 中的所有字符都是字母。字母区分大小写，因此&amp;quot;a&amp;quot;和&amp;quot;A&amp;quot;是不同类型的石头。
示例 1: 输入: J = &amp;#34;aA&amp;#34;, S = &amp;#34;aAAbbbb&amp;#34; 输出: 3 示例 2: 输入: J = &amp;#34;z&amp;#34;, S = &amp;#34;ZZ&amp;#34; 输出: 0 注意:
S 和 J 最多含有50个字母。 J 中的字符不重复。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jewels-and-stones 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} jewels * @param {string} stones * @return {number} */ var numJewelsInStones = function (jewels, stones) { // 转换为Set const jewelsSet = new Set(jewels.</description>
    </item>
    
    <item>
      <title>535.TinyURL的加密与解密</title>
      <link>https://www.pengjielee.cn/post/leetcode/535.tinyurl%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Tue, 11 May 2021 16:39:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/535.tinyurl%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</guid>
      <description>题目 TinyURL是一种URL简化服务， 比如：当你输入一个URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk.
要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/encode-and-decode-tinyurl 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Encodes a URL to a shortened URL. * * @param {string} longUrl * @return {string} */ /** * Decodes a shortened URL to its original URL. * * @param {string} shortUrl * @return {string} */ var i = 0; var map = new Map(); var encode = function (longUrl) { map.set(i, longUrl); return &amp;#34;http://tinyurl.</description>
    </item>
    
    <item>
      <title>463.岛屿的周长</title>
      <link>https://www.pengjielee.cn/post/leetcode/463.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</link>
      <pubDate>Tue, 11 May 2021 15:44:00 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/463.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</guid>
      <description>题目 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。
网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
示例 1： 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] 输出：16 解释：它的周长是上面图片中的 16 个黄色的边 示例 2： 输入：grid = [[1]] 输出：4 示例 3： 输入：grid = [[1,0]] 输出：4 提示：
row == grid.length col == grid[i].length 1 &amp;lt;= row, col &amp;lt;= 100 grid[i][j] 为 0 或 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/island-perimeter 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 1）加入答案 ans 中即可。</description>
    </item>
    
    <item>
      <title>617.合并二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 11 May 2021 10:26:10 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
示例 1:
输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-binary-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.</description>
    </item>
    
    <item>
      <title>KK的99个建议</title>
      <link>https://www.pengjielee.cn/post/other/kk%E7%9A%8499%E4%B8%AA%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Mon, 10 May 2021 16:44:42 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/kk%E7%9A%8499%E4%B8%AA%E5%BB%BA%E8%AE%AE/</guid>
      <description>99 Additional Bits of Unsolicited Advice I have another birthday, and another bunch of unsolicited advice.
• That thing that made you weird as a kid could make you great as an adult — if you don’t lose it.
那些让你小时候很怪异的东西，可以让你成年后变得很棒——如果你不失去它的话。
• If you have any doubt at all about being able to carry a load in one trip, do yourself a huge favor and make two trips.
• What you get by achieving your goals is not as important as what you become by achieving your goals.</description>
    </item>
    
    <item>
      <title>KK的68个建议</title>
      <link>https://www.pengjielee.cn/post/other/kk%E7%9A%8468%E4%B8%AA%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Mon, 10 May 2021 16:42:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/kk%E7%9A%8468%E4%B8%AA%E5%BB%BA%E8%AE%AE/</guid>
      <description>68 Bits of Unsolicited Advice It’s my birthday. I’m 68. I feel like pulling up a rocking chair and dispensing advice to the young ‘uns. Here are 68 pithy bits of unsolicited advice which I offer as my birthday present to all of you. (For my 69th birthday I made another batch.)
• Learn how to learn from those you disagree with, or even offend you. See if you can find the truth in what they believe.</description>
    </item>
    
    <item>
      <title>064.最小路径和</title>
      <link>https://www.pengjielee.cn/post/leetcode/064.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Mon, 10 May 2021 13:17:33 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/064.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description>题目 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示：
m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= grid[i][j] &amp;lt;= 100 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 1、设置状态。
令dp[i][j]表示走到(i,j)点的最小路径和。
2、状态转移方程。
如何求出dp[i][j]？
由于每次只能往右走或者下走。换言之，当前单元格dp[i][j]的前继状态只有dp[i-1][j],dp[i][j-1]，所以我们在两者取最小，然后加上当前格子内的数即可。
走到当前单元格(i,j)的最小路径和 = 【从左方单元格 (i-1,j) 与 从上方单元格 (i,j−1) 走来的 两个最小路径和中较小的】 + 当前单元格值 grid[i][j]
dp(i,j) = grid(i,j) + min(dp(i-1,j),dp(i,j-1)) 具体分以下4种情况:
当左边和上边都不是矩阵边界时：即 i!</description>
    </item>
    
    <item>
      <title>125.验证回文串</title>
      <link>https://www.pengjielee.cn/post/leetcode/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Sat, 08 May 2021 10:31:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1: 输入: &amp;#34;A man, a plan, a canal: Panama&amp;#34; 输出: true 示例 2: 输入: &amp;#34;race a car&amp;#34; 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
知识点 charCodeAt()
charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
charAt()
方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。
&amp;#39;a&amp;#39;.charCodeAt(); //97 &amp;#39;b&amp;#39;.charCodeAt(); //98 ... &amp;#39;z&amp;#39;.charCodeAt(); //122 (97+26-1=122) &amp;#39;A&amp;#39;.charCodeAt(); //65 &amp;#39;B&amp;#39;.charCodeAt(); //66 ... &amp;#39;Z&amp;#39;.charCodeAt(); //90 (65+26-1=90) &amp;#39;0&amp;#39;.charCodeAt(); //48 &amp;#39;1&amp;#39;.charCodeAt(); //49 &amp;#39;9&amp;#39;.charCodeAt(); //57 (48+10-1=57) JS实现 /** * @param {string} s * @return {boolean} */ var isPalindrome = (str) =&amp;gt; { // 字符串转为小写 str = str.</description>
    </item>
    
    <item>
      <title>154.寻找旋转排序数组中的最小值II</title>
      <link>https://www.pengjielee.cn/post/leetcode/154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/</link>
      <pubDate>Fri, 07 May 2021 14:32:47 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/</guid>
      <description>题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], &amp;hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], &amp;hellip;, a[n-2]] 。
给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
示例 1： 输入：nums = [1,3,5] 输出：1 示例 2： 输入：nums = [2,2,2,0,1] 输出：0 提示：
n == nums.length 1 &amp;lt;= n &amp;lt;= 5000 -5000 &amp;lt;= nums[i] &amp;lt;= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶：</description>
    </item>
    
    <item>
      <title>153.寻找旋转排序数组中的最小值</title>
      <link>https://www.pengjielee.cn/post/leetcode/153.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</link>
      <pubDate>Fri, 07 May 2021 14:32:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/153.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</guid>
      <description>题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], &amp;hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], &amp;hellip;, a[n-2]] 。
给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
示例 1： 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2： 输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3： 输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示：</description>
    </item>
    
    <item>
      <title>033.搜索旋转排序数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 07 May 2021 13:32:39 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2： 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3： 输入：nums = [1], target = 0 输出：-1 提示：</description>
    </item>
    
    <item>
      <title>081.搜索旋转排序数组II</title>
      <link>https://www.pengjielee.cn/post/leetcode/081.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</link>
      <pubDate>Fri, 07 May 2021 13:28:20 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/081.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</guid>
      <description>题目 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
示例 1： 输入：nums = [2,5,6,0,0,1,2], target = 0 输出：true 示例 2： 输入：nums = [2,5,6,0,0,1,2], target = 3 输出：false 提示：
1 &amp;lt;= nums.length &amp;lt;= 5000 -10^4 &amp;lt;= nums[i] &amp;lt;= 10^4 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -10^4 &amp;lt;= target &amp;lt;= 10^4 进阶：</description>
    </item>
    
    <item>
      <title>034.在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://www.pengjielee.cn/post/leetcode/034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Fri, 07 May 2021 11:41:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</guid>
      <description>题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例：
示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示：
0 &amp;lt;= nums.length &amp;lt;= 10^5 -10^9 &amp;lt;= nums[i] &amp;lt;= 10^9 nums 是一个非递减数组 -10^9 &amp;lt;= target &amp;lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、
/** * @param {number[]} nums * @param {number} target * @return {number[]} */ // 查找第一个等于给定值的元素 const binarySearchFirst = (arr, target) =&amp;gt; { let low = 0, high = arr.</description>
    </item>
    
    <item>
      <title>540.有序数组中的单一元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/540.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 06 May 2021 11:35:08 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/540.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/</guid>
      <description>题目 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
示例 1: 输入: [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2: 输入: [3,3,7,7,10,11,11] 输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、位运算
/** * @param {number[]} nums * @return {number} */ var singleNonDuplicate = function (nums) { let result = nums[0]; for (let i = 1; i &amp;lt; nums.length; i++) { result = result ^ nums[i]; } return result; }; 2、二分搜索
我们的数组个数始终是奇数，因为有一个元素出现一次，其余元素出现两次。
var singleNonDuplicate = function (nums) { let low = 0, high = nums.</description>
    </item>
    
    <item>
      <title>633.平方数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/633.%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 06 May 2021 10:28:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/633.%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c 。
示例 1： 输入：c = 5 输出：true 解释：1 * 1 + 2 * 2 = 5 示例 2： 输入：c = 3 输出：false 示例 3： 输入：c = 4 输出：true 解释：0 * 0 + 2 * 2 = 4 示例 4： 输入：c = 2 输出：true 解释：1 * 1 + 1 * 1= 2 示例 5： 输入：c = 1 输出：true 解释：0 * 0 + 1 * 1 = 1 提示： 0 &amp;lt;= c &amp;lt;= 2^31 - 1</description>
    </item>
    
    <item>
      <title>680.验证回文字符串II</title>
      <link>https://www.pengjielee.cn/post/leetcode/680.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 06 May 2021 09:58:17 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/680.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
示例 1: 输入: &amp;#34;aba&amp;#34; 输出: True 示例 2: 输入: &amp;#34;abca&amp;#34; 输出: True 解释: 你可以删除c字符。 注意:
字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {boolean} */ var validPalindrome = function (s) { // 双指针，一个指向字符串开头，一个指向字符串末尾 let i = 0, j = s.length - 1; // 判断是否是回文串 const isPalindrome = (low, high) =&amp;gt; { while (low &amp;lt; high) { if (s.charAt(low) != s.charat(high)) { return false; } low++; high--; } return true; }; while (i &amp;lt; j) { // 字符串开头与末尾不相等 if (s.</description>
    </item>
    
    <item>
      <title>524.通过删除字母匹配到字典里最长单词</title>
      <link>https://www.pengjielee.cn/post/leetcode/524._%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Thu, 06 May 2021 09:22:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/524._%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</guid>
      <description>题目 给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。
示例 1: 输入: s = &amp;#34;abpcplea&amp;#34;, d = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] 输出: &amp;#34;apple&amp;#34; 示例 2: 输入: s = &amp;#34;abpcplea&amp;#34;, d = [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出: &amp;#34;a&amp;#34; 说明:
所有输入的字符串只包含小写字母。 字典的大小不会超过 1000。 所有输入的字符串长度不会超过 1000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @param {string[]} dictionary * @return {string} */ var findLongestWord = function (s, dictionary) { let result = &amp;#34;&amp;#34;; // 遍历字典 for (let dstr of dictionary) { // 定义两个指针i,j，i用来指向整个字符串s，j用来指向字符串dstr for (let i = 0, j = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>004.寻找两个正序数组的中位数</title>
      <link>https://www.pengjielee.cn/post/leetcode/004.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Thu, 29 Apr 2021 09:07:10 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/004.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>题目 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.</description>
    </item>
    
    <item>
      <title>堆排序</title>
      <link>https://www.pengjielee.cn/post/algorithm/22.%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 28 Apr 2021 15:53:10 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/22.%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>堆排序 1、参考代码
class HeapSort { //建堆 buildHeap(array) { //下标为0的位置保留 const arr = [0].concat(array); for (let i = arr.length; i &amp;gt; 0; i--) { this._heapify(arr, arr.length, i); } return arr; } // 排序 sort(array) { const arr = this.buildHeap(array); // 先建堆 let len = arr.length - 1; while (len &amp;gt; 1) { this._swap(arr, 1, len); // 交换顶元素和最后一位。顶元素永远是最大的。 len--; this._heapify(arr, len, 1); //剩下的元素重新建堆 直到len === 1 停止 } return arr.slice(1); } // 堆化（构建大顶堆） _heapify(arr, len, i) { while (true) { let maxPos = i; // 如果index i拥有叶左节点 并且左节点较大 if (i * 2 &amp;lt;= len &amp;amp;&amp;amp; arr[i] &amp;lt; arr[i * 2]) { maxPos = i * 2; } // 如果index i拥有叶右节点 与Max节点比较大小，选出父/左/右中最大的一个 if (i * 2 + 1 &amp;lt;= len &amp;amp;&amp;amp; arr[maxPos] &amp;lt; arr[i * 2 + 1]) { maxPos = i * 2 + 1; } if (maxPos === i) break; // 循环直到i节点为最大值 this.</description>
    </item>
    
    <item>
      <title>堆</title>
      <link>https://www.pengjielee.cn/post/algorithm/21.%E5%A0%86/</link>
      <pubDate>Wed, 28 Apr 2021 10:03:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/21.%E5%A0%86/</guid>
      <description>理解堆 堆是一个完全二叉树； 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值； 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。
几个例子：
堆1：大顶堆 10 / \ 9 8 /\ /\ 6 5 7 4 / 3 堆2：大顶堆 10 / \ 8 9 /\ /\ 7 3 5 6 / 4 堆3：小顶堆 3 / \ 4 6 /\ /\ 5 8 9 10 / 7 堆的存储及操作 1、堆的存储
完全二叉树适合用数组来存储。
7 / \ 5 6 / \ / 4 2 1 用数组来存储： arr = [, 7, 5, 6, 4, 2, 1] idx = 0 1 2 3 4 5 6 - 数组下标为0的位置置空； - 数组中下标为i的节点的左子节点，就是下标为i* 2的节点，右子节点就是下标为i*2+1的节点，父节点就是下标为i/2的节点。 2、往堆中插入元素</description>
    </item>
    
    <item>
      <title>451.根据字符出现频率排序</title>
      <link>https://www.pengjielee.cn/post/leetcode/451.%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 27 Apr 2021 17:32:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/451.%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</guid>
      <description>题目 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1: 输入: &amp;#34;tree&amp;#34; 输出: &amp;#34;eert&amp;#34; 解释: &amp;#39;e&amp;#39;出现两次，&amp;#39;r&amp;#39;和&amp;#39;t&amp;#39;都只出现一次。 因此&amp;#39;e&amp;#39;必须出现在&amp;#39;r&amp;#39;和&amp;#39;t&amp;#39;之前。此外，&amp;#34;eetr&amp;#34;也是一个有效的答案。 示例 2: 输入: &amp;#34;cccaaa&amp;#34; 输出: &amp;#34;cccaaa&amp;#34; 解释: &amp;#39;c&amp;#39;和&amp;#39;a&amp;#39;都出现三次。此外，&amp;#34;aaaccc&amp;#34;也是有效的答案。 注意&amp;#34;cacaca&amp;#34;是不正确的，因为相同的字母必须放在一起。 示例 3: 输入: &amp;#34;Aabb&amp;#34; 输出: &amp;#34;bbAa&amp;#34; 解释: 此外，&amp;#34;bbaA&amp;#34;也是一个有效的答案，但&amp;#34;Aabb&amp;#34;是不正确的。 注意&amp;#39;A&amp;#39;和&amp;#39;a&amp;#39;被认为是两种不同的字符。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-characters-by-frequency 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、桶排序
/** * @param {string} s * @return {string} */ var frequencySort = function (s) { const result = []; // 使用hashmap统计每个字符出现的次数 const hashmap = new Map(); for (let ch of s) { if (!hashmap.has(ch)) { hashmap.set(ch, 0); } hashmap.</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://www.pengjielee.cn/post/algorithm/20.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 27 Apr 2021 16:57:10 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/20.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>实现1 var division = (list, left, right) =&amp;gt; { // 以最左边的数(left)为基准 var base = list[left]; while (left &amp;lt; right) { // 从序列右端开始，向左遍历，直到找到小于base的数 while (left &amp;lt; right &amp;amp;&amp;amp; list[right] &amp;gt;= base) { right--; } // 找到了比base小的元素，将这个元素放到最左边的位置 list[left] = list[right]; // 从序列左端开始，向右遍历，直到找到大于base的数 while (left &amp;lt; right &amp;amp;&amp;amp; list[left] &amp;lt;= base) { left++; } // 找到了比base大的元素，将这个元素放到最右边的位置 list[right] = list[left]; } // 最后将base放到left位置。此时，left位置的左侧数值应该都比left小； // 而left位置的右侧数值应该都比left大。 list[left] = base; return left; }; var sort = (list, left, right) =&amp;gt; { // 左下标一定小于右下标，否则就越界了 if (left &amp;lt; right) { // 对数组进行分割，取出下次分割的基准标号 var base = division(list, left, right); // 对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序 sort(list, left, base - 1); // 对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序 sort(list, base + 1, right); } }; var quickSort = (arr) =&amp;gt; { sort(arr, 0, arr.</description>
    </item>
    
    <item>
      <title>215.数组中的第K个最大元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Tue, 27 Apr 2021 16:38:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>题目 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 解释：排序后：1,2,3,4,5,6，第2大元素是5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 解释：排序后：1,2,2,3,3,4,5,5,6，第4大元素是4 说明:
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、暴力解法
使用内置函数sort函数实现；
把元素从大到小排序，然后返回下标为k-1的元素。
/** * @param {number[]} nums * @param {number} k * @return {number} */ var findKthLargest = function(nums, k) { nums = nums.sort((a,b) =&amp;gt; b - a); return nums[k-1]; }; 2、快速选择</description>
    </item>
    
    <item>
      <title>409.最长回文串</title>
      <link>https://www.pengjielee.cn/post/leetcode/409.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Tue, 27 Apr 2021 11:36:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/409.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>题目 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。
在构造过程中，请注意区分大小写。比如 &amp;ldquo;Aa&amp;rdquo; 不能当做一个回文字符串。
注意: 假设字符串的长度不会超过 1010。
示例 1:
输入: &amp;#34;abccccdd&amp;#34; 输出: 7 解释: 我们可以构造的最长的回文串是&amp;#34;dccaccd&amp;#34;, 它的长度是 7。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 回文串： 正读和反读都相同的字符序列为回文串。
奇数个字符的回文串： 除中间字符以外，其他字符镜面对称（即其他字符都出现偶数次）。
偶数个字符的回文串： 所有字符镜面对称（即所有字符都出现偶数次）。
回文串的本质： 可能除去一个字符以外)其他的字母都出现偶数次。
最长回文串的构成： 使所有字母尽可能多的出现偶数次 + 1次（如果此时还有字母没用完）。
JS实现 参考实现1：
/** * @param {string} s * @return {number} */ var longestPalindrome = function (s) { let result = 0; // 为奇数的标识 let odd_mark = false; // 创建长度为58的数组，默认填充0，存放每个字母出现的次数 // A-Z, 65-90; a-z, 97-122 // 长度为58（26个英文小写字母+26个英文大写字母+大写Z与小写a中间的6个字符） const numbers = new Array(58).</description>
    </item>
    
    <item>
      <title>003.无重复字符的最长子串</title>
      <link>https://www.pengjielee.cn/post/leetcode/003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 27 Apr 2021 10:57:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1: 输入: s = &amp;#34;abcabcbb&amp;#34; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。 示例 2: 输入: s = &amp;#34;bbbbb&amp;#34; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。 示例 3: 输入: s = &amp;#34;pwwkew&amp;#34; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。 示例 4: 输入: s = &amp;#34;&amp;#34; 输出: 0 提示：
0 &amp;lt;= s.length &amp;lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function (s) { // hashmap，记录每个字符是否出现过 const map = new Map(); // 无重复字符最长子串的左边界 let left = 0; // 无重复字符最长子串的长度 let max = 0; // 遍历字符串 for (let i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>205.同构字符串</title>
      <link>https://www.pengjielee.cn/post/leetcode/205.%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 27 Apr 2021 10:40:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/205.%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
示例 1: 输入：s = &amp;#34;egg&amp;#34;, t = &amp;#34;add&amp;#34; 输出：true 示例 2： 输入：s = &amp;#34;foo&amp;#34;, t = &amp;#34;bar&amp;#34; 输出：false 示例 3： 输入：s = &amp;#34;paper&amp;#34;, t = &amp;#34;title&amp;#34; 输出：true 提示：
可以假设 s 和 t 长度相同。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/isomorphic-strings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。
我们维护两张哈希表，第一张哈希表 s2t 以 s 中字符为键，映射至 t 的字符为值，第二张哈希表 t2s 以 t 中字符为键，映射至 s 的字符为值。从左至右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突（即当前下标 index 对应的字符 s[index] 已经存在映射且不为 t[index] 或当前下标 index 对应的字符 t[index] 已经存在映射且不为 s[index]）时说明两个字符串无法构成同构，返回 false。</description>
    </item>
    
    <item>
      <title>242.有效的字母异位词</title>
      <link>https://www.pengjielee.cn/post/leetcode/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</link>
      <pubDate>Tue, 27 Apr 2021 09:51:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</guid>
      <description>题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
示例 1: 输入: s = &amp;#34;anagram&amp;#34;, t = &amp;#34;nagaram&amp;#34; 输出: true 示例 2: 输入: s = &amp;#34;rat&amp;#34;, t = &amp;#34;car&amp;#34; 输出: false 说明:
你可以假设字符串只包含小写字母。 进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-anagram 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 字母异位词是指由相同的字母按照不同的顺序组成的单词。
JS实现 1、排序
t 是 s 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 s 和 t 分别排序，看排序后的字符串是否相等即可判断。
/** * @param {string} s * @param {string} t * @return {boolean} */ var isAnagram = function (s, t) { if (s.</description>
    </item>
    
    <item>
      <title>763.划分字母区间</title>
      <link>https://www.pengjielee.cn/post/leetcode/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</link>
      <pubDate>Mon, 26 Apr 2021 14:46:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</guid>
      <description>题目 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
示例：
输入：S = &amp;ldquo;ababcbacadefegdehijhklij&amp;rdquo; 输出：[9,7,8] 解释： 划分结果为 &amp;ldquo;ababcbaca&amp;rdquo;, &amp;ldquo;defegde&amp;rdquo;, &amp;ldquo;hijhklij&amp;rdquo;。 每个字母最多出现在一个片段中。 像 &amp;ldquo;ababcbacadefegde&amp;rdquo;, &amp;ldquo;hijhklij&amp;rdquo; 的划分是错误的，因为划分的片段数较少。 提示：
S的长度在[1, 500]之间。 S只包含小写字母 &amp;lsquo;a&amp;rsquo; 到 &amp;lsquo;z&amp;rsquo; 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/partition-labels 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。
在得到每个字母最后一次出现的下标位置之后，可以使用贪心的方法将字符串划分为尽可能多的片段，具体做法如下。
从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start=end=0。 对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 end_c，则当前片段的结束下标一定不会小于 end_c，因此令 end=max(end,end_c)。 当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start,end]，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start=end+1，继续寻找下一个片段。 重复上述过程，直到遍历完字符串。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {string} S * @return {number[]} */ var partitionLabels = function (S) { const result = []; //使用hashmap记录每一个字符出现的最后位置 const map = new Map(); for (let i = 0; i &amp;lt; S.</description>
    </item>
    
    <item>
      <title>122.买卖股票的最佳时机II</title>
      <link>https://www.pengjielee.cn/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</link>
      <pubDate>Mon, 26 Apr 2021 14:42:08 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii/</guid>
      <description>题目 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1: 输入: prices = [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入， 在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入， 在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: prices = [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入， 在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: prices = [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：</description>
    </item>
    
    <item>
      <title>167.两数之和II-输入有序数组.md</title>
      <link>https://www.pengjielee.cn/post/leetcode/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 25 Apr 2021 16:20:20 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。
numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;= numbers.length 。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 提示：
2 &amp;lt;= numbers.length &amp;lt;= 3 * 10^4 -1000 &amp;lt;= numbers[i] &amp;lt;= 1000 numbers 按 递增顺序 排列 -1000 &amp;lt;= target &amp;lt;= 1000 仅存在一个有效答˜ 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>435.无重叠区间</title>
      <link>https://www.pengjielee.cn/post/leetcode/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</link>
      <pubDate>Sun, 25 Apr 2021 15:12:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</guid>
      <description>题目 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:
可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-overlapping-intervals 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间 就越大，就越能保留更多的区间。
因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。
具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选 择的区间不重叠的区间。
JS实现 /** * @param {number[][]} intervals * @return {number} */ var eraseOverlapIntervals = function (intervals) { const len = intervals.</description>
    </item>
    
    <item>
      <title>135.分发糖果</title>
      <link>https://www.pengjielee.cn/post/leetcode/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</link>
      <pubDate>Sun, 25 Apr 2021 14:20:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</guid>
      <description>题目 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？
示例 1： 输入：[1,0,2] 输出：5 解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2： 输入：[1,2,2] 输出：4 解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/candy 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 两次遍历：
把所有孩子的糖果数初始化为 1； 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1； 再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数 不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。 通过这两次遍历，分配的糖果就可以满足题目要求了。 这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系
JS实现 /** * @param {number[]} ratings * @return {number} */ var candy = function (ratings) { const len = ratings.length; // 把所有孩子的糖果数初始化为1 const nums = new Array(len).fill(1); // 从左往右遍历（这里下标起始为1） for (let i = 1; i &amp;lt; len; i++) { if (ratings[i] &amp;gt; ratings[i - 1]) { nums[i] = nums[i - 1] + 1; } } // 从右往左遍历 for (let i = len - 1; i &amp;gt; 0; i--) { if (ratings[i - 1] &amp;gt; ratings[i]) { nums[i - 1] = Math.</description>
    </item>
    
    <item>
      <title>455.分发饼干</title>
      <link>https://www.pengjielee.cn/post/leetcode/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</link>
      <pubDate>Sun, 25 Apr 2021 13:48:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</guid>
      <description>题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &amp;gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示：
1 &amp;lt;= g.length &amp;lt;= 3 * 10^4 0 &amp;lt;= s.length &amp;lt;= 3 * 10^4 1 &amp;lt;= g[i], s[j] &amp;lt;= 2^31 - 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/assign-cookies 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</description>
    </item>
    
    <item>
      <title>067.二进制求和</title>
      <link>https://www.pengjielee.cn/post/leetcode/067.%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</link>
      <pubDate>Sun, 25 Apr 2021 10:51:30 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/067.%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</guid>
      <description>题目 给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = &amp;#34;11&amp;#34;, b = &amp;#34;1&amp;#34; 输出: &amp;#34;100&amp;#34; 示例 2: 输入: a = &amp;#34;1010&amp;#34;, b = &amp;#34;1011&amp;#34; 输出: &amp;#34;10101&amp;#34; 提示：
每个字符串仅由字符 &amp;lsquo;0&amp;rsquo; 或 &amp;lsquo;1&amp;rsquo; 组成。 1 &amp;lt;= a.length, b.length &amp;lt;= 10^4 字符串如果不是 &amp;ldquo;0&amp;rdquo; ，就都不含前导零。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-binary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} a * @param {string} b * @return {string} */ var addBinary = function (a, b) { let result = &amp;#34;&amp;#34;; let carry = 0; for (let i = a.</description>
    </item>
    
    <item>
      <title>014.最长公共前缀</title>
      <link>https://www.pengjielee.cn/post/leetcode/014.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Sun, 25 Apr 2021 10:35:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/014.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>题目 编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。
示例 1： 输入：strs = [&amp;#34;flower&amp;#34;,&amp;#34;flow&amp;#34;,&amp;#34;flight&amp;#34;] 输出：&amp;#34;fl&amp;#34; 示例 2： 输入：strs = [&amp;#34;dog&amp;#34;,&amp;#34;racecar&amp;#34;,&amp;#34;car&amp;#34;] 输出：&amp;#34;&amp;#34; 解释：输入不存在公共前缀。 提示：
0 &amp;lt;= strs.length &amp;lt;= 200 0 &amp;lt;= strs[i].length &amp;lt;= 200 strs[i] 仅由小写英文字母组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-common-prefix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、横向扫描法
/** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function (strs) { if (strs.length === 0) { return &amp;#34;&amp;#34;; } // 获取两个字符串的最长公共前缀 const lcp = (str1, str2) =&amp;gt; { const length = Math.</description>
    </item>
    
    <item>
      <title>090.子集II</title>
      <link>https://www.pengjielee.cn/post/leetcode/090.%E5%AD%90%E9%9B%86ii/</link>
      <pubDate>Sun, 25 Apr 2021 09:44:28 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/090.%E5%AD%90%E9%9B%86ii/</guid>
      <description>题目 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
示例 1： 输入：nums = [1,2,2] 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 提示：
1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subsets-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var subsetsWithDup = function(nums) { const result = []; const len = nums.length; if (len === 0) { return result; } // 排序 nums = nums.</description>
    </item>
    
    <item>
      <title>078.子集</title>
      <link>https://www.pengjielee.cn/post/leetcode/078.%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sun, 25 Apr 2021 09:44:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/078.%E5%AD%90%E9%9B%86/</guid>
      <description>题目 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
示例 1： 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 提示：
1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums 中的所有元素 互不相同 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subsets 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
补充 子集：2^n 真子集：2^n - 1 非空子集：2^n - 1 非空真子集：2^n - 2
JS实现 1、递归
/** * @param {number[]} nums * @return {number[][]} */ var subsets = function (nums) { const result = []; const len = nums.</description>
    </item>
    
    <item>
      <title>017.电话号码的字母组合</title>
      <link>https://www.pengjielee.cn/post/leetcode/017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
      <pubDate>Fri, 23 Apr 2021 14:51:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
      <description>题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
1(!@#) 2(abc) 3(def) 4(ghi) 5(jkl) 6(mno) 7(pqrs) 8(tuv) 9(wxyz) *(+) 0(-) # 示例 1： 输入：digits = &amp;#34;23&amp;#34; 输出：[&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;] 示例 2： 输入：digits = &amp;#34;&amp;#34; 输出：[] 示例 3： 输入：digits = &amp;#34;2&amp;#34; 输出：[&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 提示：
0 &amp;lt;= digits.length &amp;lt;= 4 digits[i] 是范围 [&amp;lsquo;2&amp;rsquo;, &amp;lsquo;9&amp;rsquo;] 的一个数字。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
补充 String.prototype.slice()
slice() 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。
str.slice(beginIndex[, endIndex]) beginIndex 从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 strLength + beginIndex 看待，这里的strLength 是字符串的长度（例如， 如果 beginIndex 是 -3 则看作是：strLength - 3）</description>
    </item>
    
    <item>
      <title>047.全排列II</title>
      <link>https://www.pengjielee.cn/post/leetcode/047.%E5%85%A8%E6%8E%92%E5%88%97ii/</link>
      <pubDate>Fri, 23 Apr 2021 10:06:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/047.%E5%85%A8%E6%8E%92%E5%88%97ii/</guid>
      <description>题目 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示：
1 &amp;lt;= nums.length &amp;lt;= 8 -10 &amp;lt;= nums[i] &amp;lt;= 10 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/permutations-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var permuteUnique = function(nums) { // 返回结果数组 const result = []; const len = nums.length; // 如果数组长度等于0，直接返回 if (len === 0) { return result; } // 排序是剪枝的前提 nums = nums.</description>
    </item>
    
    <item>
      <title>046.全排列</title>
      <link>https://www.pengjielee.cn/post/leetcode/046.%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Fri, 23 Apr 2021 10:05:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/046.%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>题目 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
示例:
输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/permutations 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 排列是讲究顺序的，不同的顺序产生不同的排列；
[1,2,3]
以1开头的排列，[1,2,3],[1,3,2]；
以2开头的排列，[2,1,3],[2,3,1]；
以3开头的排列，[3,1,2],[3,2,1]；
按顺序枚举每一个位置可能出现的数字； 之前已经出现的数字在接下来要选择的数字中不能出现； [] / | \ [1] [2] [3] / \ / \ / \ [1,2] [1,3] [2,1] [2,3] [3,1] [3,2] | | | | | | [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1] JS实现 /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { // 返回结果数组 const result = []; const len = nums.</description>
    </item>
    
    <item>
      <title>216.组合总和III</title>
      <link>https://www.pengjielee.cn/post/leetcode/216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Ciii/</link>
      <pubDate>Fri, 23 Apr 2021 09:56:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Ciii/</guid>
      <description>题目 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
说明：
所有数字都是正整数。 解集不能包含重复的组合。 示例：
示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combination-sum-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} k * @param {number} n * @return {number[][]} */ var combinationSum3 = function (k, n) { // 结果数组 const result = []; //路径数组 const path = []; const dfs = (curr, end, k, sum, path, result) =&amp;gt; { // 递归终止条件 ?</description>
    </item>
    
    <item>
      <title>077.组合</title>
      <link>https://www.pengjielee.cn/post/leetcode/077.%E7%BB%84%E5%90%88/</link>
      <pubDate>Fri, 23 Apr 2021 09:54:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/077.%E7%BB%84%E5%90%88/</guid>
      <description>题目 给定两个整数 n 和 k，返回 1 &amp;hellip; n 中所有可能的 k 个数的组合。
示例:
输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combinations 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 n = 4, k = 2, [1,2,3,4]
1,2 1,3 1,4 2,3 2,4 3,4
JS实现 1、深度优先搜索（未剪枝）
/** * @param {number} n * @param {number} k * @return {number[][]} */ var combine = function (n, k) { const result = []; if (k &amp;lt;= 0 || n &amp;lt; k) { return result; } // 路径数组 const path = []; // 深度优先遍历 const dfs = (begin, n, k, path, result) =&amp;gt; { //递归终止 if (path.</description>
    </item>
    
    <item>
      <title>039.组合总和</title>
      <link>https://www.pengjielee.cn/post/leetcode/039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 23 Apr 2021 09:50:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>题目 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例：
示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ] 示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ] 提示：
1 &amp;lt;= candidates.length &amp;lt;= 30 1 &amp;lt;= candidates[i] &amp;lt;= 200 candidate 中的每个元素都是独一无二的。 1 &amp;lt;= target &amp;lt;= 500 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combination-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、未剪枝
/** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum = function (candidates, target) { const result = []; const len = candidates.</description>
    </item>
    
    <item>
      <title>061.旋转链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/061.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Apr 2021 10:54:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/061.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
示例 1： 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5
rotate 1: 5 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 rotate 2: 4 -&amp;gt; 5 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3
输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3]
示例 2： 0 -&amp;gt; 1 -&amp;gt; 2
rotate 1: 2 -&amp;gt; 1 -&amp;gt; 0 rotate 2: 1 -&amp;gt; 2 -&amp;gt; 0 rotate 3: 0 -&amp;gt; 1 -&amp;gt; 2 rotate 4: 2 -&amp;gt; 0 -&amp;gt; 1</description>
    </item>
    
    <item>
      <title>024.两两交换链表中的节点</title>
      <link>https://www.pengjielee.cn/post/leetcode/024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 22 Apr 2021 10:42:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>题目 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示：
链表中节点的数目在范围 [0, 100] 内 0 &amp;lt;= Node.val &amp;lt;= 100 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 链表： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 头节点： head = 1, 结节点： dummy = 0, dummy.next = head; 0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4 临时节点： temp = dummy 0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 | | dummy head temp temp.next，就是head，就是1 temp.next.next，就是head.next，就是2 node1 = temp.</description>
    </item>
    
    <item>
      <title>019.删除链表的倒数第N个结点</title>
      <link>https://www.pengjielee.cn/post/leetcode/019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</link>
      <pubDate>Thu, 22 Apr 2021 09:15:56 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</guid>
      <description>题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
示例 1： 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 //删除倒数第2个后： 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 5 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示：
链表中结点的数目为 sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</description>
    </item>
    
    <item>
      <title>002.两数相加</title>
      <link>https://www.pengjielee.cn/post/leetcode/002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Thu, 22 Apr 2021 09:15:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例 1： 2 -&amp;gt; 4 -&amp;gt; 3 + 5 -&amp;gt; 6 -&amp;gt; 4 ------------- = 7 -&amp;gt; 0 -&amp;gt; 8 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示：
每个链表中的节点数在范围 [1, 100] 内 0 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>082.删除排序链表中的重复元素II</title>
      <link>https://www.pengjielee.cn/post/leetcode/082.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</link>
      <pubDate>Thu, 22 Apr 2021 09:14:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/082.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0ii/</guid>
      <description>题目 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。
返回同样按升序排列的结果链表。
示例 1： 输入：head = [1,2,3,3,4,4,5] 输出：[1,2,5] 示例 2： 输入：head = [1,1,1,2,3] 输出：[2,3] 提示：
链表中节点数目在范围 [0, 300] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 题目数据保证链表已经按升序排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function (head) { //设置哑节点，方便删除 let dummy = new ListNode(0); dummy.</description>
    </item>
    
    <item>
      <title>142.环形链表II</title>
      <link>https://www.pengjielee.cn/post/leetcode/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link>
      <pubDate>Thu, 22 Apr 2021 09:13:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid>
      <description>题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
进阶：
你是否可以使用 O(1) 空间解决此题？ 示例：
示例 1： 3 -&amp;gt; 2 -&amp;gt; 0 -&amp;gt; -4 -&amp;gt; 2 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 1 -&amp;gt; 2 -&amp;gt; 1 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 1 -&amp;gt; null 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：</description>
    </item>
    
    <item>
      <title>141.环形链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Apr 2021 09:13:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
进阶：
你能用 O(1)（即，常量）内存解决此问题吗？ 示例：
示例 1： 3 -&amp;gt; 2 -&amp;gt; 0 -&amp;gt; -4 [-&amp;gt; 2] 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 1 -&amp;gt; 2 [-&amp;gt; 1] 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 1 -&amp;gt; null 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示：</description>
    </item>
    
    <item>
      <title>143.重排链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Apr 2021 09:12:52 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1: 给定链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 重新排列为 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. 示例 2: 给定链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 重新排列为 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reorder-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、使用数组存储，然后重新构建链表
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {void} Do not return anything, modify head in-place instead. */ var reorderList = function (head) { const list = []; while (head !</description>
    </item>
    
    <item>
      <title>234.回文链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Apr 2021 09:11:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 请判断一个链表是否为回文链表。
示例 1: 输入: 1-&amp;gt;2 输出: false 示例 2: 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、将值复制到数组中后用双指针法
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {boolean} */ var isPalindrome = function (head) { const values = []; // 将链表的值保存到数组中 while (head !</description>
    </item>
    
    <item>
      <title>328.奇偶链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 21 Apr 2021 14:23:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
示例 1: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL 示例 2: 输入: 2-&amp;gt;1-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;NULL 输出: 2-&amp;gt;3-&amp;gt;6-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;4-&amp;gt;NULL 说明:
应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/odd-even-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var oddEvenList = function (head) { if (head === null) { return head; } // 偶节点的头节点 let evenHead = head.</description>
    </item>
    
    <item>
      <title>237.删除链表中的节点</title>
      <link>https://www.pengjielee.cn/post/leetcode/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 21 Apr 2021 11:54:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>题目 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。
现有一个链表 &amp;ndash;head = [4,5,1,9]，它可以表示为:
示例 1： 4 -&amp;gt; 5 -&amp;gt; 1 -&amp;gt; 9 输入：head = [4,5,1,9], node = 5 输出：[4,1,9] 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9. 示例 2： 输入：head = [4,5,1,9], node = 1 输出：[4,5,9] 解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9. 提示：
链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.</description>
    </item>
    
    <item>
      <title>092.反转链表II</title>
      <link>https://www.pengjielee.cn/post/leetcode/092.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</link>
      <pubDate>Wed, 21 Apr 2021 11:50:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/092.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</guid>
      <description>题目 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &amp;lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 翻转后： 1 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 5 输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] 示例 2： 输入：head = [5], left = 1, right = 1 输出：[5] 提示：
链表中节点数目为 n 1 &amp;lt;= n &amp;lt;= 500 -500 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>206.反转链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 21 Apr 2021 11:49:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 反转一个单链表。
示例:
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、迭代
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { // 前一个节点 let prev = null; // 当前节点 let curr = head; while(curr !</description>
    </item>
    
    <item>
      <title>203.移除链表元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 21 Apr 2021 09:07:20 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</guid>
      <description>题目 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
示例 1： 1 -&amp;gt; 2 -&amp;gt; 6 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 移除6： 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2： 输入：head = [], val = 1 输出：[] 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[] 提示：
列表中的节点在范围 [0, 10^4] 内 1 &amp;lt;= Node.val &amp;lt;= 50 0 &amp;lt;= k &amp;lt;= 50 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>160.相交链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 21 Apr 2021 09:07:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 编写一个程序，找到两个单链表相交的起始节点。
如下面的两个链表： A: a1 -&amp;gt; a2 -&amp;gt; c1 -&amp;gt; c2 -&amp;gt; c3 B: b1 -&amp;gt; b2 -&amp;gt; b3 -&amp;gt; c1 -&amp;gt; c2 -&amp;gt; c3
在节点 c1 开始相交。
示例 1： A: 4 -&amp;gt; 1 -&amp;gt; 8 -&amp;gt; 4 -&amp;gt; 5 B: 5 -&amp;gt; 0 -&amp;gt; 1 -&amp;gt; 8 -&amp;gt; 4 -&amp;gt; 5 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： A: 0 -&amp;gt; 9 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 4 B: 3 -&amp;gt; 2 -&amp;gt; 4 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： A: 2 -&amp;gt; 6 -&amp;gt; 4 B: 1 -&amp;gt; 5 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意：</description>
    </item>
    
    <item>
      <title>095.不同的二叉搜索树II</title>
      <link>https://www.pengjielee.cn/post/leetcode/095.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</link>
      <pubDate>Tue, 20 Apr 2021 17:41:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/095.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</guid>
      <description>题目 给定一个整数 n，生成所有由 1 &amp;hellip; n 为节点所组成的 二叉搜索树 。
示例：
输入：3 输出： [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释： 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 提示：
0 &amp;lt;= n &amp;lt;= 8 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、回溯
/** * Definition for a binary tree node. * function TreeNode(val) { * this.</description>
    </item>
    
    <item>
      <title>096.不同的二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Tue, 20 Apr 2021 17:41:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给定一个整数 n，求以 1 &amp;hellip; n 为节点组成的二叉搜索树有多少种？
示例:
输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 假设 n 个节点存在二叉排序树的个数是 G (n)，令 f(i) 为以 i 为根的二叉搜索树的个数，则 G(n) = f(1) + f(2) + f(3) + f(4) + &amp;hellip; + f(n)</description>
    </item>
    
    <item>
      <title>111.二叉树的最小深度</title>
      <link>https://www.pengjielee.cn/post/leetcode/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 20 Apr 2021 16:37:33 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明：叶子节点是指没有子节点的节点。
示例 1： 3 / \ 9 20 / \ 15 7 输入：root = [3,9,20,null,null,15,7] 输出：2 (节点3，9) 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 2 \ 3 \ 4 \ 5 \ 6 输出：5 (节点2，3，4，5，6) 提示：
树中节点数的范围在 [0, 10^5] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、深度优先搜索
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.</description>
    </item>
    
    <item>
      <title>257.二叉树的所有路径</title>
      <link>https://www.pengjielee.cn/post/leetcode/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 20 Apr 2021 16:05:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。
示例:
输入: 1 / \ 2 3 \ 5 输出: [&amp;#34;1-&amp;gt;2-&amp;gt;5&amp;#34;, &amp;#34;1-&amp;gt;3&amp;#34;] 解释: 所有根节点到叶子节点的路径为: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-paths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、深度优先搜索
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {string[]} */ var binaryTreePaths = function (root) { const result = []; if (root === null) { return result; } const dfs = (root, path) =&amp;gt; { if (root) { path.</description>
    </item>
    
    <item>
      <title>113.路径总和II</title>
      <link>https://www.pengjielee.cn/post/leetcode/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Cii/</link>
      <pubDate>Tue, 20 Apr 2021 09:13:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Cii/</guid>
      <description>题目 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
示例 1： 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 （5 - 4 - 11 - 2） 输出：[[5,4,11,2],[5,8,4,5]] 示例 2： 1 / \ 2 3 输入：root = [1,2,3], targetSum = 5 输出：[] 示例 3： 输入：root = [1,2], targetSum = 0 输出：[] 提示：
树中节点的数目在范围 [0, 5000] 内 -1000 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>112.路径总和</title>
      <link>https://www.pengjielee.cn/post/leetcode/112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</link>
      <pubDate>Tue, 20 Apr 2021 09:13:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</guid>
      <description>题目 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
叶子节点 是指没有子节点的节点。
示例 1： 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 ，（5 - 4 - 11 - 2） 输出：true 示例 2： 1 / \ 2 3 输入：root = [1,2,3], targetSum = 5 输出：false 示例 3： 输入：root = [1,2], targetSum = 0 输出：false 提示：
树中节点的数目在范围 [0, 5000] 内 -1000 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>106.从中序与后序遍历序列构造二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 19 Apr 2021 16:30:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 根据一棵树的中序遍历与后序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
例如，给出
中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \ 9 20 / \ 15 7 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {number[]} inorder * @param {number[]} postorder * @return {TreeNode} */ var buildTree = function (inorder, postorder) { if (postorder.</description>
    </item>
    
    <item>
      <title>105.从前序与中序遍历序列构造二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 19 Apr 2021 16:29:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 根据一棵树的前序遍历与中序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
例如，
给出： 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \ 9 20 / \ 15 7 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 前序：根 -&amp;gt; 左 -&amp;gt; 右（根在最前边） 中序：左 -&amp;gt; 根 -&amp;gt; 右（根在中间） 后序：左 -&amp;gt; 右 -&amp;gt; 根（根在最后边） 由前序序列，我们可以确定根节点； 由后序序列，我们也可以确定根节点； 由中序序列，我们可以确定左右节点；
前序 + 中序，可以确定二叉树； 后序 + 中序，可以确定二叉树；
举例：
4 / \ 1 3 / / \ 2 5 8 tree: [4,1,3,2,null,5,8] 前序：[4,1,2,3,5,8] 中序：[2,1,4,5,3,8] 后序：[2,1,5,8,3,4] 前序+中序： 由前序：我们确定根节点为4； 由中序：我们确定根节点4左边的为左子树[2,1]，右边的为右子树[5,3,8]； 后序+中序： 由后序：我们确定根节点为4； 由中序：我们确定根节点4左边的为左子树[2,1]，右边的为右子树[5,3,8]； 前序+后序： 由前序：我们确定根节点为4； 由后序：我们确定根节点为4； JS实现 /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>100.相同的树</title>
      <link>https://www.pengjielee.cn/post/leetcode/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link>
      <pubDate>Mon, 19 Apr 2021 16:25:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid>
      <description>题目 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
示例 1： tree1： 1 / \ 2 3 tree2： 1 / \ 2 3 输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2： tree1： 1 / 2 tree2： 1 \ 2 输入：p = [1,2], q = [1,null,2] 输出：false 示例 3： tree1： 1 / \ 2 1 tree2： 1 / \ 1 2 输入：p = [1,2,1], q = [1,1,2] 输出：false 提示：
两棵树上的节点数目都在范围 [0, 100] 内 -10^4 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>226.翻转二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 19 Apr 2021 14:59:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 翻转一棵二叉树。
示例：
输入： 4 / \ 2 7 / \ / \ 1 3 6 9 输出： 4 / \ 7 2 / \ / \ 9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ：
谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/invert-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ?</description>
    </item>
    
    <item>
      <title>107.二叉树的层序遍历II</title>
      <link>https://www.pengjielee.cn/post/leetcode/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii/</link>
      <pubDate>Mon, 19 Apr 2021 14:06:42 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii/</guid>
      <description>题目 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回其自底向上的层序遍历为： [ [15,7], [9,20], [3] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、反转其返回结果（102.二叉树的层序遍历）
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrderBottom = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</description>
    </item>
    
    <item>
      <title>145.二叉树的后序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:14:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树，返回它的 后序 遍历。
示例:
输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 后序遍历：左 -&amp;gt; 右 -&amp;gt; 根
JS实现 1、递归实现
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var helper = function (root, result) { if (root !</description>
    </item>
    
    <item>
      <title>144.二叉树的前序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:13:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
示例 1： 1 \ 2 / 3 输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 1 / 2 输入：root = [1,2] 输出：[1,2] 示例 5： 1 \ 2 输入：root = [1,null,2] 输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 前序遍历：根 -&amp;gt; 左 -&amp;gt; 右
JS实现 1、 递归实现</description>
    </item>
    
    <item>
      <title>103.二叉树的锯齿形层序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:12:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如：
给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回锯齿形层序遍历如下： [ [3], [20,9], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var zigzagLevelOrder = function (root) { // write code here const result = []; if (root === null) { return result; } const q = []; q.</description>
    </item>
    
    <item>
      <title>094.二叉树的中序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 19 Apr 2021 11:05:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树的根节点 root ，返回它的 中序 遍历。
示例 1： 1 \ 2 / 3 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 1 / 2 输入：root = [1,2] 输出：[2,1] 示例 5： 1 \ 2 输入：root = [1,null,2] 输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 进阶:
递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 中序遍历：左 -&amp;gt; 根 -&amp;gt; 右
JS实现 1、递归实现</description>
    </item>
    
    <item>
      <title>二叉树题目合集</title>
      <link>https://www.pengjielee.cn/post/algorithm/19.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</link>
      <pubDate>Mon, 19 Apr 2021 10:39:25 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/19.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</guid>
      <description>题目 求二叉树的最大深度； 求二叉树的最小深度； 求二叉树中节点的个数； 求二叉树中叶子节点的个数； 求二叉树中第k层节点的个数； 判断二叉树是否是平衡二叉树； 判断二叉树是否是完全二叉树； 判断两个二叉树是否完全相同； 判断两个二叉树是否互为镜像； 翻转二叉树/镜像二叉树； 求两个二叉树的最低公共祖先节点； 二叉树的前序遍历； 二叉树的中序遍历； 二叉树的后序遍历； 构造二叉树（前序遍历和中序遍历/后序遍历和中序遍历）； 二叉树中插入/删除节点； 输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径； 二叉树的搜索区间； 二叉树的层次遍历； 二叉树内两个节点的最长距离； 不同的二叉树； 判断二叉树是否是合法的二叉查找树（BST）； More 一篇文章搞定面试中的二叉树题目(java实现)
https://www.jianshu.com/p/0190985635eb</description>
    </item>
    
    <item>
      <title>链表题目合集</title>
      <link>https://www.pengjielee.cn/post/algorithm/18.%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</link>
      <pubDate>Mon, 19 Apr 2021 10:39:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/18.%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</guid>
      <description>题目 翻转链表； 判断链表是否有环； 链表排序； 链表相加求和； 获取链表倒数第n个节点； 删除链表倒数第n个节点； 删除链表中重复元素； 旋转链表； 重排链表； 链表划分； 翻转链表的n到m之间的节点； 合并K个排序过的链表； More 一篇文章搞定面试中的链表题目(java实现)
https://www.jianshu.com/p/a64d1ef95980</description>
    </item>
    
    <item>
      <title>922.按奇偶排序数组II</title>
      <link>https://www.pengjielee.cn/post/leetcode/922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</link>
      <pubDate>Sat, 17 Apr 2021 16:32:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii/</guid>
      <description>题目 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
你可以返回任何满足上述条件的数组作为答案。
示例：
输入：[4,2,5,7] 输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示：
2 &amp;lt;= A.length &amp;lt;= 20000 A.length % 2 == 0 0 &amp;lt;= A[i] &amp;lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[]} */ var sortArrayByParityII = function (nums) { const result = new Array(nums.length); let i = 0; // 第1次遍历，在偶数位上设置偶数 for (const num of nums) { if (num % 2 === 0) { result[i] = num; i += 2; } } i = 1; // 第2次遍历，在奇数位上设置奇数 for (const num of nums) { if (num % 2 === 1) { result[i] = num; i += 2; } } return result; }; </description>
    </item>
    
    <item>
      <title>905.按奇偶排序数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/905.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 17 Apr 2021 16:26:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/905.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。
你可以返回满足此条件的任何数组作为答案。
示例：
输入：[3,1,2,4] 输出：[2,4,3,1] 输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示：
1 &amp;lt;= A.length &amp;lt;= 5000 0 &amp;lt;= A[i] &amp;lt;= 5000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-array-by-parity 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} A * @return {number[]} */ var sortArrayByParity = function(A) { const result = []; // 第1次遍历，添加所有偶数 for(let item of A) { if(item % 2 === 0){ result.push(item); } } // 第2次遍历，添加所有奇数 for(let item of A) { if(item % 2 === 1){ result.</description>
    </item>
    
    <item>
      <title>349.两个数组的交集</title>
      <link>https://www.pengjielee.cn/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Sat, 17 Apr 2021 16:14:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 说明：
输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、排序 + 双指针
/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function (nums1, nums2) { const result = []; //分别对两个数组排序（从小到大） nums1.sort((a, b) =&amp;gt; a - b); nums2.sort((a, b) =&amp;gt; a - b); const len1 = nums1.</description>
    </item>
    
    <item>
      <title>排序算法合集</title>
      <link>https://www.pengjielee.cn/post/algorithm/17.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/</link>
      <pubDate>Sat, 17 Apr 2021 09:16:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/17.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/</guid>
      <description>算法度量 1、算法内存使用
原地排序（Sorted in place）算法，特指空间复杂度是 O(1) 的排序算法。
2、算法的稳定性
经过某种排序算法排序之后：
如果两个元素的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法； 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。 冒泡排序 var bubbleSort = (arr) =&amp;gt; { const n = arr.length; if (n &amp;lt;= 1) { return; } for (let i = 0; i &amp;lt; n; i++) { for (let j = 0; j &amp;lt; n - i - 1; j++) { if (arr[j] &amp;gt; arr[j+1]) { const temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } }; 测试：</description>
    </item>
    
    <item>
      <title>JavaScript位运算</title>
      <link>https://www.pengjielee.cn/post/fe/javascript%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Thu, 15 Apr 2021 16:45:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/javascript%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>什么是位运算 现代计算机中所有的数据都以二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、/)都叫位运算，即将符号位共同参与运算的运算。
位运算 AND 当对一对数位执行位运算 AND 时，如果数位均为 1 则返回 1。
1、单位示例：
运算 结果 0 &amp;amp; 0 0 0 &amp;amp; 1 0 1 &amp;amp; 0 0 1 &amp;amp; 1 1 2、四位示例：
运算 结果 1111 &amp;amp; 0000 0000 1111 &amp;amp; 0001 0001 1111 &amp;amp; 0010 0010 1111 &amp;amp; 0100 0100 位运算 OR 当对一对数位执行位运算 OR 时，如果其中一位是 1 则返回 1：
1、单位示例：
运算 结果 0 0 0 1 1 0 1 1 2、四位示例：</description>
    </item>
    
    <item>
      <title>015.三数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 15 Apr 2021 14:14:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2： 输入：nums = [] 输出：[] 示例 3： 输入：nums = [0] 输出：[] 提示：
0 &amp;lt;= nums.length &amp;lt;= 3000 -10^5 &amp;lt;= nums[i] &amp;lt;= 10^5
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function (nums) { let result = []; // 传入数组为null直接返回result if (nums === null) { return result; } const len = nums.</description>
    </item>
    
    <item>
      <title>计数排序</title>
      <link>https://www.pengjielee.cn/post/algorithm/16.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 15 Apr 2021 10:50:30 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/16.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>桶排序 （Bucket sort） 核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。
比如对 9,10,20,45,40,27,32,35,31,50,53,63进行桶排序：
桶1（0-9）: 9 桶2（10-19）: 19 桶3（20-29）: 20,27 桶4（30-39）: 32,35,31 桶5（40-49）: 45,40, 桶6（50-59）: 50,53 桶6（60-69）: 63 桶排序的时间复杂度为什么是 O(n) 呢?
如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。 每个桶内部使用快速排序，时间复杂度为 O(k * logk)。 m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。
当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。
计数排序 （Counting sort） 当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。
题目：数组里有20个随机数，取值范围为从0到10，要求用最快的速度把这20个整数从小到大进行排序。
1、整数的取值范围是从0到10，那么这些整数的值肯定是在0到10这11个数里面。于是我们可以建立一个长度为11的数组，数组下标从0到10，元素初始值全为0
先假设20个随机整数的值是： 9, 3, 5, 4, 9, 1, 2, 7, 8, 1, 3, 6, 5, 3, 4, 0, 10, 9, 7, 9</description>
    </item>
    
    <item>
      <title>075.颜色分类</title>
      <link>https://www.pengjielee.cn/post/leetcode/075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</link>
      <pubDate>Thu, 15 Apr 2021 10:25:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</guid>
      <description>题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 示例 3： 输入：nums = [0] 输出：[0] 示例 4： 输入：nums = [1] 输出：[1] 提示：
n == nums.length 1 &amp;lt;= n &amp;lt;= 300 nums[i] 为 0、1 或 2 进阶：
你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-colors 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、单指针
在第一次遍历中，我们将数组中所有的 0 交换到数组的头部。
在第二次遍历中，我们将数组中所有的 1 交换到头部的 0 之后。 此时，所有的 2 都出现在数组的尾部，这样我们就完成了排序。
/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead.</description>
    </item>
    
    <item>
      <title>347.前K个高频元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 15 Apr 2021 10:25:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/347.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</guid>
      <description>题目 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 提示：
1 &amp;lt;= nums.length &amp;lt;= 10^5 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/top-k-frequent-elements 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function (nums, k) { const result = []; // 使用hashmap统计每个数字出现的次数 const hashmap = new Map(); for (let num of nums) { if (!</description>
    </item>
    
    <item>
      <title>16.编程题</title>
      <link>https://www.pengjielee.cn/post/fe/16.%E7%BC%96%E7%A8%8B%E9%A2%98/</link>
      <pubDate>Thu, 15 Apr 2021 09:16:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/16.%E7%BC%96%E7%A8%8B%E9%A2%98/</guid>
      <description>&amp;lsquo;##&amp;rsquo; 005. 介绍下深度优先遍历和广度优先遍历，如何实现？ &amp;lsquo;##&amp;rsquo; 006. 请分别用深度优先思想和广度优先思想实现一个拷贝函数？
&amp;lsquo;##&amp;rsquo; 011. 算法手写题
已知如下数组：
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
&amp;lsquo;##&amp;rsquo; 014. 情人节福利题，如何实现一个 new
&amp;lsquo;##&amp;rsquo; 030. 两个数组合并成一个数组
请把两个数组 [&amp;lsquo;A1&amp;rsquo;, &amp;lsquo;A2&amp;rsquo;, &amp;lsquo;B1&amp;rsquo;, &amp;lsquo;B2&amp;rsquo;, &amp;lsquo;C1&amp;rsquo;, &amp;lsquo;C2&amp;rsquo;, &amp;lsquo;D1&amp;rsquo;, &amp;lsquo;D2&amp;rsquo;] 和 [&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;lsquo;D&amp;rsquo;]，合并为 [&amp;lsquo;A1&amp;rsquo;, &amp;lsquo;A2&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B1&amp;rsquo;, &amp;lsquo;B2&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C1&amp;rsquo;, &amp;lsquo;C2&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;lsquo;D1&amp;rsquo;, &amp;lsquo;D2&amp;rsquo;, &amp;lsquo;D&amp;rsquo;]。
&amp;lsquo;##&amp;rsquo; 031. 改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。</description>
    </item>
    
    <item>
      <title>15.观察者模式vs发布订阅模式</title>
      <link>https://www.pengjielee.cn/post/fe/15.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8Fvs%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 13 Apr 2021 17:16:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/15.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8Fvs%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>联系 / 意图 / 区别 / 适用场景 1、联系
发布-订阅模式是观察者模式的一种变体。发布-订阅只是把一部分功能抽象成一个独立的ChangeManager。
2、意图
都是某个对象(subject, publisher)改变，使依赖于它的多个对象(observers, subscribers)得到通知。
3、区别与适用场景
总的来说，发布-订阅模式适合更复杂的场景。
在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？
在「多对一」或者「多对多」场景下。一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是等所有发布者都更新完毕再通知订阅者？
这些逻辑都可以放到ChangeManager里。
4、简单理解
观察者模式没有中介，发布者和订阅者必须知道对方的存在
发布订阅模式有中介，发布者和订阅者不需要知道对方是谁，只要通过中介进行信息的传递和过滤就可以了
代码理解 观察者模式：
// 被观察者 var subject = { observers: [], notify() { this.observers.forEach((observer) =&amp;gt; { observer.update(); }); }, attach(observer) { this.observers.push(observer); }, }; // 观察者 var observer = { update() { alert(&amp;#34;updated&amp;#34;); }, }; // 绑定观察者 subject.attach(observer); // 通知观察者 subject.notify(); 发布订阅模式：
//发布订阅对象 var pubsub = { subscribes: [], publish() { this.</description>
    </item>
    
    <item>
      <title>14.实现数组方法合集</title>
      <link>https://www.pengjielee.cn/post/fe/14.%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</link>
      <pubDate>Tue, 13 Apr 2021 13:20:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/14.%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</guid>
      <description>实现数组方法flat // 实现1 var flat1 = (arr, number = 10) =&amp;gt; { let result = [],count = 0; var helper = (arr) =&amp;gt; { let res = []; count++; for (let item of arr) { if (Array.isArray(item)) { if (count === number) { break; } res = res.concat(helper(item)); } else { res.push(item); } } return res; }; result = result.concat(helper(arr)); return result; }; // 实现2 var flat2 = (arr) =&amp;gt; { return arr.</description>
    </item>
    
    <item>
      <title>12.CSS优先级</title>
      <link>https://www.pengjielee.cn/post/fe/12.css%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Tue, 13 Apr 2021 13:18:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/12.css%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>一道题目 &amp;lt;style&amp;gt; .classA { color: blue; } .classB { color: red; } p { color: black; } &amp;lt;/style&amp;gt; &amp;lt;p class=&amp;#34;classB classA&amp;#34;&amp;gt;hello&amp;lt;/p&amp;gt; &amp;lt;!-- 元素p内的文字最终什么颜色：red --&amp;gt; 解释：“类选择器” 的优先级要高于 “类型选择器”；后面声明的类选择器 &amp;gt; 先声明的类选择器，所以颜色为red（css）。
更多实例 1、
&amp;lt;style&amp;gt; div { width: 100px; height: 100px; background-color: blue; } .div1 { background-color: green; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;#34;div1&amp;#34; id=&amp;#34;div1&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- div最终什么颜色：green --&amp;gt; 解释：类选择器 &amp;gt; 类型选择器；
2、
&amp;lt;style&amp;gt; div { width: 100px; height: 100px; background-color: blue; } .div1 { background-color: green; } #div1 { background-color: red; } &amp;lt;/style&amp;gt; &amp;lt;div class=&amp;#34;div1&amp;#34; id=&amp;#34;div1&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>11.typeof操作符</title>
      <link>https://www.pengjielee.cn/post/fe/11.typeof%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Tue, 13 Apr 2021 11:32:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/11.typeof%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>一道题目 typeof typeof typeof null; //&amp;#39;string&amp;#39; typeof操作符 typeof 操作符返回一个字符串，表示未经计算的操作数的类型。
语法：
typeof operand typeof(operand) 1、数值
console.log(typeof 42); //&amp;#39;number&amp;#39; console.log(typeof 3.14); //&amp;#39;number&amp;#39; console.log(typeof(42)); //&amp;#39;number&amp;#39; console.log(typeof Math.LN2); //&amp;#39;number&amp;#39; console.log(typeof Infinity); //&amp;#39;number&amp;#39; console.log(typeof NaN); //&amp;#39;number&amp;#39; console.log(typeof Number(1)); //&amp;#39;number&amp;#39; console.log(typeof 42n); //&amp;#39;bigint&amp;#39; 2、字符串
console.log(typeof &amp;#39;&amp;#39;); //&amp;#39;string&amp;#39; console.log(typeof &amp;#39;hello&amp;#39;); //&amp;#39;string&amp;#39; console.log(typeof `hello`); //&amp;#39;string&amp;#39; console.log(typeof &amp;#39;1&amp;#39;); //&amp;#39;string&amp;#39; console.log(typeof (typeof 1)); //&amp;#39;string&amp;#39; console.log(typeof String(1)); //&amp;#39;string&amp;#39; 3、布尔值
console.log(typeof true); //&amp;#39;boolean&amp;#39; console.log(typeof false); //&amp;#39;boolean&amp;#39; //Boolean() 会基于参数是真值还是虚值进行转换 console.log(typeof Boolean(1)); //&amp;#39;boolean&amp;#39; //两次调用 !</description>
    </item>
    
    <item>
      <title>10.Function.prototype &amp; Object.prototype.md</title>
      <link>https://www.pengjielee.cn/post/fe/10.function.prototype-object.prototype/</link>
      <pubDate>Tue, 13 Apr 2021 11:08:43 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/10.function.prototype-object.prototype/</guid>
      <description>一道题目 Function.prototype.a = () =&amp;gt; alert(1); Object.prototype.b = () =&amp;gt; alert(2); function Foo() {} var bar = new Foo(); bar.a(); //Uncaught TypeError: bar.a is not a function bar.b(); //2 表达式结果 以下为chrome 88.0.4324.96
function F(){}; var o = {}; // 这是一个构造函数 typeof F; //&amp;#39;function&amp;#39; // 这是一个对象 typeof o; //&amp;#39;object&amp;#39; // 构造函数的原型对象 typeof F.prototype; //&amp;#39;object&amp;#39; // 不太理解？实例对象没有原型对象？ typeof o.prototype; //&amp;#39;undefined&amp;#39; // 这是一个实例对象 typeof new F; //&amp;#39;object&amp;#39; // 不太理解？实例对象没有原型对象？ typeof (new F).prototype; //&amp;#39;undefined&amp;#39; // 实例对象的属性__proto__，指向原型对象 typeof (new F).</description>
    </item>
    
    <item>
      <title>09.代码输出结果</title>
      <link>https://www.pengjielee.cn/post/fe/09.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Mon, 12 Apr 2021 21:26:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/09.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</guid>
      <description>1、 实现一个工具方法，将下划线命名格式的字符串转化为驼峰命名格式
//实现1 var convert1 = (name) =&amp;gt; { let result = name.split(&amp;#34;_&amp;#34;); const [first, ...rest] = result; return ( first + rest .map((item) =&amp;gt; item.substring(0, 1).toUpperCase() + item.substring(1)) .join(&amp;#34;&amp;#34;) ); }; //实现2 var convert2 = (name) =&amp;gt; { return name.replace(/(\_\w)/g, function (word) { return word.slice(1, 2).toUpperCase() + word.slice(2); }); }; 2、 实现 Array 的 flat 方法的polyfill
我的（未实现）：
var flat = (arr, number) =&amp;gt; { let result = [], count = 0; count++; for (let item of arr) { if (Array.</description>
    </item>
    
    <item>
      <title>HTML5自定义标签</title>
      <link>https://www.pengjielee.cn/post/fe/html5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Thu, 08 Apr 2021 13:29:11 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/html5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/</guid>
      <description>定义非标准元素：greeting &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;style&amp;gt; greeting { display: block; font-size: 36px; color: red; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;greeting&amp;gt;Hello World&amp;lt;/greeting&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; function customTag(tagName, fn) { Array.from(document.getElementsByTagName(tagName)).forEach(fn); } function greetingHandler(element) { element.innerHTML = &amp;#34;你好，世界&amp;#34;; } customTag(&amp;#34;greeting&amp;#34;, greetingHandler); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; 效果预览 https://codepen.io/pengjielee-the-lessful/pen/poRWBLX
HTMLUnknownElement var tabs = document.createElement(&amp;#39;tabs&amp;#39;); console.log(tabs instanceof HTMLUnknownElement) // true console.log(tabs instanceof HTMLElement) // true var xTabs = document.createElement(&amp;#39;x-tabs&amp;#39;); console.log(xTabs instanceof HTMLUnknownElement) // false console.log(xTabs instanceof HTMLElement) // true Custom elements: WordCount &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;article contenteditable=&amp;#34;&amp;#34;&amp;gt; &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet&amp;lt;/p&amp;gt; &amp;lt;p is=&amp;#34;word-count&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/article&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; // Create a class for the element class WordCount extends HTMLParagraphElement { constructor() { // Always call super first in constructor super(); // count words in element&amp;#39;s parent element const wcParent = this.</description>
    </item>
    
    <item>
      <title>排列组合</title>
      <link>https://www.pengjielee.cn/post/algorithm/15.%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</link>
      <pubDate>Thu, 08 Apr 2021 11:37:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/algorithm/15.%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</guid>
      <description>排列 一般地，从n个不同元素中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列(permutation)。特别地，当m=n时，这个排列被称作全排列(all permutation)。
var permute = (nums, k) =&amp;gt; { let result = []; /* * 生成排列 * index表示向当前排列添加第index个元素。 * p表示当前的排列，其中拥有index-1个元素。 */ var generatePermutation = (nums, index, p) =&amp;gt; { if (index === k) { result.push([].concat(p)); return; } for (let num of nums) { if (p.indexOf(num) &amp;lt; 0) { p.push(num); generatePermutation(nums, index + 1, p); p.pop(); } } }; generatePermutation(nums, 0, []); return result; }; 组合 一般地，从n个不同的元素中，任取m（m≤n）个元素为一组，叫作从n个不同元素中取出m个元素的一个组合。
var combine = (nums, k) =&amp;gt; { let res = []; /* * 生成组合 * start表示需要从数组的start位置开始搜索元素加入当前组合c中。 * c表示当前的组合。 * 当前组合的长度等于k时，组合构造完成。 */ var generateCombinations = (nums, start, c) =&amp;gt; { //当前组合的长度等于k时，保存当前组合 if (c.</description>
    </item>
    
    <item>
      <title>08.部门组合</title>
      <link>https://www.pengjielee.cn/post/fe/08.%E9%83%A8%E9%97%A8%E7%BB%84%E5%90%88/</link>
      <pubDate>Thu, 08 Apr 2021 10:46:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/08.%E9%83%A8%E9%97%A8%E7%BB%84%E5%90%88/</guid>
      <description>题目 求部门安排所有组合。
示例1：
部门：{&amp;#39;frontend&amp;#39;: [1, 2], &amp;#39;backend&amp;#39;: [3, 4], &amp;#39;devops&amp;#39;: [5]} 人数：{&amp;#39;frontend&amp;#39;: 2, &amp;#39;backend&amp;#39;: 1} 组合：[[1, 2, 3], [1, 2, 4]] 要求：按员工ID升序排序
实现 /** * 部门安排所有组合 * @param departments: dict, key是部门名, value是每个部门对应所有员工ID数组 * 例 {&amp;#39;frontend&amp;#39;: [1, 2], &amp;#39;backend&amp;#39;: [3, 4], &amp;#39;devops&amp;#39;: [5]} * @param required_department: dict, 该任务需要参与的部门和需要的人数 * 例 {&amp;#39;frontend&amp;#39;: 2, &amp;#39;backend&amp;#39;: 1} * @return 所有可能的员工组合, 例 [[1, 2, 3], [1, 2, 4]]. 按员工ID升序排序 */ var staffCombinations = (department_staff_dict, required_staff) =&amp;gt; { const result = []; var combine = (nums, k) =&amp;gt; { let res = []; var generate = (nums, start, c) =&amp;gt; { if (c.</description>
    </item>
    
    <item>
      <title>07.字符串处理</title>
      <link>https://www.pengjielee.cn/post/fe/07.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 08 Apr 2021 10:37:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/07.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</guid>
      <description>统计数组中每个字符串出现次数 /** * 统计数组中每个字符串出现次数 * @param string[] strs: 字符串数组, 例如 [&amp;#39;aa&amp;#39;, &amp;#39;ab&amp;#39;, &amp;#39;ab&amp;#39;, &amp;#39;cc&amp;#39;, &amp;#39;cba&amp;#39;] * @return {[key: string]: number} 出现次数对象, 例如 { aa: 1, ab: 2, cc: 1, cba: 1 } */ var frequencyMap = (strs) =&amp;gt; { const map = {}; for (let i = 0; i &amp;lt; strs.length; i++) { const ch = strs[i]; map[ch] = (map[ch] || 0) + 1; } return map; } 处理给定字符串 /** * 请处理给定字符串: * - 去掉无用字符和乱码, 只保留大小写英文字母, 单引号, 和空格 * - 把一个或多个连续无用字符和乱码换成一个空格.</description>
    </item>
    
    <item>
      <title>252.会议室</title>
      <link>https://www.pengjielee.cn/post/leetcode/252.%E4%BC%9A%E8%AE%AE%E5%AE%A4/</link>
      <pubDate>Thu, 08 Apr 2021 10:29:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/252.%E4%BC%9A%E8%AE%AE%E5%AE%A4/</guid>
      <description>题目 给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[ s1 , e1 ] ，[ s2 , e2 ]，…] (si &amp;lt; ei) ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。
示例 1: 输入: [[0, 30],[5, 10],[15, 20]] 输出: 2
示例 2: 输入: [[7,10],[2,4]] 输出: 1
JS实现 var minMeetingRooms = (meetings) =&amp;gt; { if (meetings === null || meetings.length === 0) { return 0; } // 需要的会议室个数 let number = 1; // 会议按结束时间排序 meetings.sort((a, b) =&amp;gt; a[1] - b[1]); // 上一次会议结束时间（这里是第一次） let end = meetings[0][1]; for (let i = 1; i &amp;lt; meetings.</description>
    </item>
    
    <item>
      <title>06.代码输出结果</title>
      <link>https://www.pengjielee.cn/post/fe/06.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Thu, 08 Apr 2021 10:17:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/06.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</guid>
      <description>1. function fn2(){ for(var i=0;i&amp;lt;4;i++){ var timer=setInterval(function(i,timer){ console.log(i); clearInterval(timer) },10,i,timer); } } fn2(); 输出：0 1 2 3 3 3 3 重复
2. function fn1(){ for(var i=0;i&amp;lt;4;i++){ var timer=setTimeout(function(i){ console.log(i); clearTimeout(timer) },10,i); } } fn1(); 输出：0 1 2
3. const a = []; for (var i = 0; i &amp;lt; 10; i++) { a.push(function () { return console.log(i); }); } a[0](); a[1](); 输出：10 10
4. var m = true; setTimeout(function() { m = false; },3000); while(m) { } console.</description>
    </item>
    
    <item>
      <title>043.字符串相乘</title>
      <link>https://www.pengjielee.cn/post/leetcode/043.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Thu, 08 Apr 2021 09:18:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/043.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</guid>
      <description>题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
示例 1:
输入: num1 = &amp;#34;2&amp;#34;, num2 = &amp;#34;3&amp;#34; 输出: &amp;#34;6&amp;#34; 示例 2:
输入: num1 = &amp;#34;123&amp;#34;, num2 = &amp;#34;456&amp;#34; 输出: &amp;#34;56088&amp;#34; 说明：
num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/multiply-strings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 如果 num1 和 num2 之一是 0，则直接将 0 作为结果返回即可。
如果 num1和 num2都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。这道题中，被乘数是 num1，乘数是 num2 。
需要注意的是，num2 除了最低位以外，其余的每一位的运算结果都需要补 0。</description>
    </item>
    
    <item>
      <title>415.字符串相加</title>
      <link>https://www.pengjielee.cn/post/leetcode/415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Thu, 08 Apr 2021 09:11:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</guid>
      <description>题目 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
提示：
num1 和num2 的长度都小于 5100 num1 和num2 都只包含数字 0-9 num1 和num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-strings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} num1 * @param {string} num2 * @return {string} */ var addStrings = function (num1, num2) { let i = num1.length - 1, j = num2.length - 1, add = 0; const result = []; while (i &amp;gt;= 0 || j &amp;gt;= 0 || add !</description>
    </item>
    
    <item>
      <title>博客收藏</title>
      <link>https://www.pengjielee.cn/post/other/blogs/</link>
      <pubDate>Tue, 06 Apr 2021 10:56:00 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/blogs/</guid>
      <description>林鑫个人博客
https://github.com/lin-xin/blog
冴羽个人博客
https://github.com/mqyqingfeng/Blog
dwqs个人博客
https://github.com/dwqs/blog
jaywcjlove笔记
https://github.com/jaywcjlove/handbook
梁少峰个人博客
https://github.com/youngwind/blog
fouber个人博客
https://github.com/fouber/blog
CSS魔法博客
https://github.com/cssmagic/blog
前端开发博客
https://github.com/camsong/blog
&amp;ldquo;地瓜哥&amp;quot;博客网
https://www.diguage.com/</description>
    </item>
    
    <item>
      <title>JavaScript发布订阅模式</title>
      <link>https://www.pengjielee.cn/post/fe/javascript%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 06 Apr 2021 10:03:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/javascript%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>发布订阅模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JS中，我们一般用事件模型来替代传统的发布-订阅模式。
1. 现实中的发布-订阅模式 购房者与售楼处；
购房者：订阅者； 售楼处：发布者；
2. 发布-订阅模式的作用 发布-订阅模式优点：
a. 发布-订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。在异步编程中，使用发布-订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。
b. 发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。
3. DOM事件 //订阅body的click事件 document.body.addEventListener(&amp;#39;click&amp;#39;,function(){ console.log(2) }, false); document.body.addEventListener(&amp;#39;click&amp;#39;,function(){ console.log(3) }, false); document.body.addEventListener(&amp;#39;click&amp;#39;,function(){ console.log(4) }, false); document.body.click(); //模拟用户点击 注意，手动触发事件更好的做法是 IE 下用 fireEvent，标准浏览器下用 dispatchEvent 实现。
4. 自定义事件 var salesOffices = {}; // 定义售楼处 salesOffices.clientList = []; // 缓存列表，存放订阅者的回调函数 salesOffices.listen = function (fn) { // 增加订阅者 this.clientList.push(fn); // 订阅的消息添加进缓存列表 }; salesOffices.trigger = function () { // 发布消息 for (var i = 0, fn; (fn = this.</description>
    </item>
    
    <item>
      <title>JavaScript单例模式</title>
      <link>https://www.pengjielee.cn/post/fe/javascript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 06 Apr 2021 10:03:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/javascript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>代码 var getSingle = function (fn) { var result; return function () { return result || (result = fn.apply(this, arguments)); }; }; // 创建登录框 var createLoginDialog = function () { var div = document.createElement(&amp;#34;div&amp;#34;); div.innerHTML = &amp;#34;Login Dialog&amp;#34;; div.style.display = &amp;#34;none&amp;#34;; document.body.appendChild(div); return div; }; // 创建唯一登录框 var createSingleLoginDialog = getSingle(createLoginDialog); document.getElementById(&amp;#34;login&amp;#34;).onclick = function () { var loginDialog = createSingleLoginDialog(); loginDialog.style.display = &amp;#34;block&amp;#34;; }; </description>
    </item>
    
    <item>
      <title>JavaScript函数声明提升</title>
      <link>https://www.pengjielee.cn/post/fe/javascript%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/</link>
      <pubDate>Fri, 02 Apr 2021 11:38:47 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/javascript%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/</guid>
      <description>1、Function declaration foo(); // &amp;#34;bar&amp;#34; function foo() { console.log(&amp;#39;bar&amp;#39;); } 解释：
function foo() { console.log(&amp;#39;bar&amp;#39;); } foo(); // &amp;#34;bar&amp;#34; 2、Function expression baz(); // TypeError: baz is not a function var baz = function() { console.log(&amp;#39;bar2&amp;#39;); }; 解释：
var baz; baz(); baz = function() { console.log(&amp;#39;bar2&amp;#39;); }; 3、 var foo = function(){ console.log(123); } function foo(){ console.log(456); } foo(); //123 解释：
var foo; // 变量声明提升 function foo(){ // 函数声明提升 console.log(456); } foo = function(){ // 变量赋值依然保留在原来位置 console.</description>
    </item>
    
    <item>
      <title>JavaScript变量声明提升</title>
      <link>https://www.pengjielee.cn/post/fe/javascript%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/</link>
      <pubDate>Fri, 02 Apr 2021 11:38:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/javascript%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/</guid>
      <description>1、 console.log(x === undefined); // true var x = 3; 解释：
var x; console.log(x === undefined); // true x = 3; 2、 // will return a value of undefined var myvar = &amp;#39;my value&amp;#39;; (function() { console.log(myvar); // undefined var myvar = &amp;#39;local value&amp;#39;; })(); 解释：
var myvar = &amp;#39;my value&amp;#39;; (function() { var myvar; console.log(myvar); // undefined myvar = &amp;#39;local value&amp;#39;; })(); 3、 function foo() { console.log(x); // undefined var x = 12; console.</description>
    </item>
    
    <item>
      <title>05.代码输出结果</title>
      <link>https://www.pengjielee.cn/post/fe/05.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Fri, 02 Apr 2021 11:19:49 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/05.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</guid>
      <description>1. 输出是什么？ function sayHi() { console.log(name) console.log(age) var name = &amp;#39;Lydia&amp;#39; let age = 21 } sayHi() A: Lydia 和 undefined B: Lydia 和 ReferenceError C: ReferenceError 和 21 D: undefined 和 ReferenceError 我的：D（ok）
2. 输出是什么？ for (var i = 0; i &amp;lt; 3; i++) { setTimeout(() =&amp;gt; console.log(i), 1) } for (let i = 0; i &amp;lt; 3; i++) { setTimeout(() =&amp;gt; console.log(i), 1) } A: 0 1 2 和 0 1 2 B: 0 1 2 和 3 3 3 C: 3 3 3 和 0 1 2 我的：C（ok）</description>
    </item>
    
    <item>
      <title>Weekly-20210402</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2021.04.02/</link>
      <pubDate>Fri, 02 Apr 2021 10:44:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2021.04.02/</guid>
      <description>文章 Build your own React
https://pomb.us/build-your-own-react/
壹题汇总 | 木易杨前端进阶
https://muyiy.cn/question/
在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么？ - SegmentFault 思否
https://segmentfault.com/q/1010000002810093
介绍 | uTools
https://u.tools/docs/guide/about-uTools.html
深入理解http2.0协议，看这篇就够了！ - 知乎
https://zhuanlan.zhihu.com/p/89471776
归档 | JerryQu 的小站
https://imququ.com/post/archives.html
宁皓网 - Node.js，Flutter，Vue.js，小程序，Token 视频教程
https://ninghao.net/
我应该在组件中使用一个还是多个useEffect？ http://codingdict.com/questions/77800
前端性能优化 24 条建议
https://mp.weixin.qq.com/s/ezOX9lcLEOuMjlRIrT_ARw
269个JavaScript工具函数，助你提升工作效率（上） https://mp.weixin.qq.com/s/2_ln9Yj2b8G_nRrajHBZAQ
查理·芒格：让我受用一生的思维方式
https://mp.weixin.qq.com/s/96ibXz4uRjPCX8-BsZE2YQ
关于写文章的一点经验
https://mp.weixin.qq.com/s/fJNIvghKrN_HZaO-qNfgkQ</description>
    </item>
    
    <item>
      <title>实现JSON.stringify()</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0json.stringify/</link>
      <pubDate>Wed, 31 Mar 2021 11:46:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0json.stringify/</guid>
      <description>写一个函数format，传入一个javascript object，输出格式化后的string，为了简化，我们规定object里只有number、array、object三种类型。比如
//输入 var object = { a: 1, b: 2, c: { d: 3 }, e: [4, 5, { g: 6 }] } //输出 参考 JSON.stringify(object, null, &amp;#39; &amp;#39;) &amp;#34; { &amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: 2, &amp;#34;c&amp;#34;: { &amp;#34;d&amp;#34;: 3 }, &amp;#34;e&amp;#34;: [ 4, 5, { &amp;#34;g&amp;#34;: 6 } ] } &amp;#34; 参考1（不符题目要求，未格式化输出） function jsonStringify(obj) { let type = typeof obj; if (type !== &amp;#34;object&amp;#34; || type === null) { if (/string|undefined|function/.</description>
    </item>
    
    <item>
      <title>实现Promise.all()</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise.all/</link>
      <pubDate>Wed, 31 Mar 2021 11:46:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise.all/</guid>
      <description>语法 Promise.all(iterable); 参数：
iterable
一个可迭代对象，如 Array 或 String。
返回值：
如果传入的参数是一个空的可迭代对象，则返回一个已完成（already resolved）状态的 Promise。 如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。注意：Google Chrome 58 在这种情况下返回一个已完成（already resolved）状态的 Promise。 其它情况下返回一个处理中（pending）的Promise。这个返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。 说明：
完成（Fulfillment）： 如果传入的可迭代对象为空，Promise.all 会同步地返回一个已完成（resolved）状态的promise。
如果所有传入的 promise 都变为完成状态，或者传入的可迭代对象内没有 promise，Promise.all 返回的 promise 异步地变为完成。
在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。
失败/拒绝（Rejection）： 如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成。
实现 Promise._all = function (promises) { // promises 是可迭代对象，省略参数合法性检查 return new Promise((resolve, reject) =&amp;gt; { // Array.from 将可迭代对象转换成数组 promises = Array.</description>
    </item>
    
    <item>
      <title>实现Promise.finally()</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise.finally/</link>
      <pubDate>Wed, 31 Mar 2021 11:46:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise.finally/</guid>
      <description>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
这避免了同样的语句需要在then()和catch()中各写一次的情况。
语法 p.finally(onFinally); p.finally(function() { // 返回状态为(resolved 或 rejected) }); 实现 Promise.prototype._finally = function (callback) { let P = this.constructor; return this.then( value =&amp;gt; P.resolve(callback()).then(() =&amp;gt; value), reason =&amp;gt; P.resolve(callback()).then(() =&amp;gt; { throw reason }) ); }; More Promise.prototype.finally()
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally
Promise.prototype.finally()
https://es6.ruanyifeng.com/#docs/promise#Promise-prototype-finally</description>
    </item>
    
    <item>
      <title>实现Promise.race()</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise.race/</link>
      <pubDate>Wed, 31 Mar 2021 11:45:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise.race/</guid>
      <description>语法 Promise.race(iterable); 参数：
iterable
可迭代对象，类似Array。
返回值：
一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的值，从而异步地解析或拒绝（一旦堆栈为空）。
理解 Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。
理解1：
var p1 = new Promise((resolve, reject) =&amp;gt; { setTimeout(resolve, 500, &amp;#34;one&amp;#34;); }); var p2 = new Promise((resolve, reject) =&amp;gt; { setTimeout(resolve, 100, &amp;#34;two&amp;#34;); }); Promise.race([p1, p2]).then((value) =&amp;gt; { console.log(value); // Both resolve, but p2 is faster }); // expected output: &amp;#34;two&amp;#34; 理解2：
var p3 = new Promise(function(resolve, reject) { setTimeout(resolve, 100, &amp;#34;three&amp;#34;); }); var p4 = new Promise(function(resolve, reject) { setTimeout(reject, 500, &amp;#34;four&amp;#34;); }); Promise.</description>
    </item>
    
    <item>
      <title>实现Promise：完全版</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise3/</link>
      <pubDate>Wed, 31 Mar 2021 11:42:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise3/</guid>
      <description>Promise规范 promise 有三个状态：pending，fulfilled，rejected。「规范 Promise/A+ 2.1」 new promise时， 需要传递一个executor()执行器，执行器立即执行； executor接受两个参数，分别是resolve和reject； promise 的默认状态是 pending； promise 有一个value保存成功状态的值，可以是undefined/thenable/promise；「规范 Promise/A+ 1.3」 promise 有一个reason保存失败状态的值；「规范 Promise/A+ 1.5」 promise 只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变； promise 必须有一个then方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」 如果调用 then 时，promise 已经成功，则执行onFulfilled，参数是promise的value； 如果调用 then 时，promise 已经失败，那么执行onRejected, 参数是promise的reason； 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调onRejected； Promise版本1 // 定义三种状态 const PENDING = &amp;#34;PENDING&amp;#34;; const FULFILLED = &amp;#34;FULFILLED&amp;#34;; const REJECTED = &amp;#34;REJECTED&amp;#34;; class Promise { constructor(executor) { // 默认状态为 PENDING this.</description>
    </item>
    
    <item>
      <title>实现Promise：升级版</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise2/</link>
      <pubDate>Wed, 31 Mar 2021 11:40:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise2/</guid>
      <description>升级版 const PENDING = &amp;#34;pending&amp;#34;; const FULFILLED = &amp;#34;fulfilled&amp;#34;; const REJECTED = &amp;#34;rejected&amp;#34;; function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if (value instanceof Promise) { return value.then(resolve, reject); } // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() =&amp;gt; { // 调用resolve 回调对应onFulfilled函数 if (that.</description>
    </item>
    
    <item>
      <title>实现Promise：简洁版</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise1/</link>
      <pubDate>Wed, 31 Mar 2021 11:40:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0promise1/</guid>
      <description>简洁版 function myPromise(constructor) { let self = this; self.status = &amp;#34;pending&amp;#34;; //定义状态改变前的初始状态 self.value = undefined; //定义状态为resolved的时候的状态 self.reason = undefined; //定义状态为rejected的时候的状态 function resolve(value) { //两个===&amp;#34;pending&amp;#34;，保证了状态的改变是不可逆的 if (self.status === &amp;#34;pending&amp;#34;) { self.value = value; self.status = &amp;#34;resolved&amp;#34;; } } function reject(reason) { //两个===&amp;#34;pending&amp;#34;，保证了状态的改变是不可逆的 if (self.status === &amp;#34;pending&amp;#34;) { self.reason = reason; self.status = &amp;#34;rejected&amp;#34;; } } //捕获构造异常 try { constructor(resolve, reject); } catch (e) { reject(e); } } myPromise.prototype.then = function (onFullfilled, onRejected) { let self = this; switch (self.</description>
    </item>
    
    <item>
      <title>04.代码输出结果</title>
      <link>https://www.pengjielee.cn/post/fe/04.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Tue, 30 Mar 2021 17:01:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/04.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</guid>
      <description>33. 下面的代码打印什么内容，为什么？ var b = 10; (function b(){ b = 20; console.log(b); })(); 我的：20
正确：[Function b]
解析：
声明提前：一个声明在函数体内都是可见的，函数声明优先于变量声明； 在非匿名自执行函数中，函数变量为只读状态无法修改；
var b = 10; (function b() { // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值； // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。 // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等） b = 20; console.log(b); // [Function b] console.log(window.b); // 10，不是20 })(); 严格模式下会报错误：
var b = 10; (function b() { &amp;#39;use strict&amp;#39; b = 20; console.log(b); })() // &amp;#34;Uncaught TypeError: Assignment to constant variable.&amp;#34; 使用var声明：
var b = 10; (function b() { var b = 20; // IIFE内部变量 console.</description>
    </item>
    
    <item>
      <title>03.parseInt与map</title>
      <link>https://www.pengjielee.cn/post/fe/03.parseint%E4%B8%8Emap/</link>
      <pubDate>Mon, 29 Mar 2021 17:52:17 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/03.parseint%E4%B8%8Emap/</guid>
      <description>[&amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;].map(parseInt) what &amp;amp; why ? 1、parseInt
parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。
const intValue = parseInt(string[, radix]); string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。
radix 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。 返回值 返回一个整数或NaN
demo:
parseInt(100); // 100 parseInt(100, 10); // 100 parseInt(100, 2); // 4 -&amp;gt; converts 100 in base 2 to base 10 注意： 在radix为 undefined，或者radix为 0 或者没有指定的情况下，JavaScript 作如下处理：
如果字符串 string 以&amp;quot;0x&amp;quot;或者&amp;quot;0X&amp;quot;开头, 则基数是16 (16进制). 如果字符串 string 以&amp;quot;0&amp;quot;开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。 以下例子均返回15:
console.log(parseInt(&amp;#34;0xF&amp;#34;, 16)); console.log(parseInt(&amp;#34;F&amp;#34;, 16)); console.</description>
    </item>
    
    <item>
      <title>React Hooks原理</title>
      <link>https://www.pengjielee.cn/post/deep-dive-react-hooks/</link>
      <pubDate>Mon, 29 Mar 2021 14:14:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/deep-dive-react-hooks/</guid>
      <description>useState实现 function useState(initialValue) { var _val = initialValue; function state(){ return _val; } function setState(newVal){ _val = newVal; } return [state, setState]; } 使用
var [foo, setFoo] = useState(0) // 数组解构 console.log(foo()); //output: 0 setFoo(1); console.log(foo()); //output: 1 在函数组件中使用 function Counter() { const [count, setCount] = useState(0) // 和上文实现的一样 return { click: () =&amp;gt; setCount(count() + 1), render: () =&amp;gt; console.log(&amp;#39;render:&amp;#39;, { count: count() }) } } const C = Counter() C.</description>
    </item>
    
    <item>
      <title>创建你自己的React</title>
      <link>https://www.pengjielee.cn/post/build-your-react/</link>
      <pubDate>Mon, 29 Mar 2021 09:40:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/build-your-react/</guid>
      <description>version1: jsx const element = &amp;lt;h1 title=&amp;#34;foo&amp;#34;&amp;gt;Hello&amp;lt;/h1&amp;gt;; const container = document.getElementById(&amp;#39;root&amp;#39;); ReactDOM.render(element, container); version2: React.createElement const element = React.createElement( &amp;#34;h1&amp;#34;, { title: &amp;#34;foo&amp;#34;}, &amp;#34;Hello&amp;#34; ); const container = document.getElementById(&amp;#39;root&amp;#39;); ReactDOM.render(element, container); version3: convert jsx to js const element = { type: &amp;#34;h1&amp;#34;, props: { title: &amp;#34;foo&amp;#34;, children: &amp;#34;Hello&amp;#34; } } const container = document.getElementById(&amp;#39;root&amp;#39;); ReactDOM.render(element, container); version4: const element = { type: &amp;#34;h1&amp;#34;, props: { title: &amp;#34;foo&amp;#34;, children: &amp;#34;Hello&amp;#34; } } const container = document.</description>
    </item>
    
    <item>
      <title>238.移动零</title>
      <link>https://www.pengjielee.cn/post/leetcode/238.%E7%A7%BB%E5%8A%A8%E9%9B%B6/</link>
      <pubDate>Tue, 23 Mar 2021 10:47:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/238.%E7%A7%BB%E5%8A%A8%E9%9B%B6/</guid>
      <description>题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明:
必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/move-zeroes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。
右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
注意到以下性质：
左指针左边均为非零数； 右指针左边直到左指针处均为零。 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var moveZeroes = function (nums) { let n = nums.length, left = 0, right = 0; while (right &amp;lt; n) { if (nums[right] != 0) { const temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; } right++; } }; </description>
    </item>
    
    <item>
      <title>387.字符串中的第一个唯一字符</title>
      <link>https://www.pengjielee.cn/post/leetcode/387.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Mon, 22 Mar 2021 10:30:49 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/387.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</guid>
      <description>题目 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
示例：
s = &amp;#34;leetcode&amp;#34; 返回 0 s = &amp;#34;loveleetcode&amp;#34; 返回 2 提示：你可以假定该字符串只包含小写字母。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {string} s * @return {number} */ var firstUniqChar = function (s) { const map = {}; for (let i = 0; i &amp;lt; s.length; i++) { const ch = s[i]; map[ch] = (map[ch] || 0) + 1; } for (let i = 0; i &amp;lt; s.length; i++) { if (map[s[i]] === 1) { return i; } } return -1; }; 参考代码2：hashmap实现</description>
    </item>
    
    <item>
      <title>344.反转字符串</title>
      <link>https://www.pengjielee.cn/post/leetcode/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 22 Mar 2021 10:12:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&amp;#34;h&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;o&amp;#34;] 输出：[&amp;#34;o&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;h&amp;#34;] 示例 2：
输入：[&amp;#34;H&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;h&amp;#34;] 输出：[&amp;#34;h&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;H&amp;#34;] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 双指针的解法：
1、将 left 指向字符数组首元素，right 指向字符数组尾元素。
2、当 left &amp;lt; right：
交换 s[left] 和 s[right]； left 指针右移一位，即 left = left + 1； right 指针左移一位，即 right = right - 1。 3、当 left &amp;gt;= right，反转结束，返回字符数组即可。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/reverse-string/solution/fan-zhuan-zi-fu-chuan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead.</description>
    </item>
    
    <item>
      <title>198.打家劫舍</title>
      <link>https://www.pengjielee.cn/post/leetcode/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</link>
      <pubDate>Sat, 20 Mar 2021 15:50:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</guid>
      <description>题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
示例 1：
输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2：
输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示：
0 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 400 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>053.最大子序和</title>
      <link>https://www.pengjielee.cn/post/leetcode/053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</link>
      <pubDate>Sat, 20 Mar 2021 15:49:43 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</guid>
      <description>题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [0] 输出：0 示例 4： 输入：nums = [-1] 输出：-1 示例 5： 输入：nums = [-100000] 输出：-100000 提示：
1 &amp;lt;= nums.length &amp;lt;= 3 * 10^4 -10^5 &amp;lt;= nums[i] &amp;lt;= 10^5 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-subarray 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考代码1：
/** * @param {number[]} nums * @return {number} */ var maxSubArray = function (nums) { // 当前和 let cur_sum = nums[0]; // 最大和 let max_sum = nums[0]; // 遍历数组 for (let i = 1; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>121.买卖股票的最佳时机</title>
      <link>https://www.pengjielee.cn/post/leetcode/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Sat, 20 Mar 2021 15:48:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid>
      <description>题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1：
输入：[7,1,5,3,6,4] 输出：5 解释： 在第 2 天（股票价格 = 1）的时候买入， 在第 5 天（股票价格 = 6）的时候卖出， 最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：
输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：
1 &amp;lt;= prices.length &amp;lt;= 10^5 0 &amp;lt;= prices[i] &amp;lt;= 10^4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 参考1：一次遍历</description>
    </item>
    
    <item>
      <title>070.爬楼梯</title>
      <link>https://www.pengjielee.cn/post/leetcode/070.%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Sat, 20 Mar 2021 15:46:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/070.%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/climbing-stairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归（执行超时了）
找规律：
第1级台阶，1种方法（爬1级） 第2级台阶，2种方法（爬1级 或 爬2级） 第3级台阶，3种方法（从第2级台阶爬1级 或 从第1级台阶爬2级） &amp;hellip; 第n级台阶，从第n-1级台阶爬1级 或 从第n-2级台阶爬2级 递推公式：F(n) = F(n-1) + F(n-2)</description>
    </item>
    
    <item>
      <title>108.将有序数组转换为二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 20 Mar 2021 11:15:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
示例 1：
0 / \ -3 9 / / -10 5 输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 0 / \ -10 5 \ \ -3 9 示例 2：
3 1 / \ 1 3 输入：nums = [1,3] 输出：[3,1] 解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示：
1 &amp;lt;= nums.length &amp;lt;= 10^4 -10^4 &amp;lt;= nums[i] &amp;lt;= 10^4 nums 按 严格递增 顺序排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>098.验证二叉搜索树</title>
      <link>https://www.pengjielee.cn/post/leetcode/098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 20 Mar 2021 11:15:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:
输入:
2 / \ 1 3 输出: true
示例 2:
输入:
5 / \ 1 4 / \ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/validate-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 var valid = function (node, lower, upper) { if (node === null) { return true; } let val = node.val; if (lower != null &amp;amp;&amp;amp; val &amp;lt;= lower) { return false; } if (upper !</description>
    </item>
    
    <item>
      <title>102.二叉树的层序遍历</title>
      <link>https://www.pengjielee.cn/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 20 Mar 2021 11:05:11 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例： 二叉树：[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层序遍历结果：
[ [3], [9,20], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function (root) { const result = []; if (root === null) { return result; } // 声明一个队列，队列特点：先进先出 let q = []; // 入队根节点 q.</description>
    </item>
    
    <item>
      <title>101.对称二叉树</title>
      <link>https://www.pengjielee.cn/post/leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 20 Mar 2021 09:52:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
1 / \ 2 2 \ \ 3 3 进阶：
你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 1、递归实现
/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ?</description>
    </item>
    
    <item>
      <title>104.二叉树的最大深度</title>
      <link>https://www.pengjielee.cn/post/leetcode/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sat, 20 Mar 2021 09:46:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例： 给定二叉树 [3,9,20,null,null,15,7]，
3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
补充 高度：从下往上。从最底层开始计数，计数起点是0；
深度：从上往下。从根节点开始计数，计数起点是0；
层次：与深度类似。计数起点是1；根节点在第1层；
节点的高度 = 节点到叶子节点的最长路径（边数）； 节点的深度 = 根节点到这个节点所经历的边的个数； 节点的层数 = 节点的深度 + 1；
树的高度 = 根节点的高度；
JS实现 1、递归实现
参考1：
/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function (root) { if (!</description>
    </item>
    
    <item>
      <title>088.合并两个有序数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/088.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 19 Mar 2021 17:06:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/088.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 提示：
nums1.length == m + n nums2.length == n 0 &amp;lt;= m, n &amp;lt;= 200 1 &amp;lt;= m + n &amp;lt;= 200 -10^9 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>Weekly-20210319</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2021.03.19/</link>
      <pubDate>Fri, 19 Mar 2021 16:03:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2021.03.19/</guid>
      <description>摘录 1、
人生就像一辆列车，当陪你的那个人要下车时，即使你再不舍，你也要心存感激挥手告别。
——宫崎骏
2、
内心真正富足的人，从不炫耀拥有的一切。
——亦舒《圆舞》
3、
优越感只不过是自卑感以倒立的姿态走路。
——《奥修著作》</description>
    </item>
    
    <item>
      <title>384.打乱数组</title>
      <link>https://www.pengjielee.cn/post/leetcode/384._%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 17 Mar 2021 17:29:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/384._%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</guid>
      <description>题目 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 示例：
输入 [&amp;#34;Solution&amp;#34;, &amp;#34;shuffle&amp;#34;, &amp;#34;reset&amp;#34;, &amp;#34;shuffle&amp;#34;] [[[1, 2, 3]], [], [], []] 输出 [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] 解释 Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2] 提示：</description>
    </item>
    
    <item>
      <title>169.多数元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/169.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 17 Mar 2021 16:45:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/169.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</guid>
      <description>题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1： 输入：[3,2,3] 输出：3
示例 2： 输入：[2,2,1,1,1,2,2] 输出：2
进阶：
尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/majority-element 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var majorityElement = function (nums) { let half = nums.length / 2; let obj = {}; for (let num of nums) { obj[num] = (obj[num] || 0) + 1; if (obj[num] &amp;gt; half) { return num; } } }; ES6 Map</description>
    </item>
    
    <item>
      <title>136.只出现一次的数字</title>
      <link>https://www.pengjielee.cn/post/leetcode/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 17 Mar 2021 16:44:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
位运算 异或运算：
任何数和 0 做异或运算，结果仍是原来的数； 任何数和其自身做异或运算，结果是0； 异或运算满足交换律和结合律； 位运算 XOR：当对一对数位进行位运算 XOR 时，如果数位是不同的则返回 1。
示例：
console.log(0 ^ 0); //0，规则1，规则2 console.log(0 ^ 1); //1，规则1 console.log(1 ^ 0); //1，规则1 console.log(1 ^ 1); //0，规则2 console.log(0 ^ 1); //1，规则1 console.log(0 ^ 10); //10，规则1 console.log(1 ^ 1); //0，规则2 console.log(2 ^ 2); //0，规则2 console.log(1 ^ 1 ^ 2); //2，规则1，2，3 console.</description>
    </item>
    
    <item>
      <title>实现EventEmitter</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0eventemitter/</link>
      <pubDate>Tue, 16 Mar 2021 21:02:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0eventemitter/</guid>
      <description>代码 // 组件通信，一个触发与监听的过程 class EventEmitter { constructor() { // 存储事件 this.events = this.events || new Map(); } // 监听事件 addListener(type, fn) { if (!this.events.get(type)) { this.events.set(type, fn); } } // 触发事件 emit(type) { let handle = this.events.get(type); handle.apply(this, [...arguments].slice(1)); } } Test // 测试 let emitter = new EventEmitter(); // 监听事件 emitter.addListener(&amp;#34;ages&amp;#34;, (age) =&amp;gt; { console.log(age); }); // 触发事件 emitter.emit(&amp;#34;ages&amp;#34;, 18); // 18 </description>
    </item>
    
    <item>
      <title>实现filter</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0filter/</link>
      <pubDate>Tue, 16 Mar 2021 21:01:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0filter/</guid>
      <description>实现myfilter Array.prototype._filter = function (fn) { const result = []; for (let i = 0; i &amp;lt; this.length; i++) { if (fn(this[i], i, this)) { result.push(this[i]); } } return result; }; Test var arr = [4, 5, 6, 7, 9, 10]; var result1 = arr.filter((el) =&amp;gt; el &amp;gt; 5); console.log(result1); //[6,7,9,10] var result2 = arr._filter((el) =&amp;gt; el &amp;gt; 5); console.log(result2); //[6,7,9,10] Polyfill filter 被添加到 ECMA-262 标准第 5 版中，因此在某些实现环境中不被支持。可以把下面的代码插入到脚本的开头来解决此问题，该代码允许在那些没有原生支持 filter 的实现环境中使用它。该算法是 ECMA-262 第 5 版中指定的算法，假定 fn.</description>
    </item>
    
    <item>
      <title>实现jsonp</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0jsonp/</link>
      <pubDate>Tue, 16 Mar 2021 21:01:08 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0jsonp/</guid>
      <description>实现 var Jsonp = { loadScript: function(url) { var script = document.createElement(&amp;#34;script&amp;#34;); script.type = &amp;#34;text/javascript&amp;#34;; if (script.readyState) { script.onreadystatechange = function() { if (this.readyState == &amp;#34;loaded&amp;#34; || this.readyState == &amp;#34;complete&amp;#34;) { this.onreadystatechange = null; document.body.removeChild(this); } }; } else { script.onload = function() { document.body.removeChild(this); }; } script.setAttribute(&amp;#39;src&amp;#39;, url); document.body.appendChild(script); }, encodeParameters: function(parameters) { var params = []; for (parameter in parameters) { params.push(escape(parameter) + &amp;#34;=&amp;#34; + escape(parameters[parameter])); } return params.</description>
    </item>
    
    <item>
      <title>054.螺旋矩阵</title>
      <link>https://www.pengjielee.cn/post/leetcode/054.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Tue, 16 Mar 2021 17:13:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/054.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
      <description>题目 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 1 2 3 4 5 6 7 8 9 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 1 2 3 4 5 6 7 8 9 10 11 12 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 10 -100 &amp;lt;= matrix[i][j] &amp;lt;= 100 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/spiral-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 JS实现 /** * @param {number[][]} matrix * @return {number[]} */ var spiralOrder = function (matrix) { let result = []; let left = 0, right = matrix[0].</description>
    </item>
    
    <item>
      <title>059.螺旋矩阵II</title>
      <link>https://www.pengjielee.cn/post/leetcode/059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</link>
      <pubDate>Tue, 16 Mar 2021 16:53:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</guid>
      <description>题目 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
示例 1： 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]]
示例 2： 输入：n = 1 输出：[[1]] 提示：
1 &amp;lt;= n &amp;lt;= 20
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/spiral-matrix-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number[][]} */ var generateMatrix = function (n) { let num = 1; const matrix = new Array(n).fill(0).map(() =&amp;gt; new Array(n).fill(0)); let left = 0, right = n - 1, top = 0, bottom = n - 1; while (left &amp;lt;= right &amp;amp;&amp;amp; top &amp;lt;= bottom) { //从左到右 for (let column = left; column &amp;lt;= right; column++) { matrix[top][column] = num; num++; } //从上到下 for (let row = top + 1; row &amp;lt;= bottom; row++) { matrix[row][right] = num; num++; } // 从右到左 for (let column = right - 1; column &amp;gt; left; column--) { matrix[bottom][column] = num; num++; } // 从下到上 for (let row = bottom; row &amp;gt; top; row--) { matrix[row][left] = num; num++; } left++; right--; top++; bottom--; } return matrix; }; </description>
    </item>
    
    <item>
      <title>026.删除有序数组中的重复项</title>
      <link>https://www.pengjielee.cn/post/leetcode/026.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Tue, 16 Mar 2021 15:29:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/026.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>题目 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); } 示例 1：
输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]</description>
    </item>
    
    <item>
      <title>001.两数之和</title>
      <link>https://www.pengjielee.cn/post/leetcode/001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Tue, 16 Mar 2021 15:28:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
你可以按任意顺序返回答案。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示：
2 &amp;lt;= nums.length &amp;lt;= 10^3 -10^9 &amp;lt;= nums[i] &amp;lt;= 10^9 -10^9 &amp;lt;= target &amp;lt;= 10^9 只会存在一个有效答案 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { // 创建一个hashmap const map = new Map(); // 遍历数组 for (let i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>实现防抖节流</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</link>
      <pubDate>Mon, 15 Mar 2021 17:12:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</guid>
      <description>防抖函数 1、防抖函数接收两个参数（运行函数，定时器时间间隔）；
2、防抖函数返回一个函数（闭包）；
3、闭包外定义定时器；
4、闭包里：
定义this，arguments； 首先清除定时器； 重新设置定时器； function debounce(fn, delay) { let timer = null; return function () { const self = this, args = arguments; timer &amp;amp;&amp;amp; clearTimeout(timer); timer = setTimeout(function () { fn.apply(self, args); }, delay); }; } 节流函数 1、节流函数有三个参数（运行的函数，定时器运行间隔，必须运行的时间间隔）；
2、节流函数返回一个函数（闭包）；
3、闭包外定义定时器，开始时间；
4、闭包里：
a. 定义this，arguments，当前时间；
b. 首先清除定时器；
c. 判断是否达到必须运行时间间隔： 达到，运行函数，重置开始时间为当前时间；
没达到，重新设置定时器；
// 简单的节流函数 function throttle(fn, wait, mustRun) { let timer, startTime = new Date(); return function () { const self = this, args = arguments, currentTime = new Date(); timer &amp;amp;&amp;amp; clearTimeout(timer); // 如果达到了规定的触发时间间隔，触发 handler if (currentTime - startTime &amp;gt;= mustRun) { fn.</description>
    </item>
    
    <item>
      <title>实现深拷贝</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Mon, 15 Mar 2021 17:00:34 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/</guid>
      <description>实现1 function deepClone(obj, hash = new WeakMap()) { if (obj instanceof RegExp) return new RegExp(obj); if (obj instanceof Date) return new Date(obj); if (obj === null || typeof obj != &amp;#34;object&amp;#34;) { return obj; // 如果不是复杂数据类型，直接返回 } if (hash.has(obj)) { return has.get(obj); } /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] **/ let t = new obj.constructor(); hash.set(obj, t); for (let key in obj) { if (obj.</description>
    </item>
    
    <item>
      <title>实现函数柯里化</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</link>
      <pubDate>Mon, 15 Mar 2021 16:54:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</guid>
      <description>代码 function curry(fn, currArgs) { return function () { let args = [].slice.call(arguments); // 首次调用时，若未提供最后一个参数currArgs，则不用进行args的拼接 if (currArgs !== undefined) { args = args.concat(currArgs); } // 递归调用 if (args.length &amp;lt; fn.length) { return curry(fn, args); } // 递归出口 return fn.apply(null, args); }; } Test function sum(a, b, c) { console.log(a + b + c); } const fn = curry(sum); fn(1, 2, 3); // 6 fn(1, 2)(3); // 6 fn(1)(2, 3); // 6 fn(1)(2)(3); // 6 </description>
    </item>
    
    <item>
      <title>实现缓存系统</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 15 Mar 2021 16:51:28 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/</guid>
      <description>题目 基于 localStorage 设计一个 1M 的缓存系统，需要实现缓存淘汰机制。
设计思路如下：
存储的每个对象需要添加两个属性：分别是过期时间和存储时间。 利用一个属性保存系统中目前所占空间大小，每次存储都增加该属性。当该属性值大于 1M 时，需要按照时间排序系统中的数据，删除一定量的数据保证能够存储下目前需要存储的数据。 每次取数据时，需要判断该缓存数据是否过期，如果过期就删除。 以下是代码实现，实现了思路，但是可能会存在 Bug，但是这种设计题一般是给出设计思路和部分代码，不会需要写出一个无问题的代码
class Store { constructor() { let store = localStorage.getItem(&amp;#34;cache&amp;#34;); if (!store) { store = { maxSize: 1024 * 1024, size: 0, }; this.store = store; } else { this.store = JSON.parse(store); } } set(key, value, expire) { this.store[key] = { date: Date.now(), expire, value, }; let size = this.sizeOf(JSON.stringify(this.store[key])); if (size + this.store.size &amp;gt; this.store.maxSize) { console.</description>
    </item>
    
    <item>
      <title>实现Ajax</title>
      <link>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0ajax/</link>
      <pubDate>Mon, 15 Mar 2021 15:48:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E5%AE%9E%E7%8E%B0ajax/</guid>
      <description>简单实现 var xhr = null; // Old compatibility code, no longer needed. if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ... xhr = new XMLHttpRequest(); } else if (window.ActiveXObject) { // IE 6 and older xhr = new ActiveXObject(&amp;#34;Microsoft.XMLHTTP&amp;#34;); } xhr.onreadystatechange = function () { // Process the server response here. if (xhr.readyState === XMLHttpRequest.DONE) { // Everything is good, the response was received. if (xhr.status === 200) { // Perfect! console.</description>
    </item>
    
    <item>
      <title>155.最小栈</title>
      <link>https://www.pengjielee.cn/post/leetcode/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</link>
      <pubDate>Mon, 15 Mar 2021 13:10:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</guid>
      <description>题目 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例:
输入： [&amp;#34;MinStack&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;getMin&amp;#34;,&amp;#34;pop&amp;#34;,&amp;#34;top&amp;#34;,&amp;#34;getMin&amp;#34;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.getMin(); --&amp;gt; 返回 -2. 提示：
pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-stack 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 栈特点：先进后出。
使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。
当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中； 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出； 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/min-stack/solution/zui-xiao-zhan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * initialize your data structure here.</description>
    </item>
    
    <item>
      <title>020.有效的括号</title>
      <link>https://www.pengjielee.cn/post/leetcode/020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Mon, 15 Mar 2021 13:10:10 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>题目 给定一个只包括 &amp;lsquo;(&amp;rsquo;，&amp;rsquo;)&amp;rsquo;，&amp;rsquo;{&amp;rsquo;，&amp;rsquo;}&amp;rsquo;，&amp;rsquo;[&amp;rsquo;，&amp;rsquo;]&amp;rsquo; 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = &amp;#34;()&amp;#34; 输出：true 示例 2： 输入：s = &amp;#34;()[]{}&amp;#34; 输出：true 示例 3： 输入：s = &amp;#34;(]&amp;#34; 输出：false 示例 4： 输入：s = &amp;#34;([)]&amp;#34; 输出：false 示例 5： 输入：s = &amp;#34;{[]}&amp;#34; 输出：true 提示：
1 &amp;lt;= s.length &amp;lt;= 10^4； s 仅由括号 &amp;lsquo;()[]{}&amp;rsquo; 组成； 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 我们遍历字符串中的所有字符：
1、如果遇到了左括号，就把对应的右括号压栈（比如遇到了字符&amp;rsquo;(&amp;rsquo;，就把字符&amp;rsquo;)&amp;lsquo;压栈）。
2、如果遇到了右括号
查看栈是否为空，如果为空，说明不能构成有效的括号，直接返回false。 如果栈不为空，栈顶元素出栈，然后判断出栈的这个元素是否等于这个右括号，如果不等于，说明不匹配，直接返回false。如果匹配，就继续判断字符串的下一个字符。 3、最后如果栈为空，说明是完全匹配，是有效的括号，否则如果栈不为空，说明不完全匹配，不是有效的括号。
作者：数据结构和算法 链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnbcaj/?discussion=rj6XSA 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 参考1:
/** * @param {string} s * @return {boolean} */ var isValid = function (s) { const stack = []; const map = { &amp;#34;(&amp;#34;: &amp;#34;)&amp;#34;, &amp;#34;[&amp;#34;: &amp;#34;]&amp;#34;, &amp;#34;{&amp;#34;: &amp;#34;}&amp;#34;, }; //遍历字符串 for (let char of s) { //如果map结构中存在左括号，把左括号入栈 if (char in map) { stack.</description>
    </item>
    
    <item>
      <title>083.删除排序链表中的重复元素</title>
      <link>https://www.pengjielee.cn/post/leetcode/083.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 15 Mar 2021 11:45:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/083.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid>
      <description>题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例 1: 输入: 1-&amp;gt;1-&amp;gt;2 输出: 1-&amp;gt;2 示例 2: 输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 输出: 1-&amp;gt;2-&amp;gt;3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function (head) { let current = head; while (current != null &amp;amp;&amp;amp; current.</description>
    </item>
    
    <item>
      <title>021.合并两个有序链表</title>
      <link>https://www.pengjielee.cn/post/leetcode/021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 15 Mar 2021 11:45:10 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示：
两个链表的节点数目范围是 [0, 50] -100 &amp;lt;= Node.val &amp;lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.</description>
    </item>
    
    <item>
      <title>069.x的平方根</title>
      <link>https://www.pengjielee.cn/post/leetcode/069.x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</link>
      <pubDate>Mon, 15 Mar 2021 10:10:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/069.x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</guid>
      <description>题目 实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sqrtx 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于 x 平方根的整数部分ans 是满足 k^2 &amp;lt;= x 的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。
二分查找的下界为 0，上界可以粗略地设定为 x。
作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number} x * @return {number} */ var mySqrt = function (x) { if (x &amp;lt; 2) { return x; } let low = 1, high = Math.</description>
    </item>
    
    <item>
      <title>035.搜索插入位置</title>
      <link>https://www.pengjielee.cn/post/leetcode/035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 15 Mar 2021 09:48:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
示例 1: 输入: [1,3,5,6], 5 输出: 2
示例 2: 输入: [1,3,5,6], 2 输出: 1
示例 3: 输入: [1,3,5,6], 7 输出: 4
示例 4: 输入: [1,3,5,6], 0 输出: 0
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-insert-position 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @param {number} target * @return {number} */ var searchInsert = function (nums, target) { let low = 0, high = nums.length - 1; while (low &amp;lt;= high) { let mid = parseInt(low + (high - low) / 2); if (nums[mid] === target) { return mid; } else if (nums[mid] &amp;lt; target) { low = mid + 1; } else { high = mid - 1; } } return low; }; </description>
    </item>
    
    <item>
      <title>React高级：性能优化</title>
      <link>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 13 Mar 2021 17:27:11 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>创建项目 $ npx create-react-app react-try 情景一：shouldComponentUpdate Child.js
import React from &amp;#39;react&amp;#39;; class Child extends React.Component { constructor(props) { super(props); } componentDidMount() { console.log(&amp;#39;child did mount&amp;#39;); } componentWillUnmount() { console.log(&amp;#39;child will mount&amp;#39;); } render() { console.log(&amp;#39;child render&amp;#39;); return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;This is Child&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; ); } } export default Child; Parent.js
import React from &amp;#39;react&amp;#39;; import Child from &amp;#39;./Child&amp;#39;; class Parent extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; this.</description>
    </item>
    
    <item>
      <title>React高级：事件机制</title>
      <link>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 13 Mar 2021 17:24:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>1、 import React from &amp;#34;react&amp;#34;; export default class App extends React.Component { innerClick = () =&amp;gt; { console.log(&amp;#34;A: react inner click.&amp;#34;); }; outerClick = () =&amp;gt; { console.log(&amp;#34;B: react outer click.&amp;#34;); }; componentDidMount() { document.getElementById(&amp;#34;outer&amp;#34;).addEventListener(&amp;#34;click&amp;#34;, () =&amp;gt; { console.log(&amp;#34;C: native outer click&amp;#34;); }); document.getElementById(&amp;#34;inner&amp;#34;).addEventListener(&amp;#34;click&amp;#34;, () =&amp;gt; { console.log(&amp;#34;D: native inner click&amp;#34;); }); } render() { return ( &amp;lt;div id=&amp;#34;outer&amp;#34; onClick={this.outerClick}&amp;gt; &amp;lt;button id=&amp;#34;inner&amp;#34; onClick={this.innerClick}&amp;gt; BUTTON &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); } } 输出：</description>
    </item>
    
    <item>
      <title>React高级：diff算法</title>
      <link>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7diff%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 13 Mar 2021 17:12:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7diff%E7%AE%97%E6%B3%95/</guid>
      <description>More 虚拟 DOM 到底是什么？ https://juejin.cn/post/6844903870229905422#heading-6
让虚拟DOM和DOM-diff不再成为你的绊脚石
https://juejin.im/post/5c8e5e4951882545c109ae9c#heading-12
snabbdom https://github.com/snabbdom/snabbdom
virtual-dom https://github.com/Matt-Esch/virtual-dom</description>
    </item>
    
    <item>
      <title>React高级：虚拟DOM</title>
      <link>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7%E8%99%9A%E6%8B%9Fdom/</link>
      <pubDate>Sat, 13 Mar 2021 15:37:28 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7%E8%99%9A%E6%8B%9Fdom/</guid>
      <description>什么是虚拟DOM 虚拟DOM就是一个普通的 JavaScript 对象，包含了 tag、props、children 三个属性。
虚拟 DOM 的优势是：
diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗； 抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI。 定义JSX // 使用jsx定义的元素 const element = &amp;lt;h1 title=&amp;#34;foo&amp;#34;&amp;gt;Hello&amp;lt;/h1&amp;gt; // 获取根节点 const container = document.getElementById(&amp;#34;root&amp;#34;); // 插入元素到真实DOM树中 ReactDOM.render(element, container) JSX编译为React.createElement // 使用babel将jsx编译为React.createElement方法 const element = React.createElement( &amp;#34;h1&amp;#34;, { title: &amp;#34;foo&amp;#34; }, &amp;#34;Hello&amp;#34; ) ​ const container = document.getElementById(&amp;#34;root&amp;#34;) ReactDOM.render(element, container) 使用Babel编译JSX // 创建test目录 $ mkdri test $ cd test // 初始化项目 $ npm init -y // 安装依赖 $ npm install --save-dev @babel/core @babel/cli $ npm install --save-dev @babel/preset-react 创建babel.</description>
    </item>
    
    <item>
      <title>React高级：JSX</title>
      <link>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7jsx/</link>
      <pubDate>Sat, 13 Mar 2021 13:46:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/react%E9%AB%98%E7%BA%A7jsx/</guid>
      <description>jsx句法 /** @jsx h */ let foo = &amp;lt;div id=&amp;#34;foo&amp;#34; className=&amp;#34;foo&amp;#34;&amp;gt;Hello!&amp;lt;/div&amp;gt; h函数 function h(nodeName, attributes, ...args) { let children = args.length ? [].concat(...args) : null; return { nodeName, attributes, children, }; } JSX编译 h(&amp;#39;div&amp;#39;, {id: &amp;#34;foo&amp;#34;, className: &amp;#34;foo&amp;#34;}, &amp;#39;Hello!&amp;#39;); JSX编译为虚拟DOM var foo = h(&amp;#39;div&amp;#39;, {id: &amp;#34;foo&amp;#34;, className: &amp;#34;foo&amp;#34;}, &amp;#39;Hello!&amp;#39;); //Output: { &amp;#34;nodeName&amp;#34;: &amp;#34;div&amp;#34;, &amp;#34;attributes&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;foo&amp;#34;, &amp;#34;className&amp;#34;: &amp;#34;foo&amp;#34; }, &amp;#34;children&amp;#34;: [&amp;#34;Hello!&amp;#34;] } render函数 function render(vnode) { // Strings just convert to #text Nodes: if (typeof vnode === &amp;#39;string&amp;#39;) { return document.</description>
    </item>
    
    <item>
      <title>50.数组中重复的数字</title>
      <link>https://www.pengjielee.cn/post/sword/array_50.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 12 Mar 2021 15:17:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/array_50.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
详解 排序：将输入数组排序，再判断相邻位置是否存在相同数字，如果存在，对 duplication 赋值返回，否则继续比较
JS实现 function duplicate(numbers, duplication) { // write code here if (numbers.length &amp;lt;= 0) { return false; } numbers = numbers.sort(); for (let i = 0; i &amp;lt; numbers.length - 1; i++) { if (numbers[i] === numbers[i + 1]) { duplication[0] = numbers[i]; return true; } } return false; } Go实现 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sort&amp;#34; ) func main() { nums := []int{3, 1, 0, 2, 5, 3, 5} fmt.</description>
    </item>
    
    <item>
      <title>47.求1&#43;2&#43;3&#43;...&#43;n</title>
      <link>https://www.pengjielee.cn/post/sword/47.%E6%B1%821&#43;2&#43;3&#43;...&#43;n/</link>
      <pubDate>Fri, 12 Mar 2021 15:16:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/47.%E6%B1%821&#43;2&#43;3&#43;...&#43;n/</guid>
      <description>题目 求1+2+3+&amp;hellip;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
详解 短路原理
JS实现 function Sum_Solution(n) { // write code here let result = n; result &amp;amp;&amp;amp; (result += Sum_Solution(n - 1)); return result; } </description>
    </item>
    
    <item>
      <title>45.扑克牌顺子</title>
      <link>https://www.pengjielee.cn/post/sword/45.%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</link>
      <pubDate>Fri, 12 Mar 2021 15:16:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/45.%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</guid>
      <description>题目 LL今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王(一副牌原本是54张^ _ ^)&amp;hellip;他随机从中抽出了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！&amp;ldquo;红心A，黑桃3，小王，大王，方片5&amp;rdquo;，&amp;ldquo;Oh My God!&amp;ldquo;不是顺子&amp;hellip;..
LL不高兴了，他想了想，决定大小 王可以看成任何数字，并且A看作1，J为11，Q为12，K为13。上面的5张牌就可以变成&amp;quot;1，2，3，4，5&amp;rdquo;(大小王分别看作2和4)，&amp;ldquo;So Lucky!&amp;quot;。LL决定去买体育彩票啦。
现在，要求你使用这幅牌模拟上面的过程，然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见，你可以认为大小王是0。
详解 说了那么多，其实就是给一个数字数组，然后判断是否符合以下五个条件：
必须是五个数； 数字范围必须是 0 - 13； 大王小王可以跳过； 最大和最小的数相减必须少于5； 除了大王和小王，其他数字只能出现1次； JS实现 function IsContinuous(numbers) { if (numbers.length &amp;lt; 5) { return false; } let min = 14; let max = -1; let obj = {}; for (let i = 0; i &amp;lt; numbers.length; i++) { if (numbers[i] &amp;lt; 0 || numbers[i] &amp;gt; 13) { return false; } if (numbers[i] === 0) { continue; } if (obj[numbers[i]]) { return false; } obj[numbers[i]] = true; if (numbers[i] &amp;lt; min) { min = numbers[i]; } if (numbers[i] &amp;gt; max) { max = numbers[i]; } if (max - min &amp;gt;= 5) { return false; } } return true; } More 剑指OFFER&amp;mdash;-61、扑克牌顺子(js实现)</description>
    </item>
    
    <item>
      <title>67.剪绳子.md</title>
      <link>https://www.pengjielee.cn/post/sword/67.%E5%89%AA%E7%BB%B3%E5%AD%90/</link>
      <pubDate>Fri, 12 Mar 2021 15:04:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/67.%E5%89%AA%E7%BB%B3%E5%AD%90/</guid>
      <description>题目 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为k[0],k[1],&amp;hellip;,k[m]。 请问k[0] x k[1] x &amp;hellip; x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
输入描述: 输入一个数n，意义见题面。（2 &amp;lt;= n &amp;lt;= 60） 输出描述: 输出答案。 示例1 输入 8 输出 18 详解 动态规划（自底向上）
使用动态规划，从已知值 F(2) 逐步迭代到目标值 F(n)，它是一种自底向上的方法。
算法:
建立一维动态数组 dp； 边界条件：dp[1] = dp[2] = 1，表示长度为 2 的绳子最大乘积为 1； 状态转移方程：dp[i] = max(dp[i], max((i - j) * j, j * dp[i - j]))，可以这样理解： dp[i] = max(【dp[i]】, max(【(i - j) * j】, 【j * dp[i - j]】)) 【】0，维护原状态，不剪； 【】1，从j处剪一下，剪下来的部分是i-j，i-j不再剪了； 【】2，从j处剪一下，剪下来的部分是i-j，i-j继续剪； JS实现 确定边界条件和状态转移方程：</description>
    </item>
    
    <item>
      <title>Weekly-20210312</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2021.03.12/</link>
      <pubDate>Fri, 12 Mar 2021 14:43:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2021.03.12/</guid>
      <description>摘录 1、
只要想起一生中后悔的事
梅花便落了下来
比如看她游泳到河的另一岸
比如登上一株松木梯子
危险的事固然美丽
不如看她骑马归来
面颊温暖，
羞惭。低下头，回答着皇帝
一面镜子永远等候她
让她坐到镜中常坐的地方
望着窗外，只要想起一生中后悔的事
梅花便落满了南山
—— 张枣《镜中》
文章 35岁，他们决定考研
https://mp.weixin.qq.com/s/u1x9x7z6d7VQQKeew3YVsg
我的一些关于职场和职业发展的心得
https://mp.weixin.qq.com/s/kJkJZGSqiCpd8vHQYMRCvg
提高国内访问 GitHub 的速度的 9 种方案 https://mp.weixin.qq.com/s/P-4Dh6yLfEXL7f4RS0xd6A</description>
    </item>
    
    <item>
      <title>判断对称二叉树</title>
      <link>https://www.pengjielee.cn/algorithm/determine-symmetric-binary-tree/</link>
      <pubDate>Thu, 11 Mar 2021 13:42:28 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/determine-symmetric-binary-tree/</guid>
      <description>二叉树【 每个节点最多有两个子节点。
10 / \ 9 20 / \ 15 35 二叉树的特点：
每个节点最多有两个子树，节点的度最大为2； 左子树和右子树是有顺序的，次序不能颠倒； 即使某节点只有一个子树，也要区分左右子树； 对称二叉树 如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
10 / \ 5 5 / \ / \ 1 4 4 1 实现思路:
判断根节点相同； 左子树的右节点和右子树的左节点相同； 右子树的左节点和左子树的右节点相同； 模拟一个对称二叉树和非对称二叉树：
//对称二叉树 const symmetricalTree = { val: 8, left: { val: 6, left: { val: 5, left: null, right: null }, right: { val: 7, left: null, right: null }, }, right: { val: 6, left: { val: 7, left: null, right: null }, right: { val: 5, left: null, right: null }, }, }; //非对称二叉树 const binaryTree = { val: 8, left: { val: 6, left: { val: 5, left: null, right: null }, right: { val: 7, left: null, right: null }, }, right: { val: 9, left: { val: 7, left: null, right: null }, right: { val: 5, left: null, right: null }, }, }; JS实现 利用递归实现对称二叉树判断</description>
    </item>
    
    <item>
      <title>二叉查找树</title>
      <link>https://www.pengjielee.cn/algorithm/binary-search-tree/</link>
      <pubDate>Wed, 10 Mar 2021 15:25:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/binary-search-tree/</guid>
      <description>二叉查找树 二叉查找树(binary search tree)：当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大。
class TreeNode { constructor(data) { this.data = data; this.left = null; this.right = null; } } class BinarySearchTree { constructor() { this.root = null; } insert(data) { var newNode = new TreeNode(data); if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); } } insertNode(node, newNode) { if (newNode.data &amp;lt; node.data) { if (node.left === null) { node.left = newNode; } else { this.</description>
    </item>
    
    <item>
      <title>06.旋转数组的最小数字</title>
      <link>https://www.pengjielee.cn/post/sword/array_06.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 10 Mar 2021 14:18:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/array_06.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid>
      <description>题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组 {3,4,5,1,2} 为 {1,2,3,4,5} 的一个旋转，该数组的最小值为1。
原来的：{1,2,3,4,5}
旋转后：{3,4,5,1,2}
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
详解 旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的值 都大于 后面子数组中的元素。
注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。
思路：
我们用两个指针left，right分别指向数组的第一个元素和最后一个元素。 按照题目的旋转的规则，第一个元素应该是大于最后一个元素的没. 重复的元素）。 但是如果不是旋转，第一个元素肯定小于最后一个元素。
找到数组的中间元素。 中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。 移动之后，第一个指针仍然位于前面的递增数组中。 中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。 移动之后，第二个指针仍然位于后面的递增数组中。 这样可以缩小寻找的范围。 按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。 最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。 也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。
到目前为止以上思路很耗的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。
因此这一道题目比上一道题目多了些特殊情况：
我们看一组例子：｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。
这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。
第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。
因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。 也就无法移动指针来缩小查找的范围。
牛客网
https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba?f=discussion
JS实现 function minNumberInRotateArray(rotateArray) { // write code here const len = rotateArray.length; if (len === 0) { return 0; } let low = 0; let high = len - 1; while (low &amp;lt; high) { const mid = low + Math.</description>
    </item>
    
    <item>
      <title>02.替换空格</title>
      <link>https://www.pengjielee.cn/post/sword/string_02.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link>
      <pubDate>Wed, 10 Mar 2021 14:15:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/string_02.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid>
      <description>题目 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy。则经过替换之后的字符串为We%20Are%20Happy。
JS实现 //实现1：调用自带函数 function replaceSpace(str) { // write code here return str.replace(/\s{1}/g, &amp;#34;%20&amp;#34;); } //实现2：用新的变量存，当遇到 &amp;#34; &amp;#34;，就追加 &amp;#34;%20&amp;#34;，否则遇到什么追加什么 function replaceSpace(str) { // write code here let result = &amp;#34;&amp;#34;; for (let i = 0; i &amp;lt; str.length; i++) { if (str[i] === &amp;#34; &amp;#34;) { result += &amp;#34;%20&amp;#34;; } else { result += str[i]; } } return result; } Go实现 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { str := &amp;#34;We are happy.</description>
    </item>
    
    <item>
      <title>04.重建二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 10 Mar 2021 11:33:30 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
详解 前序：根-&amp;gt;左-&amp;gt;右 {1,2,4,7,3,5,6,8} 中序：左-&amp;gt;根-&amp;gt;右 {4,7,2,1,5,3,8,6}
根据中序遍历和前序遍历可以确定二叉树，具体过程为：
根据前序序列第一个结点确定根结点； 根据根结点在中序序列中的位置分割出左右两个子序列； 对左子树和右子树分别递归使用同样的方法继续分解； 例如： 前序序列{1,2,4,7,3,5,6,8} = pre 中序序列{4,7,2,1,5,3,8,6} = in
根据当前前序序列的第一个结点确定根结点，为 1 找到 1 在中序遍历序列中的位置，为 in[3] 切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树 则切割后的左子树前序序列为：{2,4,7}，切割后的左子树中序序列为：{4,7,2}；切割后的右子树前序序列为：{3,5,6,8}，切割后的右子树中序序列为：{5,3,8,6} 对子树分别使用同样的方法分解 链接：https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6?answerType=1&amp;amp;f=discussion 来源：牛客网
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function reConstructBinaryTree(pre, vin) { // write code here if (pre.length === 0 || vin.length === 0) { return null; } //前序的第一个节点为根节点 let root = new TreeNode(pre[0]); //在中序中找到根节点 for (let i = 0; i &amp;lt; vin.</description>
    </item>
    
    <item>
      <title>01.二维数组中的查找</title>
      <link>https://www.pengjielee.cn/post/sword/array_01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Wed, 10 Mar 2021 10:31:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/array_01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>题目 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] 详解 暴力法 挨个遍历数组，如果找到就返回 true
时间复杂度：O(n^2) 空间复杂度：O(1)
从左下找 利用该二维数组的性质：
每一行都按照从左到右递增的顺序排序， 每一列都按照从上到下递增的顺序排序 换个说法，即对于左下角的值 m，m 是该行最小的数，是该列最大的数
每次将 m 和目标值 target 比较：
当 m &amp;lt; target，由于 m 已经是该行最大的元素，想要更大只有从列考虑，取值右移一位 当 m &amp;gt; target，由于 m 已经是该列最小的元素，想要更小只有从行考虑，取值上移一位 当 m = target，找到该值，返回 true 用某行最小或某列最大与 target 比较，每次可剔除一整行或一整列。
时间复杂度：O(行高 + 列宽) 空间复杂度：O(1)
从右上找 和从左下找道理一样，都是因为每次判断都能剔除一整行或一整列
时间复杂度：O(行高 + 列宽) 空间复杂度：O(1)
链接：https://www.nowcoder.com/questionTerminal/abc3fe2ce8e146608e868a70efebf62e?answerType=1&amp;amp;f=discussion 来源：牛客网
JS实现 //暴力法 function Find(target, array) { // write code here for (let i = 0; i &amp;lt; array.</description>
    </item>
    
    <item>
      <title>17.树的子结构</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 10 Mar 2021 10:29:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>题目 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function HasSubtree(root1, root2) { // write code here if (root1 === null || root2 === null) { return false; } let result = false; if (root1.val === root2.val) { result = helper(root1, root2); } if (!result) { result = helper(root1.left, root2); } if (!result) { result = helper(root1.right, root2); } return result; } function helper(r1, r2) { if (r2 === null) return true; if (r1 === null) return false; if (r1.</description>
    </item>
    
    <item>
      <title>19.顺时针打印矩阵</title>
      <link>https://www.pengjielee.cn/post/sword/19.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Wed, 10 Mar 2021 10:17:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/19.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>题目 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字， 例如，
如果输入如下4 X 4矩阵：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10.
详解 简单来说，就是不断地收缩矩阵的边界。
定义四个变量代表范围，up、down、left、right
向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错 向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错 向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错 链接：https://www.nowcoder.com/questionTerminal/9b4c81a02cd34f76be2659fa0d54342a?answerType=1&amp;amp;f=discussion
来源：牛客网
JS实现 function printMatrix(matrix) { // write code here let result = []; if (matrix === null || matrix.</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://www.pengjielee.cn/algorithm/binary-tree/</link>
      <pubDate>Tue, 09 Mar 2021 15:18:47 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/binary-tree/</guid>
      <description>树的概念 节点分类：
根节点 子节点 叶子节点 兄弟节点 其他：
树的深度：从根节点到最底层节点的层数。 树的深度：树中节点的最大层次称为树的深度（或树的高度）。 节点的度：节点拥有的子树数称为节点的度。 叶子节点：度为0的节点称为叶节点（或终端节点）。 分支节点：度不为0的节点称为分支节点（或非终端节点）。 树的度：树内各节点的度的最大值。 节点层次：从根开始，根为第一层，根的孩子为第二层。 二叉树 二叉树：每个节点最多有两个子节点。
10 / \ 9 20 / \ 15 35 二叉树的操作：
1、创建二叉树； 2、遍历二叉树；
先序遍历：先访问根节点，然后访问左节点，最后访问右节点（根-&amp;gt;左-&amp;gt;右）10-&amp;gt;9-&amp;gt;20-&amp;gt;15-&amp;gt;35 中序遍历：先访问左节点，然后访问根节点，最后访问右节点（左-&amp;gt;根-&amp;gt;右）9-&amp;gt;10-&amp;gt;15-&amp;gt;20-&amp;gt;35 后序遍历：先访问左节点，然后访问右节点，最后访问根节点（左-&amp;gt;右-&amp;gt;根）9-&amp;gt;15-&amp;gt;35-&amp;gt;20-&amp;gt;10 3、查询树的深度；
4、查询树的最大值；
通过先序和中序/中序和后序我们可以还原出原始的二叉树，但是通过先序和后序是无法还原出原始的二叉树的。（？）
二叉树的特点：
每个节点最多有两个子树，节点的度最大为2； 左子树和右子树是有顺序的，次序不能颠倒； 即使某节点只有一个子树，也要区分左右子树； 特殊的二叉树 1、斜树
所有的节点都只有左子树（左斜树），或者只有右子树（右斜树）。
2、满二叉树
所有的分支节点都存在左子树和右子树，并且所有的叶子结点都在同一层上。
满二叉树的特点：
叶子只能出现在最下一层； 非叶子节点度一定是2； 在同样深度的二叉树中，满二叉树的节点个数最多，叶子树最多； 3、完全二叉树
对一棵具有n个结点的二叉树按层序排号，如果编号为i的结点与同样深度的满二叉树编号为i结点在二叉树中位置完全相同，就是完全二叉树。
满二叉树必须是完全二叉树，反过来不一定成立。
对一棵具有n个节点的二叉树按层序编号，如果编号为i（1&amp;lt;=i&amp;lt;=n）的节点与同样深度的满二叉树中编号为i的节点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
完全二叉树特点：
叶子节点只能出现在最下一层（满二叉树继承而来）； 最下层叶子节点一定集中在左 部连续位置； 倒数第二层，如有叶子节点，一定出现在右部连续位置； 同样节点树的二叉树，完全二叉树的深度最小（满二叉树也是对的）； </description>
    </item>
    
    <item>
      <title>二叉树遍历</title>
      <link>https://www.pengjielee.cn/algorithm/binary-tree-traversal/</link>
      <pubDate>Tue, 09 Mar 2021 15:03:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/binary-tree-traversal/</guid>
      <description>树结构多种多样，我们最常用的还是二叉树。
特殊二叉树 1、满二叉树；
2、完全二叉树；
二叉树的存储 1、基于指针或者引用的二叉链式存储法；
2、基于数组的顺序存储法；
我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。
如果节点x存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i / 2 的位置存储的就是它的父节点。
通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为1的位置），这样就可以通过下标计算，把整棵树都串起来。
二叉树的遍历 前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。
前序遍历的递推公式：
preOrder(root) = print root-&amp;gt;preOrder(root-&amp;gt;left)-&amp;gt;preOrder(root-&amp;gt;right)
中序遍历的递推公式：
inOrder(root) = inOrder(root-&amp;gt;left)-&amp;gt;print root-&amp;gt;inOrder(root-&amp;gt;right)
后序遍历的递推公式：
postOrder(root) = postOrder(root-&amp;gt;left)-&amp;gt;postOrder(root-&amp;gt;right)-&amp;gt;postOrder
// 前序：根 -&amp;gt; 左 -&amp;gt; 右 void preOrder(Node* root){ if(root == null) return; print root; // 先打印根节点 preOrder(root-&amp;gt;left); preOrder(root-&amp;gt;right); } // 中序： 左 -&amp;gt; 根 -&amp;gt; 右 void inOrder(Node* root){ if(root == null) return; inOrder(root-&amp;gt;left); print(root); // 中间打印根节点 inOrder(root-&amp;gt;right); } // 后序：左 -&amp;gt; 右 -&amp;gt; 根 void postOrder(Node* root){ if(root == null) return; postOrder(root-&amp;gt;left); postOrder(root-&amp;gt;right); print root; // 最后打印根节点 } 通过遍历序列构造二叉树 给定二叉树: [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 前序遍历：3,9,null,null,20,15,7 中序遍历：null,9,null,3,15,20,7 后序遍历：null,null,9,15,7,20,3 1、前序和中序遍历序列构造二叉树：</description>
    </item>
    
    <item>
      <title>React教程：绑定事件</title>
      <link>https://www.pengjielee.cn/post/react-tutorial-bind-events/</link>
      <pubDate>Tue, 09 Mar 2021 11:08:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/react-tutorial-bind-events/</guid>
      <description>1、在构造函数中绑定事件
class Item extends React.Component { constructor(props) { super(props); this.state = { number: 0, }; this.handleClick = this.handleClick.bind(this); } handleClick() { console.log(&amp;#39;click&amp;#39;); this.setState({ number: this.state.number + 1, }); } render() { return ( &amp;lt;div&amp;gt; &amp;lt;span style={{ marginRight: &amp;#39;5px&amp;#39; }}&amp;gt;number: {this.state.number}&amp;lt;/span&amp;gt; &amp;lt;button onClick={this.handleClick}&amp;gt;click&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); } } 2、在render中绑定 this
class Item extends React.Component { constructor(props) { super(props); this.state = { number: 0, }; } handleClick() { console.log(&amp;#39;click&amp;#39;); this.setState({ number: this.state.number + 1, }); } render() { return ( &amp;lt;div&amp;gt; &amp;lt;span style={{ marginRight: &amp;#39;5px&amp;#39; }}&amp;gt;number: {this.</description>
    </item>
    
    <item>
      <title>React教程：useMemo用法</title>
      <link>https://www.pengjielee.cn/post/react-tutorial-usememo-usage/</link>
      <pubDate>Tue, 09 Mar 2021 09:11:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/react-tutorial-usememo-usage/</guid>
      <description>看代码 import React, { useState } from &amp;#39;react&amp;#39;; // 计算斐波那契数 const fibc = n =&amp;gt; { console.log(&amp;#39;calculate...&amp;#39;); if (n &amp;lt;= 2) { return 1; } return fibc(n - 1) + fibc(n - 2); }; const Fibc = props =&amp;gt; { let [number, setNumber] = useState(1); let [count, setCount] = useState(0); // 优化前 const result = fibc(number); return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;number: {number}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;count: {count}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;fibc result: {result}&amp;lt;/p&amp;gt; &amp;lt;button onClick={() =&amp;gt; setNumber(number + 1)}&amp;gt;add number&amp;lt;/button&amp;gt; &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt;add count&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); }; export default Fibc; 问题:</description>
    </item>
    
    <item>
      <title>React教程：设置样式</title>
      <link>https://www.pengjielee.cn/post/react-tutorial-set-the-style/</link>
      <pubDate>Tue, 09 Mar 2021 09:11:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/react-tutorial-set-the-style/</guid>
      <description>设置行内样式 1、使用行内 style 样式
import React from &amp;#39;react&amp;#39;; const Home = props =&amp;gt; { const name = &amp;#39;Home Page&amp;#39;; return ( &amp;lt;div style={{ backgroundColor: &amp;#39;#ddd&amp;#39;, color: &amp;#39;red&amp;#39;, fontSize: &amp;#39;30px&amp;#39;, paddingLeft: &amp;#39;20px&amp;#39;, }}&amp;gt; { name } &amp;lt;/div&amp;gt; ); }; export default Home; 注意：
行内样式的属性名需使用驼峰命名。 行内样式需要使用双大括号{{ }}，变量用单个大括号{ } 2、使用分离的 style 对象
import React from &amp;#39;react&amp;#39;; const Home = props =&amp;gt; { const name = &amp;#39;Home Page&amp;#39;; const nameStyle = { backgroundColor: &amp;#39;#333&amp;#39;, color: &amp;#39;#fff&amp;#39;, fontSize: &amp;#39;30px&amp;#39;, paddingLeft: &amp;#39;20px&amp;#39;, marginTop: &amp;#39;10px&amp;#39;, }; return ( &amp;lt;div&amp;gt; &amp;lt;div style={nameStyle}&amp;gt;{name}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ); }; export default Home; 设置多个class 1、使用join拼接</description>
    </item>
    
    <item>
      <title>Webpack多页面应用4：动态获取入口</title>
      <link>https://www.pengjielee.cn/post/webpack-multi-page-application4/</link>
      <pubDate>Mon, 08 Mar 2021 16:26:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/webpack-multi-page-application4/</guid>
      <description>问题 每次创建新的页面时，如果都要去更改webpack的入口 配置文件，那样太不爽了，我们改造我们的代码来动态获取入口文件。
改造 1、安装glob
$ npm install glob -D 2、动态获取目录中的文件
const glob = require(&amp;#39;glob&amp;#39;); /* * 1. 我们以文件夹里是否有html文件为准，来判断是否需要生成多页面 * 2. 我们的多页应用目录最多支持三级 */ const pages = glob.sync(&amp;#39;./src/pages/**?/**/index.html&amp;#39;).map(item =&amp;gt; { /* * pathArr * = [ &amp;#39;.&amp;#39;, &amp;#39;src&amp;#39;, &amp;#39;pages&amp;#39;, &amp;#39;home&amp;#39;, &amp;#39;index.html&amp;#39; ] * = [ &amp;#39;.&amp;#39;, &amp;#39;src&amp;#39;, &amp;#39;pages&amp;#39;, &amp;#39;blog&amp;#39;, &amp;#39;list&amp;#39;, &amp;#39;index.html&amp;#39; ] * = [ &amp;#39;.&amp;#39;, &amp;#39;src&amp;#39;, &amp;#39;pages&amp;#39;, &amp;#39;blog&amp;#39;, &amp;#39;list&amp;#39;, &amp;#39;detail&amp;#39;, &amp;#39;index.html&amp;#39; ] */ const pathArr = item.split(&amp;#39;/&amp;#39;); // 从第3个截取至倒数第一个，为我们的文件名 return pathArr.</description>
    </item>
    
    <item>
      <title>Webpack多页面应用3：快速创建页面</title>
      <link>https://www.pengjielee.cn/post/webpack-multi-page-application3/</link>
      <pubDate>Mon, 08 Mar 2021 15:55:42 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/webpack-multi-page-application3/</guid>
      <description>安装依赖 $ npm install chalk inquirer fs-extra -D chalk，终端美化； inquirer，命令行交互工具； fs-extra，fs模块的增加版； 创建页面的脚本 newPage.js
const path = require(&amp;#39;path&amp;#39;); const chalk = require(&amp;#39;chalk&amp;#39;); const inquirer = require(&amp;#39;inquirer&amp;#39;); const fs = require(&amp;#39;fs-extra&amp;#39;); // 获取传递的参数 const options = process.argv.slice(2); const name = options[0]; // 创建html文件 const createHtml = function(desFilePath, dirName) { const content = `&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1, shrink-to-fit=no&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;keywords&amp;#34; content=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;&amp;#34;/&amp;gt; &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.</description>
    </item>
    
    <item>
      <title>Webpack多页面应用2：添加React</title>
      <link>https://www.pengjielee.cn/post/webpack-multi-page-application2/</link>
      <pubDate>Mon, 08 Mar 2021 15:36:08 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/webpack-multi-page-application2/</guid>
      <description>添加 React $ npm install react react-com home/index.js
import React from &amp;#39;react&amp;#39;; import ReactDOM from &amp;#39;react-dom&amp;#39;; function App() { return &amp;lt;h1&amp;gt;About page - Rendered by React&amp;lt;/h1&amp;gt;; } ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;)); about/index.js
import React from &amp;#39;react&amp;#39;; import ReactDOM from &amp;#39;react-dom&amp;#39;; function App() { return &amp;lt;h1&amp;gt;Home page - Rendered by React&amp;lt;/h1&amp;gt;; } ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;)); 更新webpack 1、安装依赖
$ npm install -D babel-loader @babel/preset-react -D 2、更新webpack.config.js，添加处理js后缀的loader
module.exports = { //... module: { rules: [ { test: /\.</description>
    </item>
    
    <item>
      <title>二分查找变形</title>
      <link>https://www.pengjielee.cn/algorithm/binary-search-deformation/</link>
      <pubDate>Mon, 08 Mar 2021 13:25:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/binary-search-deformation/</guid>
      <description>查找第一个等于给定值的元素（有重复元素） const binarySearch = (arr, value) =&amp;gt; { let low = 0, high = arr.length - 1; while (low &amp;lt;= high) { const mid = parseInt(low + (high - low) / 2); if (arr[mid] === value) { if (mid === 0 || arr[mid - 1] != value) { return mid; } else { high = mid - 1; } } else if (arr[mid] &amp;lt; value) { low = mid + 1; } else { high = mid - 1; } } return -1; }; var nums = [3, 5, 6, 6, 6, 10]; console.</description>
    </item>
    
    <item>
      <title>二分查找</title>
      <link>https://www.pengjielee.cn/algorithm/binary-search/</link>
      <pubDate>Mon, 08 Mar 2021 13:13:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/binary-search/</guid>
      <description>循环实现（无重复元素） const binarySearch = (arr, value) =&amp;gt; { let low = 0, high = arr.length - 1; while (low &amp;lt;= high) { const mid = parseInt((low + high) / 2, 10); if (arr[mid] === value) { return mid; } else if (arr[mid] &amp;lt; value) { low = mid + 1; } else { high = mid - 1; } } return -1; }; 递归实现（无重复元素） const binarySearch = (arr, value) =&amp;gt; { const search = (arr, low, high, value) =&amp;gt; { if (low &amp;gt; high) { return -1; } const mid = parseInt((low + high) / 2, 10); if (arr[mid] === value) { return mid; } else if (arr[mid] &amp;lt; value) { return search(arr, mid + 1, high, value); } else { return search(arr, low, mid - 1, value); } }; return search(arr, 0, arr.</description>
    </item>
    
    <item>
      <title>Webpack多页面应用1：创建项目</title>
      <link>https://www.pengjielee.cn/post/webpack-multi-page-application1/</link>
      <pubDate>Mon, 08 Mar 2021 13:10:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/webpack-multi-page-application1/</guid>
      <description>准备工作 1、创建项目
$ mkdir multi-pages &amp;amp; cd multi-pages $ npm init -y 2、项目结构
src/ pages/ home/ index.js about/ index.js webpack.config.js home/index.js
export default function index() { return &amp;#39;Home Page&amp;#39;; } document.getElementById(&amp;#39;root&amp;#39;).innerHTML = index(); about/index.js
export default function index() { return &amp;#39;About Page&amp;#39;; } document.getElementById(&amp;#39;root&amp;#39;).innerHTML = index(); webpack配置 1、安装依赖
$ npm install webpack webpack-cli webpack-dev-server -D $ npm install html-webpack-plugin -D 2、webpack.config.js
const path = require(&amp;#39;path&amp;#39;); const HtmlWebpackPlugin = require(&amp;#39;html-webpack-plugin&amp;#39;); module.exports = { entry: { home: &amp;#39;.</description>
    </item>
    
    <item>
      <title>02.实现信号灯</title>
      <link>https://www.pengjielee.cn/post/fe/02.%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E7%81%AF/</link>
      <pubDate>Mon, 08 Mar 2021 09:20:10 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/02.%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E7%81%AF/</guid>
      <description>版本1：实现一个简单的信号灯切换 (function () { const start = () =&amp;gt; { setTimeout(() =&amp;gt; { console.log(&amp;#34;红灯亮.&amp;#34;); setTimeout(() =&amp;gt; { console.log(&amp;#34;绿灯亮.&amp;#34;); setTimeout(() =&amp;gt; { console.log(&amp;#34;黄灯亮.&amp;#34;); start(); }, 1 * 1000); }, 2 * 1000); }, 3 * 1000); }; start(); })(); 版本2：将信号灯分离出来 (function () { const LIGHTS = [&amp;#34;红灯&amp;#34;, &amp;#34;绿灯&amp;#34;, &amp;#34;黄灯&amp;#34;]; const start = (lights = [], count = 0) =&amp;gt; { let length = lights.length; return setTimeout(() =&amp;gt; { console.log(`${lights[count % length]}亮`); count++; start(lights, count); }, 1000); }; start(LIGHTS); })(); 版本3：将信号灯持续时间分离出来 (function () { const LIGHTS = [ [&amp;#34;红灯&amp;#34;, 3000], [&amp;#34;绿灯&amp;#34;, 2000], [&amp;#34;黄灯&amp;#34;, 1000], ]; const start = (lights = [], count = 0) =&amp;gt; { let length = lights.</description>
    </item>
    
    <item>
      <title>59.按之字形顺序打印二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_59.%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 07 Mar 2021 20:40:42 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_59.%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 按之字形顺序打印二叉树
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function Print(pRoot) { // write code here let result = []; if (pRoot === null) { return result; } let q = []; q.push(pRoot); let rev = true; while (q.length != 0) { let level = []; let len = q.length; for (let i = 0; i &amp;lt; len; i++) { const node = q.</description>
    </item>
    
    <item>
      <title>58.对称的二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_58.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 07 Mar 2021 20:40:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_58.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function isSymmetrical(pRoot) { // write code here return isSymmetricalTree(pRoot, pRoot); } function isSymmetricalTree(node1, node2) { //判断两个节点都是否为空 if (!node1 &amp;amp;&amp;amp; !node2) { return true; } //判断两个节点是否存在一个为空 if (!node1 || !node2) { return false; } //判断两个节点是否相同 if (node1.val != node2.val) { return false; } return ( isSymmetricalTree(node1.left, node2.right) &amp;amp;&amp;amp; isSymmetricalTree(node1.right, node2.left) ); } </description>
    </item>
    
    <item>
      <title>39.平衡二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_39.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 07 Mar 2021 20:39:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_39.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
平衡二叉树一般指平衡树。
平衡树(Balance Tree，BT) 指的是，任意节点的子树的高度差都小于等于1。
详解 /* * 链接：https://www.nowcoder.com/questionTerminal/8b3b95850edb4115918ecebdf1b4d222?f=discussion * 来源：牛客网 */ public class Solution { public boolean IsBalanced_Solution(TreeNode root) { return getDepth(root) != -1; } private int getDepth(TreeNode root) { if (root == null) return 0; int left = getDepth(root.left); if (left == -1) return -1; int right = getDepth(root.right); if (right == -1) return -1; return Math.abs(left - right) &amp;gt; 1 ? -1 : 1 + Math.max(left, right); } } JS实现 /* function TreeNode(x) { this.</description>
    </item>
    
    <item>
      <title>38.二叉树的深度</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_38.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 07 Mar 2021 20:39:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_38.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function TreeDepth(pRoot) { // write code here if (pRoot == null) { return 0; } const left = TreeDepth(pRoot.left); const right = TreeDepth(pRoot.right); return Math.max(left, right) + 1; } More 牛客网题解
https://www.nowcoder.com/questionTerminal/435fb86331474282a3499955f0a41e8b?f=discussion</description>
    </item>
    
    <item>
      <title>22.从上往下打印二叉树</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_22.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 07 Mar 2021 20:38:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_22.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 从上往下打印出二叉树的每个节点，同层节点从左至右打印。
JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function PrintFromTopToBottom(root) { // write code here let result = []; if (root === null) { return result; } let q = []; q.push(root); while (q.length != 0) { let len = q.length; for (let i = 0; i &amp;lt; len; i++) { const node = q.shift(); result.push(node.val); if (node.left != null) { q.</description>
    </item>
    
    <item>
      <title>18.二叉树的镜像</title>
      <link>https://www.pengjielee.cn/post/sword/binarytree_18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sun, 07 Mar 2021 20:36:23 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sword/binarytree_18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>题目 操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述: 二叉树的镜像定义
//源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 //镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 JS实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null; } */ function Mirror(root) { // write code here if (root === null) { return; } if (root.left === null &amp;amp;&amp;amp; root.right === null) { return; } let temp = root.</description>
    </item>
    
    <item>
      <title>打印蛇形矩阵</title>
      <link>https://www.pengjielee.cn/algorithm/print-the-serpentine-matrix/</link>
      <pubDate>Sat, 06 Mar 2021 15:58:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/print-the-serpentine-matrix/</guid>
      <description>题目 对于给定的n，打印出如下型式的蛇形矩阵。例如
n=3时，输出： 1 2 3 8 9 4 7 6 5 n=4时，输出： 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7 参考 var snake = (n) =&amp;gt; { let row = n, col = row; var q = Math.ceil(n / 2); // 旋转几圈 // 创建存放的数组 var result = new Array(row); for (var i = 0; i &amp;lt; row; i++) { result[i] = new Array(col); } var n = 0; // 第n+1圈 var begin = 1; // 每一圈起始值 // 第n+1圈top，right，bottom，left值 // 难点在于找到每一边上二维数组的索引变化规律 // top的索引值 result[n][n+i] // bottom索引值 result[row-1-n][col-1-n-i] // right、left类似 // right索引 result[n+i][col-1-n] // left索引 result[row-1-n-i][n] while (n &amp;lt;= q) { var top = col - 2 * n; for (var i = 0; i &amp;lt; top; i++) { result[n][i + n] = begin + i; } var right = row - 2 * n; for (var i = 0; i &amp;lt; right; i++) { result[i + n][col - n - 1] = begin + top + i - 1; } var bottom = col - 2 * n; for (var i = 0; i &amp;lt; bottom; i++) { result[row - n - 1][col - n - i - 1] = begin + top + right + i - 2; } var left = row - 2 * n - 1; for (var i = 0; i &amp;lt; left; i++) { result[row - i - n - 1][n] = begin + top + right + bottom + i - 3; } begin += top + right + bottom + left - 3; n++; } return result; }; More 利用JavaScript实现蛇形矩阵</description>
    </item>
    
    <item>
      <title>合并两个有序链表</title>
      <link>https://www.pengjielee.cn/algorithm/merges-two-ordered-linked-lists/</link>
      <pubDate>Fri, 05 Mar 2021 15:41:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/merges-two-ordered-linked-lists/</guid>
      <description>数据结构 // 节点类 class Node { constructor(value) { this.value = value; // 存储值 this.next = null; // 存储下一个节点的引用 } } //链表类 class LinkedList { constructor() { this.length = 0; //链表的长度 this.head = null; //链表的头结点 } //链表的插入方法 append(value) { var node = new Node(value); //创建节点 if (!this.head) { this.head = node; //设置头结点 } else { var current = this.head; while (current.next) { //通过循环找到最后一个节点 current = current.next; } current.next = node; } this.</description>
    </item>
    
    <item>
      <title>合并两个有序数组</title>
      <link>https://www.pengjielee.cn/algorithm/merges-two-ordered-arrays/</link>
      <pubDate>Fri, 05 Mar 2021 15:41:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/merges-two-ordered-arrays/</guid>
      <description>将两个有序数组合并成一个有序数组。
实现1 //O(n) time &amp;amp; O(n) space var mergeArr1 = (arr1, arr2) =&amp;gt; { var result = [], index1 = 0, index2 = 0, current = 0; while (current &amp;lt; arr1.length + arr2.length) { //debugger; var element1 = arr1[index1]; var element2 = arr2[index2]; if (element1 &amp;lt; element2) { result[current] = element1; index1++; } else { result[current] = element2; index2++; } current++; } return result; }; 测试：
var arr1 = [2, 5, 8], arr2 = [4, 6, 8, 10]; var result = mergeArr1(arr1, arr2); console.</description>
    </item>
    
    <item>
      <title>Weekly-20210305</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2021.03.05/</link>
      <pubDate>Fri, 05 Mar 2021 09:25:34 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2021.03.05/</guid>
      <description>摘录 1、
第一条：不读的权利。
第二条：跳读的权利。
第三条：不读完的权利。
第四条：重读的权利。
第五条：读不择书的权利。
第六条：包法利症（被小说内容感染的权利）。
第七条：读不择地的权利。
第八条：随意选读的权利。
第九条：朗读的权利。
第十条：默读的权利。
—— 法国当代作家达尼埃尔·佩纳克的“读者权利十条”
2、
你是自由的人，那就去选择吧——也就是说，去创造（invent）。也许你正面临处决，或是被囚禁在盖世太保的监狱里，或是即将坠落悬崖——你也仍然可以自由地在心中和行动上决定如何去看待它。从你现在所处的地方开始，你进行选择。而在选择中，你便选择了你将会成为什么样的人。
没有任何划定的道路来引导人去救赎自己；他必须不断创造自己的道路。但是，创造道路，他便拥有了自由与责任，失去了推脱的借口，而所有希望都存在于他本身之中。
真正重要的不是过去，而是未来。一个人必须不断前行，创造还未发生的事：走到世界中，行动起来，然后去影响它。
来源：《存在主义咖啡馆：自由、存在和杏子鸡尾酒》
3、
我只要最好的，我只管把眼前的一件事做到最好。
我只向前看一步，但总是正确的一步。 —— 棋手卡帕布兰卡
永远去做你余生中最重要的那件事。
拷问自己：我现在做的是我所能做的最重要的事情吗？
来源：长期主义：永远做你余生中最重要的事！
文章 写了十年技术博客，我收获了什么
https://insights.thoughtworks.cn/technical-blog-experience/</description>
    </item>
    
    <item>
      <title>两个数组的交集,并集,差集,子集.md</title>
      <link>https://www.pengjielee.cn/algorithm/the-intersection-union-difference-subset-of-two-arrays/</link>
      <pubDate>Thu, 04 Mar 2021 15:49:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/the-intersection-union-difference-subset-of-two-arrays/</guid>
      <description>两个数组的交集 集合论中，设A，B是两个集合，由所有属于集合A且属于集合B的元素所组成的集合，叫做集合A与集合B的交集。
集合 {1,2,3} 和 {2,3,4} 的交集为 {2,3}。
//filter实现 let intersect = (a,b) =&amp;gt; a.filter(x =&amp;gt; b.indexOf(x) &amp;gt; -1); //Set实现 let intersect1 = (a, b) =&amp;gt; { return a.filter(x =&amp;gt; new Set(b).has(x)); } let intersect2 = (a, b) =&amp;gt; { let result = new Set(); const other = new Set(b); a.forEach(value =&amp;gt; { if (other.has(value)) { result.add(value); } }); return [...result]; } 两个数组的并集 集合论中，设A，B是两个集合，把他们所有的元素合并在一起组成的集合，叫做集合A与集合B的并集。
集合{1, 2, 3} 和 {2, 3, 4} 的并集是 {1, 2, 3, 4}。</description>
    </item>
    
    <item>
      <title>React教程：使用React Router</title>
      <link>https://www.pengjielee.cn/post/react-tutorial-using-the-react-router/</link>
      <pubDate>Thu, 04 Mar 2021 12:39:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/react-tutorial-using-the-react-router/</guid>
      <description>代码 1、安装
$ npm install react-router-dom 2、创建多页面
文件结构：
/src /views /blog detail.js list.js about.js home.js app.js index.js home.js
import React from &amp;#39;react&amp;#39;; const Home = props =&amp;gt; { return &amp;lt;div&amp;gt;Home Page&amp;lt;/div&amp;gt;; }; export default Home; about.js
import React from &amp;#39;react&amp;#39;; const About = props =&amp;gt; { return &amp;lt;div&amp;gt;About Page&amp;lt;/div&amp;gt;; }; export default About; blog/list.js
import React from &amp;#39;react&amp;#39;; import { Link } from &amp;#39;react-router-dom&amp;#39;; const BlogList = props =&amp;gt; { const blogs = [ { id: 1, title: &amp;#39;将React应用部署到GitHub Pages&amp;#39;, url: &amp;#39;https://cnodejs.</description>
    </item>
    
    <item>
      <title>React教程：添加样式文件</title>
      <link>https://www.pengjielee.cn/post/react-tutorial-add-style-files/</link>
      <pubDate>Thu, 04 Mar 2021 10:10:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/react-tutorial-add-style-files/</guid>
      <description>添加 .css 文件 1、安装 css-loader/style-loader
$ npm install --save-dev css-loader style-loader 2、更新 webpack.config.js
module.exports = { module: { rules: [ { test: /\.css$/i, use: [&amp;#39;style-loader&amp;#39;, &amp;#39;css-loader&amp;#39;], }, ], }, }; 3、创建 base.css 文件
/src /assets /styles base.css base.css
body { background: red; color: #fff; } 4、引入 base.css 文件
src/index.js
import React from &amp;#39;react&amp;#39;; import ReactDOM from &amp;#39;react-dom&amp;#39;; // 引入样式文件 import &amp;#39;./assets/styles/base.css&amp;#39;; ReactDOM.render(&amp;lt;h1&amp;gt;Hello, World!&amp;lt;/h1&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;)); 此时打开浏览器： http://localhost:9000/
项目源码见（切换 tag 至 css-loader）git checkout css-loader： https://github.</description>
    </item>
    
    <item>
      <title>React教程：使用prettier格式化代码</title>
      <link>https://www.pengjielee.cn/post/react-tutorial-formatting-code-with-prettier/</link>
      <pubDate>Thu, 04 Mar 2021 08:58:07 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/react-tutorial-formatting-code-with-prettier/</guid>
      <description>安装 $ npm install --save-dev --save-exact prettier 创建一个空的配置文件 $ echo {}&amp;gt; .prettierrc.js 配置.prettierrc.js module.exports = { arrowParens: &amp;#34;avoid&amp;#34;, bracketSpacing: true, printWidth: 100, semi: true, singleQuote: true, tabWidth: 2, trailingComma: &amp;#34;all&amp;#34;, jsxSingleQuote: false, jsxBracketSameLine: false, useTabs: false, overrides: [ { files: &amp;#34;*.html&amp;#34;, options: { parser: &amp;#34;angular&amp;#34;, htmlWhitespaceSensitivity: &amp;#34;ignore&amp;#34;, printWidth: 120, tabWidth: 2, }, } ], }; 我的prettier配置
创建忽略文件 .prettierignore 文件用来设置哪些文件不需要格式化。
.prettierignore
build coverage dist/*.js 使用 npm scripts 格式化 package.json
{ scripts: { &amp;#34;prettier&amp;#34;: &amp;#34;prettier --write src/*.</description>
    </item>
    
    <item>
      <title>React教程：设置环境变量</title>
      <link>https://www.pengjielee.cn/post/react-tutorial-setting-environment-variables/</link>
      <pubDate>Wed, 03 Mar 2021 17:22:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/react-tutorial-setting-environment-variables/</guid>
      <description>Mac系统下环境变量 1、注入环境变量，export NODE_ENV=development
package.json
{ &amp;#34;scripts&amp;#34;: { &amp;#34;dev&amp;#34;: &amp;#34;export NODE_ENV=development &amp;amp;&amp;amp; webpack serve&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;export NODE_ENV=production &amp;amp;&amp;amp; webpack&amp;#34; }, } 2、使用环境变量 process.env.NODE_ENV
webpack.config.js
const path = require(&amp;#39;path&amp;#39;); const devMode = process.env.NODE_ENV !== &amp;#39;production&amp;#39;; console.log(&amp;#39;devMode:&amp;#39;, devMode); module.exports = { entry: &amp;#39;./src/index.js&amp;#39;, mode: devMode ? &amp;#39;development&amp;#39; : &amp;#39;production&amp;#39;, output: { path: path.resolve(__dirname, &amp;#39;dist&amp;#39;), filename: &amp;#39;[name].bundle.js&amp;#39;, }, }; cross-env，跨平台设置环境变量 1、安装
$ npm install --save-dev cross-env 2、注入
{ &amp;#34;scripts&amp;#34;: { &amp;#34;cross:dev&amp;#34;: &amp;#34;cross-env NODE_ENV=development webpack serve&amp;#34;, &amp;#34;cross:build&amp;#34;: &amp;#34;cross-env NODE_ENV=production webpack&amp;#34; }, } 项目源码见（切换 tag 至 node_env）git checkout node_env： https://github.</description>
    </item>
    
    <item>
      <title>React教程：Hello World</title>
      <link>https://www.pengjielee.cn/post/react-tutorial-helloworld/</link>
      <pubDate>Wed, 03 Mar 2021 15:11:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/react-tutorial-helloworld/</guid>
      <description>创建项目 # 创建项目目录 $ mkdir hello-world # 进入项目目录 $ cd hello-world # 初始化 package.json 文件 $ npm init -y # 创建源码src目录（所有源代码都放在src目录），并创建入口文件 index.js $ mkdir src &amp;amp;&amp;amp; touch index.js # 安装react和react-dom $ npm install react react-dom # 安装babel-loader，用于处理js文件 # 安装@babel/preset-react，用于处理jsx $ npm install -D babel-loader @babel/preset-react # 安装webpack相关库 $ npm install -D webpack webpack-cli webpack-dev-serve 项目结构 hello-world /dist index.html /src index.js package.json webpack.config.js 项目代码 1、src/index.js
import React from &amp;#39;react&amp;#39;; import ReactDOM from &amp;#39;react-dom&amp;#39;; ReactDOM.</description>
    </item>
    
    <item>
      <title>10.矩形覆盖</title>
      <link>https://www.pengjielee.cn/post/the-rectangle-cover/</link>
      <pubDate>Wed, 03 Mar 2021 14:32:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/the-rectangle-cover/</guid>
      <description>题目 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？
比如n=3时，2 * 3的矩形块有3种覆盖方法： ()[../images/offer10.png]
详解 每次使用两个变量a，b来计算下一个数的值sum，然后a，b，sum分别是斐波那契数列中的三个数，那么就令a=b，b=sum，这样a和b就往下移动了一个位置，再计算sum就是第4个数了，重复这个过程即可。
target = 1时，1种
target = 2时，2种
target = 3时，3种
target = 4时，5种
target = n时，分两步考虑：
第一次摆放2* 1的小矩形，则摆放方法总共为f(target-1); 第一次摆放1* 2的小矩形，则摆放方法总共为f(target-2); 这就是斐波那契数列啊。
JS实现 function rectCover(number) { // write code here if (number === 1) { return 1; } if (number === 2) { return 2; } let a = 1, b = 2, sum = 0; for (let i = 3; i &amp;lt;= number; i++) { sum = a + b; a = b; b = sum; } return sum; } </description>
    </item>
    
    <item>
      <title>09.变态跳台阶</title>
      <link>https://www.pengjielee.cn/post/jump-the-floor2/</link>
      <pubDate>Wed, 03 Mar 2021 14:32:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/jump-the-floor2/</guid>
      <description>题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
详解 关于本题，前提是n个台阶会有一次n阶的跳法。分析如下：
f(1) = 1
f(2) = f(2-1) + f(2-2) //f(2-2)表示2阶一次跳2阶的次数。
f(3) = f(3-1) + f(3-2) + f(3-3)
&amp;hellip;
f(n) = f(n-1) + f(n-2) + f(n-3) + &amp;hellip; + f(n-(n-1)) + f(n-n)
说明：
这里的f(n)代表的是n个台阶有一次1,2,&amp;hellip;,n阶的跳法数。
n=1时，只有1种跳法，f(1)=1
n=2时，会有两种跳的方式，一次1阶或者2阶，这回归到了问题(1)，f(2)=f(2-1)+f(2-2)
n=3时，会有三种跳的方式，1阶、2阶、3阶，那么就是第一次跳出1阶后面剩下：f(3-1)；第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)。因此结论是f(3)=f(3-1)+f(3-2)+f(3-3)
n=n时，会有n种跳的方式，1阶、2阶&amp;hellip;n阶，得出结论： f(n)=f(n-1)+f(n-2)+f(n-3)+&amp;hellip;+f(n-(n-1))+f(n-n) =&amp;gt; f(0)+f(1)+f(2)+&amp;hellip;+f(n-1) //[式1]
由以上已经是一种结论，我们可以继续简化： f(n-1)=f(0)+f(1)+f(2)+f(3)+&amp;hellip;+f((n-1)-1) = f(0)+f(1)+f(2)+&amp;hellip;+f(n-2) //[式2]
[式1]-[式2]
f(n) = f(0)+f(1)+f(2)+&amp;hellip;+f(n-1) f(n-1) = f(0)+f(1)+f(2)+&amp;hellip;+f(n-2)
f(n)-f(n-1)= f(n-1)
可以得出：
f(n) = 2 * f(n-1)
得出最终结论，在n阶台阶，一次有1、2、&amp;hellip;n阶的跳的方式时，总的跳法为： | 1, (n=0) f(n) =| 1, (n=1) | 2 * f(n-1),(n&amp;gt;=2) 来源：https://www.</description>
    </item>
    
    <item>
      <title>08.跳台阶</title>
      <link>https://www.pengjielee.cn/post/jump-the-floor/</link>
      <pubDate>Wed, 03 Mar 2021 14:32:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/jump-the-floor/</guid>
      <description>题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
详解 一次1阶或者2阶的跳法： a. 如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1); b. 假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2) c. 由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2) d. 然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2 e. 可以发现最终得出的是一个斐波那契数列： | 1, (n=1) f(n) = | 2, (n=2) | f(n-1)+f(n-2) ,(n&amp;gt;2,n为整数)
链接：https://www.nowcoder.com/questionTerminal/8c82a5b80378478f9484d87d1c5f12a4?f=discussion 来源：牛客网
JS实现 //递归实现 const jumpFloor = (target) =&amp;gt; { if (target &amp;lt;= 0) { return -1; } if (target === 1) { return 1; } if (target === 2) { return 2; } return jumpFloor(target - 1) + jumpFloor(target - 2); }; //迭代实现 const jumpFloor = (target) =&amp;gt; { if (target &amp;lt;= 0) { return -1; } if (target === 1) { return 1; } if (target === 2) { return 2; } let a = 1, b = 2, sum = a + b; for (let i = 3; i &amp;lt;= target; i++) { sum = a + b; a = b; b = sum; } return sum; }; </description>
    </item>
    
    <item>
      <title>07.斐波那契数列</title>
      <link>https://www.pengjielee.cn/post/fibonacci-sequence/</link>
      <pubDate>Wed, 03 Mar 2021 14:31:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fibonacci-sequence/</guid>
      <description>题目 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&amp;lt;=39
斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144&amp;hellip; , 这个数列从第3项开始，每一项都等于前两项之和。
JS实现 //递归实现 const Fibonacci = (n) =&amp;gt; { if (n &amp;lt;= 0) { return 0; } if (n === 1) { return 1; } return Fibonacci(n - 1) + Fibonacci(n - 2); }; //迭代实现 const Fibonacci = (n) =&amp;gt; { if (n &amp;lt;= 0) { return 0; } if (n === 1) { return 1; } let a = 0, b = 1, sum = 0; for (let i = 2; i &amp;lt;= n; i++) { sum = a + b; a = b; b = sum; } return sum; }; </description>
    </item>
    
    <item>
      <title>判断括号匹配</title>
      <link>https://www.pengjielee.cn/algorithm/determine-bracket-match/</link>
      <pubDate>Wed, 03 Mar 2021 13:59:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/determine-bracket-match/</guid>
      <description>如何判断左右小括号是否全部匹配。如 (( ))()((((()))))？
var isValid = function (str) { var stack = []; var map = { &amp;#34;(&amp;#34;: &amp;#34;)&amp;#34;, &amp;#34;[&amp;#34;: &amp;#34;]&amp;#34;, &amp;#34;{&amp;#34;: &amp;#34;}&amp;#34;, }; for (var char of str) { if (char in map) { stack.push(char); } else { if (!stack.length || char != map[stack.pop()]) { return false; } } } // 如果最后stack 里没有元素了， 就一定是匹配的 return !stack.length; }; </description>
    </item>
    
    <item>
      <title>LocalStorage设置过期时间</title>
      <link>https://www.pengjielee.cn/post/localstorage-set-the-expiration-time/</link>
      <pubDate>Wed, 03 Mar 2021 13:15:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/localstorage-set-the-expiration-time/</guid>
      <description>代码 class Storage { constructor(name) { this.name = &amp;#34;storage&amp;#34;; } //设置缓存 setItem(params) { let obj = { name: &amp;#34;&amp;#34;, value: &amp;#34;&amp;#34;, expires: &amp;#34;&amp;#34;, startTime: new Date().getTime(), //记录何时将值存入缓存，毫秒级 }; let options = {}; //将obj和传进来的params合并 Object.assign(options, obj, params); let { name, value, expires } = options; if (expires) { //如果options.expires设置了的话 //以options.name为key，options为值放进去 localStorage.setItem(name, JSON.stringify(options)); } else { //如果value是对象或者数组对象的类型，就先用JSON.stringify转一下，再存进去 if (Object.prototype.toString.call(value) == &amp;#34;[object Object]&amp;#34;) { value = JSON.stringify(value); } if (Object.prototype.toString.call(value) == &amp;#34;[object Array]&amp;#34;) { value = JSON.</description>
    </item>
    
    <item>
      <title>01.信号灯控制器</title>
      <link>https://www.pengjielee.cn/post/fe/01.%E4%BF%A1%E5%8F%B7%E7%81%AF%E6%8E%A7%E5%88%B6%E5%99%A8/</link>
      <pubDate>Tue, 02 Mar 2021 15:05:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/01.%E4%BF%A1%E5%8F%B7%E7%81%AF%E6%8E%A7%E5%88%B6%E5%99%A8/</guid>
      <description>题目 信号灯控制器
用 React 实现一个信号灯（交通灯）控制器，要求：
默认情况下，
1.1. 红灯亮20秒，并且最后5秒闪烁；
1.2. 绿灯亮20秒，并且最后5秒闪烁；
1.3. 黄灯亮10秒；
1.4. 次序为 红-绿-黄-红-绿-黄； 灯的个数、颜色、持续时间、闪烁时间、灯光次序都可配置，如：
lights=[{color: &amp;lsquo;#fff&amp;rsquo;, duration: 10000, twinkleDuration: 5000}, &amp;hellip; ] 参考 import React from &amp;#39;react&amp;#39;; import ReactDOM from &amp;#39;react-dom&amp;#39;; let lights = [ { color: &amp;#39;red&amp;#39;, duration: 20000, twinkleDuration: 5000, on: false, flash: false, countdown: 0, }, { color: &amp;#39;green&amp;#39;, duration: 20000, twinkleDuration: 5000, on: false, flash: false, countdown: 0, }, { color: &amp;#39;yellow&amp;#39;, duration: 10000, twinkleDuration: 0, on: false, flash: false, countdown: 0, }, ]; const sleep = time =&amp;gt; { return new Promise(resolve =&amp;gt; { setTimeout(resolve, time); }); }; class TrafficLight extends React.</description>
    </item>
    
    <item>
      <title>斐波那契数列</title>
      <link>https://www.pengjielee.cn/algorithm/fibonacci-sequence/</link>
      <pubDate>Tue, 02 Mar 2021 14:46:33 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/fibonacci-sequence/</guid>
      <description>斐波那契数列 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
F(0) = 0, F(1) = 1, F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144&amp;hellip; ，这个数列从第3项开始，每一项都等于前两项之和。
给定 N，计算 F(N) 1、递归
const fib = (n) =&amp;gt; { if(n &amp;lt;= 1) { return n; } return fib(n - 1) + fib(n - 2); }; 2、记忆化自底向上
const fib = (n) =&amp;gt; { if(n &amp;lt;= 1) { return n; } let cache = new Array(n+1).</description>
    </item>
    
    <item>
      <title>00.前端面试题合集</title>
      <link>https://www.pengjielee.cn/tags/question/index/</link>
      <pubDate>Mon, 01 Mar 2021 15:24:43 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/tags/question/index/</guid>
      <description>&amp;lsquo;##&amp;rsquo; 1、node-interview
https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn
&amp;lsquo;##&amp;rsquo; 2、Front-end Developer Interview Questions
https://github.com/h5bp/Front-end-Developer-Interview-Questions
&amp;lsquo;##&amp;rsquo; 3、fe-interview
https://github.com/haizlin/fe-interview
前端面试每日3+1
&amp;lsquo;##&amp;rsquo; 4、Front End Interview Handbook
https://github.com/yangshun/front-end-interview-handbook
&amp;lsquo;##&amp;rsquo; 5、Daily-Interview-Question
https://github.com/Advanced-Frontend/Daily-Interview-Question
每天搞定一道前端大厂面试题
&amp;lsquo;##&amp;rsquo; 6、Reverse interview
https://github.com/viraptor/reverse-interview
Questions to ask the company during your interview
&amp;lsquo;##&amp;rsquo; 7、FE-interview（6.3k）
https://github.com/qiu-deqing/FE-interview
&amp;lsquo;##&amp;rsquo; 8、React Interview Questions &amp;amp; Answers
https://github.com/sudheerj/reactjs-interview-questions
&amp;lsquo;##&amp;rsquo; 9、30 Seconds of Interviews
https://github.com/30-seconds/30-seconds-of-interviews
&amp;lsquo;##&amp;rsquo; 10、JavaScript Interview Questions &amp;amp; Answers
https://github.com/sudheerj/javascript-interview-questions
&amp;lsquo;##&amp;rsquo; 11、FE-Interview
https://github.com/lgwebdream/FE-Interview</description>
    </item>
    
    <item>
      <title>SublimeText插件MarkdownEditing</title>
      <link>https://www.pengjielee.cn/post/sublimetext-plugin-markdownediting/</link>
      <pubDate>Mon, 01 Mar 2021 15:21:17 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/sublimetext-plugin-markdownediting/</guid>
      <description>问题 使用SublimeText默认打开 .md 后缀的文件，页面显示一片白，阅读起来很不爽。
MarkdownEditing MarkdownEditing是一款SublimeText插件，可以高亮显示语法，还可以快速插入 Markdown 标记。
1、安装（MacOS为例）
a. 打开 Sublime Text，按组合键 Command + Shift + P，然后输入install，选择 Package Control:Install Package。
b. 插件安装面板输入 MarkdownEditing，然后回车。
2、 配置
Sublime Test -&amp;gt; Preferences -&amp;gt; Package Settings -&amp;gt; Markdown Editing -&amp;gt; Markdown GFM Setting - User
编辑内容如下：
{ &amp;#34;color_scheme&amp;#34;: &amp;#34;Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme&amp;#34;, &amp;#34;wrap_width&amp;#34;: &amp;#34;auto&amp;#34;, &amp;#34;draw_centered&amp;#34;: false, } 3、快捷键
a. 复制链接 (https://www.baidu.com/) 到剪切板，然后按 Command + shift + K，会快速插入链接
![](https://www.baidu.com/) b. 输入&amp;quot;mdi + tab&amp;quot;会自动插入下面图片标记
![Alt text](/path/to/img.jpg &amp;#34;Optional title&amp;#34;) c.</description>
    </item>
    
    <item>
      <title>05.用两个栈实现队列</title>
      <link>https://www.pengjielee.cn/post/use-two-stacks-to-implement-the-queue/</link>
      <pubDate>Mon, 01 Mar 2021 13:39:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/use-two-stacks-to-implement-the-queue/</guid>
      <description>题目 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
详解 队列的特性是：“先进先出”，栈的特性是：“先进后出”。
当我们向模拟的队列插入数 a,b,c 时，假设插入的是 stack1，此时的栈情况为： 栈 stack1：{a,b,c} 栈 stack2：{} 当需要弹出一个数，根据队列的&amp;#34;先进先出&amp;#34;原则，a 先进入，则 a 应该先弹出。但是此时 a 在 stack1 的最下面，将 stack1 中全部元素逐个弹出压入 stack2，现在可以正确的从 stack2 中弹出 a，此时的栈情况为： 栈 stack1：{} 栈 stack2：{c,b} 继续弹出一个数，b 比 c 先进入&amp;#34;队列&amp;#34;，b 弹出，注意此时 b 在 stack2 的栈顶，可直接弹出，此时的栈情况为： 栈 stack1：{} 栈 stack2：{c} 此时向模拟队列插入一个数 d，还是插入 stack1，此时的栈情况为： 栈 stack1：{d} 栈 stack2：{c} 弹出一个数，c 比 d 先进入，c 弹出，注意此时 c 在 stack2 的栈顶，可直接弹出，此时的栈情况为： 栈 stack1：{d} 栈 stack2：{} 根据上述例子可得出结论：
当插入时，直接插入 stack1； 当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈 stack2，再弹出 stack2 栈顶元素； 链接：https://www.</description>
    </item>
    
    <item>
      <title>20.包含min函数的栈</title>
      <link>https://www.pengjielee.cn/post/the-stack-containing-the-min-function/</link>
      <pubDate>Mon, 01 Mar 2021 10:15:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/the-stack-containing-the-min-function/</guid>
      <description>题目 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。
详解 利用一个辅助栈来存放最小值；
每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶；
当出栈时，辅助栈也要出栈；
JS实现 var stack1 = []; var stack2 = []; // 辅助栈，存最小值 function push(node) { // write code here stack1.push(node); if (stack2.length === 0) { stack2.push(node); } else { var peak2 = stack2[stack2.length - 1]; //栈顶元素 if (node &amp;lt;= peak2) { stack2.push(node); } else { stack2.push(peak2); } } } function pop() { // write code here stack1.pop(); stack2.pop(); } function top1() { // write code here if (stack1.</description>
    </item>
    
    <item>
      <title>Serices</title>
      <link>https://www.pengjielee.cn/series/</link>
      <pubDate>Mon, 01 Mar 2021 09:44:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/series/</guid>
      <description>Python基础系列 Python基础：输出Hello World Python基础：用户输入 Python基础：字符串 Python基础：列表 Python基础：语句 Python基础：集合 Python基础：字典 Python基础：元组 Python基础：函数 Python基础：类 Python基础：文件读写 Flask Web开发 Flask Web开发：HelloWorld Flask Web开发：定义路由及变量约束 Flask Web开发：HTTP方法 Flask Web开发：渲染模板 Flask Web开发：重定向,终止响应,错误页 Flask Web开发：Session实现简单登录 Webpack多页面应用 Webpack多页面应用1：创建项目 Webpack多页面应用2：添加React Webpack多页面应用3：快速创建页面 Webpack多页面应用4：动态获取入口 React教程 React教程：Hello World React教程：设置环境变量 React教程：使用prettier格式化代码 React教程：添加样式文件 React教程：使用React Router React教程：设置样式 React教程：useMemo用法 React教程：绑定事件 React教程：高阶组件 React教程：使用TypeScript React教程：Hook使用 React教程：创建你自己的React React教程：Hooks原理 Electron应用：ikms 01.Electron应用创建.md 02.Electron主进程代码.md 03.Electron注入环境变量.md 04.Electron使用jQuery.md 05.Electron渲染进程报错.md 06.Electron注册全局快捷键.md 07.Electron主进程向渲染进程发消息.md 08.Electron渲染进程向主进程发消息.md 09.Electron保存文件对话框.md 10.Electron设置系统托盘图标.md 11.Electron设置Dock信息.md 12.Electron设置程序菜单.md 13.Electron使用粘贴板.md 14.使用Nodejs保存文件.md 15.Electron使用sqlite3.md 16.使用dayjs格式化日期.md 17.Electron发送通知.md 18.编码解码.md 19.Electron在浏览器中打开新链接.md 20.Electron中使用Vue.md 21.使用hightlight.js输出代码.md 22.</description>
    </item>
    
    <item>
      <title>个人项目</title>
      <link>https://www.pengjielee.cn/projects/</link>
      <pubDate>Mon, 01 Mar 2021 09:44:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/projects/</guid>
      <description>ikms，个人知识管理系统； 一个本地的知识库管理系统。支持Url、代码、笔记管理； 使用Electron + Vue2.6 + sqlite实现的本地知识管理系统； 详见：https://github.com/pengjielee/ikms 安装包：https://pan.baidu.com/s/1HOVo1AsRWKDU6UFjLuDnlg 提取码：cq5y gitnote，个人笔记桌面应用； 一个github issue本地管理工具。可以新增、删除、修改、Markdown预览的笔记管理工具； 使用Electron + Vue2.6 + Github api实现的个人笔记应用； 详见：https://github.com/pengjielee/gitnote 安装包：https://pan.baidu.com/s/1zUJEsftONXFnrO0-Ku5hKA 提取码：kma4 xun-cli，命令行工具 使用Nodejs开发的命令行工具，可以查看日期、查看天气、查看本机IP地址。 详见：https://github.com/pengjielee/xun-cli 微信小程序：write your goals 写下你的目标。微信小程序目标管理； 微信小程序 + 云存储 + 云函数； 实现功能： 目标列表； 添加目标； 删除目标； 置顶目标； 目标模板；设置主题； 详见：https://github.com/pengjielee/writeyourgoals districtpicker Vue实现的省市区选择器组件； 支持选择省、选择省市、选择省市区、数据回填； 详见：https://github.com/pengjielee/districtpicker 站点 使用Github Pages部署的个人站点 http://m.pengjielee.cn/#/
静态资源站点 http://static.pengjielee.cn/
博客 Github Issue博客 https://github.com/pengjielee/blog </description>
    </item>
    
    <item>
      <title>快捷导航</title>
      <link>https://www.pengjielee.cn/post/other/navs/</link>
      <pubDate>Mon, 01 Mar 2021 09:44:15 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/navs/</guid>
      <description>阅读 工具 生活 前端 资讯 算法 其他 </description>
    </item>
    
    <item>
      <title>21.栈的压入、弹出序列</title>
      <link>https://www.pengjielee.cn/post/the-sequence-of-stack-pushin-and-popout/</link>
      <pubDate>Mon, 01 Mar 2021 09:24:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/the-sequence-of-stack-pushin-and-popout/</guid>
      <description>题目 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
假设压入栈的所有数字均不相等。
例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
示例1: 输入： [1,2,3,4,5],[4,5,3,2,1] 返回： true 可以通过push(1)=&amp;gt;push(2)=&amp;gt;push(3)=&amp;gt;push(4)=&amp;gt;pop()=&amp;gt;push(5)=&amp;gt;pop()=&amp;gt;pop()=&amp;gt;pop()=&amp;gt;pop() 这样的顺序得到[4,5,3,2,1]这个序列，返回true 示例2: 输出：[1,2,3,4,5],[4,3,5,1,2] 返回：false 由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false 详解 借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。
举例：
入栈1,2,3,4,5
出栈4,5,3,2,1
首先1入辅助栈，此时栈顶1≠4，继续入栈2
此时栈顶2≠4，继续入栈3
此时栈顶3≠4，继续入栈4
此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，辅助栈里面是1,2,3
此时栈顶3≠5，继续入栈5
此时栈顶5=5，出栈5，弹出序列向后一位，此时为3，辅助栈里面是1,2,3
…
依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。
链接：https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106?f=discussion
来源：牛客网
JS实现 function IsPopOrder(pushV, popV) { // write code here if (pushV.length === 0 || popV.length === 0) { return false; } const stack = []; //辅助栈 let popIndex = 0; //标识弹出序列的位置 for (let i = 0; i &amp;lt; pushV.length; i++) { stack.</description>
    </item>
    
    <item>
      <title>如何为网站添加暗黑模式</title>
      <link>https://www.pengjielee.cn/post/how-do-i-add-dark-mode-to-my-website/</link>
      <pubDate>Fri, 26 Feb 2021 15:41:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/how-do-i-add-dark-mode-to-my-website/</guid>
      <description>方法1：prefers-color-scheme 用于检测用户是否有将系统的主题色设置为亮色或者暗色。
@media (prefers-color-scheme: dark) { /* all your styles for dark mode here */ body { background: #000; } } @media (prefers-color-scheme: light) { /* all your styles for light mode here */ body { background: #fff; } } 方法2：使用CSS滤镜 1、css文件
html[theme=&amp;#34;dark-mode&amp;#34;] { filter: invert(1) hue-rotate(180deg); } html[theme=&amp;#34;dark-mode&amp;#34;] img { filter: invert(1) hue-rotate(180deg); } html { transition: color 300ms; background-color 300ms; } 2、js文件
document.addEventListener(&amp;#34;DOMContentLoaded&amp;#34;, () =&amp;gt; { var html = document.</description>
    </item>
    
    <item>
      <title>Asciidoctor Document Preview</title>
      <link>https://www.pengjielee.cn/post/asciidoctor--preview/</link>
      <pubDate>Fri, 26 Feb 2021 14:11:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/asciidoctor--preview/</guid>
      <description>== 1、标题
= h1 == h2 === h3 ==== h4 ===== h5 ====== h6
== 2、无序列表
item 1 item 2 == 3、有序列表
. Step 1 . Step 2 .. Step 2a .. Step 2b . Step 3
== 4、清单
[*] checked also checked not checked normal list item == 5、代码
[source,javascript] const obj2str = (obj) =&amp;gt; { let w = Object.entries(obj) w.forEach((v, i) =&amp;gt; { w[i] = v.join(&amp;quot;=&amp;quot;) }) return w.</description>
    </item>
    
    <item>
      <title>使用Asciidoctor写文章</title>
      <link>https://www.pengjielee.cn/post/write-articles-using-asciidoctor/</link>
      <pubDate>Fri, 26 Feb 2021 13:42:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/write-articles-using-asciidoctor/</guid>
      <description>== 什么是Asciidoctor？
Asciidoctor 是一个 快速的 文本处理器和发布工具链，它可以将 AsciiDoc 文档转化成 HTML5、 DocBook 5 (或 4.5) 以及其他格式。&amp;ndash;摘自官网
== Asciidoctor vs Markdown
Asciidoctor功能更强大，语法更加复杂，学习成本更高。
Markdown作为目前使用最广泛的轻量级标记语言，语法简洁。
== Asciidoctor基础语法
1、标题
&amp;hellip;. = h1 == h2 === h3 ==== h4 ===== h5 ====== h6 &amp;hellip;.
2、无序列表
&amp;hellip;.
item 1 item 2 &amp;hellip;. 3、有序列表
&amp;hellip;. . Step 1 . Step 2 .. Step 2a .. Step 2b . Step 3 &amp;hellip;.
4、清单 &amp;hellip;.
[*] checked also checked not checked normal list item &amp;hellip;.</description>
    </item>
    
    <item>
      <title>Python学习书籍推荐</title>
      <link>https://www.pengjielee.cn/post/python-learning-book-recommendations/</link>
      <pubDate>Fri, 26 Feb 2021 11:54:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-learning-book-recommendations/</guid>
      <description>=== Python编程：从入门到实践
image::https://i.loli.net/2021/02/26/TCJnDdrj97OQ3BR.png[Python编程：从入门到实践,170,200]
可从微信读书观看。
=== Python核心编程（第3版）
image::https://i.loli.net/2021/02/26/yb1ncvwMjeEhNVl.png[Python核心编程（第3版),200,200]
网盘: https://pan.baidu.com/s/1tpNel6LNDmG2CkxAaL7D_w[&#39;&#39;, role=&amp;ldquo;external&amp;rdquo;, window=&amp;quot;_blank&amp;quot;] 提取码: pgwx</description>
    </item>
    
    <item>
      <title>如何编写一个shell脚本</title>
      <link>https://www.pengjielee.cn/post/how-do-i-write-a-shell-script/</link>
      <pubDate>Fri, 26 Feb 2021 11:17:08 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/how-do-i-write-a-shell-script/</guid>
      <description>输出 Hello World test.sh
#!/bin/bash echo &amp;#34;Hello World !&amp;#34; #! 告诉系统解释此脚本文件的 Shell 程序。
输出变量 test.sh
#!/bin/bash message=&amp;#39;Hello World&amp;#39; echo $message # output: Hello World 拼接变量 test.sh
#!/bin/bash name=&amp;#39;Peng&amp;#39; echo &amp;#34;Hello, $name&amp;#34; # output: Hello, Peng 运行Shell脚本 $ chmod +x ./test.sh #使脚本具有执行权限 $ ./test.sh #执行脚本 or $ sh test.sh #执行脚本 创建一个提交 git 记录的 shell 脚本 deploy.sh
#!/bin/bash deploy_time=$(date +%Y-%m-%d\ %H:%M:%S) # 发布时间，格式如：2021-02-26 11:32:54 git pull # 拉取最新代码 git add . # 添加所有代码到代码库 git commit -m &amp;#34;deploy on $deploy_time&amp;#34; # 提交代码 git push # 推送代码到服务器 </description>
    </item>
    
    <item>
      <title>Weekly-20210226</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2021.02.26/</link>
      <pubDate>Fri, 26 Feb 2021 09:21:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2021.02.26/</guid>
      <description>摘录 1、 + 财富就是这样，有两个维度。一个是线性的，你通过出卖自己的时间赚钱，如果你卖给固定的人，那你就是打工；如果你直接到市场上卖，那就是自由职业；如果你倒卖别人的时间，那就是创业，这些钱有的快有的慢。
来源: https://mp.weixin.qq.com/s/6ohTqBCbFuhRnHguH5rQ8w[人生的三道窄门]
2、 + 如果有一天： 你不再寻找爱情，只是去爱；你不再渴望成功，只是去做； 你不再追求成长，只是去修；一切才真正开始。&amp;ndash;纪伯伦
3、 + 金钱只是通向最终价值的桥梁，而人是无法栖居在桥梁之上的。 &amp;ndash;格奥尔格·齐美尔（德）
4、 + If you&amp;rsquo;re a recruiter reading this, please don&amp;rsquo;t be an asshole. If the person applying wasn&amp;rsquo;t a suitable candidate, just tell them. And if you can, tell them also why. It may be uncomfortable to do so, but you&amp;rsquo;ll be a better person for it and the candidate knows what to improve upon so that maybe the next opportunity that comes by will be the opportunity.</description>
    </item>
    
    <item>
      <title>Flask Web开发：Session实现简单登录</title>
      <link>https://www.pengjielee.cn/post/flask-web-development-session-implements-simple-login/</link>
      <pubDate>Thu, 25 Feb 2021 14:34:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/flask-web-development-session-implements-simple-login/</guid>
      <description>设置密钥 app.secret_key = b&amp;#39;_5#y2L&amp;#34;F4Q8z\n\xec]/&amp;#39; 生成随机密钥：
$ python -c &amp;#39;import os; print(os.urandom(16))&amp;#39; 首页 from flask import Flask, request, redirect, url_for, session, render_template from markupsafe import escape app = Flask(__name__) app.secret_key = &amp;#39;nimei&amp;#39; @app.route(&amp;#39;/&amp;#39;) def index(): return &amp;#39;&amp;lt;h1&amp;gt;Welcome&amp;lt;/h1&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;a href=&amp;#34;/login&amp;#34;&amp;gt;登录&amp;lt;/a&amp;gt;&amp;#39; 登录 storage = {&amp;#39;username&amp;#39;: &amp;#39;lipengjie&amp;#39;, &amp;#39;password&amp;#39;: &amp;#39;123456&amp;#39;} @app.route(&amp;#39;/login&amp;#39;, methods=[&amp;#39;GET&amp;#39;, &amp;#39;POST&amp;#39;]) def login(): if request.method == &amp;#39;POST&amp;#39;: username = request.form[&amp;#39;username&amp;#39;] password = request.form[&amp;#39;password&amp;#39;] # 判断与服务器存储的用户密码是否一致，此处用一个对象模拟数据库 if storage[&amp;#39;username&amp;#39;] == username and storage[&amp;#39;password&amp;#39;] == password: # 登录成功以后，把用户名存入session，并跳转后台 session[&amp;#39;username&amp;#39;] = username return redirect(url_for(&amp;#39;admin&amp;#39;)) else: return &amp;#39;用户名或密码错误！&amp;#39; else: return render_template(&amp;#39;newlogin.</description>
    </item>
    
    <item>
      <title>Flask Web开发：重定向,终止响应,错误页</title>
      <link>https://www.pengjielee.cn/post/flask-web-development-redirect-abort-notfound/</link>
      <pubDate>Thu, 25 Feb 2021 14:34:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/flask-web-development-redirect-abort-notfound/</guid>
      <description>重定向 from flask import abort, redirect, url_for @app.route(&amp;#39;/welcome&amp;#39;) def welcome(): return redirect(url_for(&amp;#39;login&amp;#39;)) 终止响应 from flask import abort, redirect, url_for @app.route(&amp;#39;/login&amp;#39;) def login(): abort(401) 404页面 from flask import render_template @app.errorhandler(404) def page_not_found(error): return render_template(&amp;#39;404.html&amp;#39;, 404) </description>
    </item>
    
    <item>
      <title>Flask Web开发：渲染模板</title>
      <link>https://www.pengjielee.cn/post/flask-web-development-render-templates/</link>
      <pubDate>Thu, 25 Feb 2021 14:13:53 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/flask-web-development-render-templates/</guid>
      <description>渲染模板 1、创建模板目录 templates，及模板文件
$ mkdir templates &amp;amp;&amp;amp; cd templates $ touch hello.html $ touch login.html 2、目录结构
/flask_web /templates /hello.html /login.html /app.py 3、模板文件
hello.html
&amp;lt;!doctype html&amp;gt; &amp;lt;title&amp;gt;Hello from Flask&amp;lt;/title&amp;gt; {% if name %} &amp;lt;h1&amp;gt;Hello {{ name }}!&amp;lt;/h1&amp;gt; {% else %} &amp;lt;h1&amp;gt;Hello, World!&amp;lt;/h1&amp;gt; {% endif %} login.html
&amp;lt;!doctype html&amp;gt; &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt; &amp;lt;form action=&amp;#34;/login&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;label&amp;gt;用户名&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;name&amp;#34;/&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;label&amp;gt;密码&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;password&amp;#34; name=&amp;#34;password&amp;#34;/&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button&amp;gt;login&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 4、指定模板
from flask import render_template @app.</description>
    </item>
    
    <item>
      <title>Flask Web开发：HTTP方法</title>
      <link>https://www.pengjielee.cn/post/flask-web-development-http-methods/</link>
      <pubDate>Thu, 25 Feb 2021 13:18:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/flask-web-development-http-methods/</guid>
      <description>定义 GET 方法（默认） from flask import request from flask import render_template @app.route(&amp;#39;/register&amp;#39;, methods=[&amp;#39;GET&amp;#39;]) def register(): return render_template(&amp;#39;register.html&amp;#39;, title=&amp;#39;Register Form&amp;#39;) 定义 POST 方法 from flask import request from markupsafe import escape @app.route(&amp;#39;/register&amp;#39;, methods=[&amp;#39;POST&amp;#39;]) def register_submit(): name = request.form[&amp;#39;name&amp;#39;] email = request.form[&amp;#39;email&amp;#39;] return &amp;#39;Username: &amp;#39; + escape(name) + &amp;#39;, Email: &amp;#39; + escape(email) 合在一起 @app.route(&amp;#39;/register&amp;#39;, methods=[&amp;#39;POST&amp;#39;]) def register(): if request.method == &amp;#39;POST&amp;#39;: name = request.form[&amp;#39;name&amp;#39;] email = request.form[&amp;#39;email&amp;#39;] return &amp;#39;Username: &amp;#39; + escape(name) + &amp;#39;, Email: &amp;#39; + escape(email) else: return render_template(&amp;#39;register.</description>
    </item>
    
    <item>
      <title>Flask Web开发：定义路由及变量约束</title>
      <link>https://www.pengjielee.cn/post/flask-web-development-define-routes-and-variable-constraint/</link>
      <pubDate>Thu, 25 Feb 2021 11:37:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/flask-web-development-define-routes-and-variable-constraint/</guid>
      <description>创建 app.py （flask默认会运行app.py文件) from flask import Flask from markupsafe import escape app = Flask(__name__) @app.route(&amp;#39;/&amp;#39;) def index(): return &amp;#39;Index Page&amp;#39; 定义多个路由 @app.route(&amp;#39;/hello&amp;#39;) def hello(): return &amp;#39;Hello, World&amp;#39; @app.route(&amp;#39;/about&amp;#39;) def about(): return &amp;#39;About Page&amp;#39; 路由变量约束 接受变量类型：
string，默认类型，接受任何字符串（斜杠除外） int，接受整数； float，接受浮点数； path，类似字符串（包括斜杠）； uuid，接受UUID； @app.route(&amp;#39;/post/&amp;lt;int:post_id&amp;gt;&amp;#39;) def show_post(post_id): return &amp;#39;Post: %d&amp;#39; % post_id @app.route(&amp;#39;/user/&amp;lt;username&amp;gt;&amp;#39;) def show_user(username): return &amp;#39;User: %s&amp;#39; % escape(username) @app.route(&amp;#39;/path/&amp;lt;path:subpath&amp;gt;&amp;#39;) def show_path(subpath): return &amp;#39;Subpath: %s&amp;#39; % escape(subpath) @app.route(&amp;#39;/product/&amp;lt;float:price&amp;gt;&amp;#39;) def show_price(price): return &amp;#39;Price: %f&amp;#39; % price 请求响应：</description>
    </item>
    
    <item>
      <title>Flask Web开发：HelloWorld</title>
      <link>https://www.pengjielee.cn/post/flask-web-development-helloworld/</link>
      <pubDate>Thu, 25 Feb 2021 10:41:37 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/flask-web-development-helloworld/</guid>
      <description>安装 flask $ pip install flask 查看flask版本
$ flask --version 终端输出：
Flask 1.0.2 Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 05:52:31) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] 创建项目目录 $ mkdir flask_web &amp;amp;&amp;amp; cd flask_web 创建 hello.py from flask import Flask app = Flask(__name__) @app.route(&amp;#39;/&amp;#39;) def hello(): return &amp;#39;Hello, World!&amp;#39; 运行 $ export FLASK_APP=hello.py $ flask run 终端输出：
peng@localhost flask_web % export FLASK_APP=hello.py peng@localhost flask_web % flask run * Serving Flask app &amp;#34;hello.</description>
    </item>
    
    <item>
      <title>Python虚拟环境</title>
      <link>https://www.pengjielee.cn/post/python-virtual-environment/</link>
      <pubDate>Thu, 25 Feb 2021 09:17:00 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-virtual-environment/</guid>
      <description>虚拟环境 虚拟环境是系统的一个位置，可以在其中安装包，并将其与其他Python包隔离。这样能够针对不同项目创建一个独立的环境，便于后期的移植。
虚拟环境管理工具 主要有三种：
virtualenv（历史更悠久）； pipenv（功能更强大）； venv（Python3.3以上原生支持）； 使用 virtualenv 创建虚拟环境 1、安装virtualenv
$ pip install virtualenv 2、查看安装版本
$ python3 -m virtualenv --version 4、创建虚拟环境
$ python3 -m virtualenv dev_env 这时终端显示：
peng@localhost myblog % python3 -m virtualenv dev_env created virtual environment CPython3.6.5.final.0-64 in 568ms creator CPython3Posix(dest=/Users/peng/python_work/myblog/dev_env, clear=False, no_vcs_ignore=False, global=False) seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=/Users/peng/Library/Application Support/virtualenv) added seed packages: pip==21.0.1, setuptools==52.0.0, wheel==0.36.2 activators BashActivator,CShellActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator peng@localhost myblog % ls dev_env 5、激活虚拟环境
$ source dev_env/bin/activate 6、安装flask</description>
    </item>
    
    <item>
      <title>SublimeText中运行Python程序</title>
      <link>https://www.pengjielee.cn/post/run-the-python-program-in-sublimetext/</link>
      <pubDate>Wed, 24 Feb 2021 11:36:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/run-the-python-program-in-sublimetext/</guid>
      <description>环境 操作系统：MacOS Big Sur（版本11.2） SublimeText：Version 3.1.1 使用系统自带版本，直接运行 创建 hello_world.py 文件，内容如下：
print(&amp;#39;Hello World.&amp;#39;) 选择菜单 Tools -&amp;gt; Build (或 command + B)。
配置Python3运行 1、查看Python3安装路径
$ type -a python3 or $ which python3 2、配置Sublime Text
选择菜单 Tools -&amp;gt; Build -&amp;gt; New Build System，会打开一个新的配置文件。
编辑内容如下：
{ &amp;#34;cmd&amp;#34;: [&amp;#34;/usr/local/bin/python3&amp;#34;, &amp;#34;-u&amp;#34;, &amp;#34;$file&amp;#34;], } 将文件重命名为 Python3.sublime-build，保存至默认目录。
选择菜单 Tools -&amp;gt; Build System -&amp;gt; Python3，再选择菜单Tools -&amp;gt; Build (或 command + B)。</description>
    </item>
    
    <item>
      <title>03.从尾到头打印链表</title>
      <link>https://www.pengjielee.cn/post/print-the-linked-list-from-tail-to-head/</link>
      <pubDate>Mon, 22 Feb 2021 10:34:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/print-the-linked-list-from-tail-to-head/</guid>
      <description>题目 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
思路 利用JS数组的unshift()方法，在数组开头插入数据。
var nums = [1,2,3]; var temp = nums.unshift(4); console.log(temp); //4 console.log(nums); //[4,1,2,3] var nums = [1,2,3]; var temp = nums.shift(); console.log(temp); //1 console.log(nums); //[2,3] JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function printListFromTailToHead(head) { // write code here let result = []; if (head === null) { return result; } let current = head; while (current != null) { result.unshift(current.val); current = current.next; } return result; } Go实现 package main import ( &amp;#34;container/list&amp;#34; &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func printList(head *ListNode) { curr := head for curr !</description>
    </item>
    
    <item>
      <title>14.链表中倒数第k个结点</title>
      <link>https://www.pengjielee.cn/post/the-last-k-node-in-the-linked-list/</link>
      <pubDate>Mon, 22 Feb 2021 10:00:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/the-last-k-node-in-the-linked-list/</guid>
      <description>题目 输入一个链表，输出该链表中倒数第k个结点。
思路 利用快慢指针，快指针先走k步，然后快慢指针一起走，当快指针走到末尾，那么慢指针就到了倒数第k个节点了。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function FindKthToTail(head, k) { // write code here let fast = head, slow = head; for (let i = 0; i &amp;lt; k; i++) { if (fast === null) return; fast = fast.next; } while (fast) { fast = fast.next; slow = slow.next; } return slow; } Test
var linkedlist = { length: 7, head: { value: 1, next: { value: 2, next: { value: 2, next: { value: 3, next: { value: 4, next: { value: 4, next: { value: 5, next: null } }, }, }, }, }, }, }; function display(linkedlist) { var results = []; var current = linkedlist.</description>
    </item>
    
    <item>
      <title>JavaScript将对象转换为Url拼接参数</title>
      <link>https://www.pengjielee.cn/post/javascript-converts-the-object-into-a-url-concatenation-parameter/</link>
      <pubDate>Sat, 20 Feb 2021 16:22:28 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/javascript-converts-the-object-into-a-url-concatenation-parameter/</guid>
      <description>将对象转换为Url拼接参数 const obj2str = obj =&amp;gt; { let arr = Object.entries(obj); arr.forEach((value, index) =&amp;gt; { arr[index] = value.join(&amp;#39;=&amp;#39;); }); return arr.join(&amp;#39;&amp;amp;&amp;#39;); }; 实例：
var data = { &amp;#34;name&amp;#34;: &amp;#34;jie&amp;#34;, &amp;#34;age&amp;#34; : 20 }; console.log(obj2str(data)); //output: name=jie&amp;amp;age=20 扩展 1、 Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组。
var data = { &amp;#34;name&amp;#34;: &amp;#34;jie&amp;#34;, &amp;#34;age&amp;#34; : 20 }; console.log(Object.entries(data)); //output: [[&amp;#39;name&amp;#39;,&amp;#39;jie&amp;#39;], [&amp;#39;age&amp;#39;, 20]] for (const [key, value] of Object.entries(data)) { console.log(`${key}: ${value}`); } // output: // name: jie // age: 20 Object.</description>
    </item>
    
    <item>
      <title>Express获取提交数据</title>
      <link>https://www.pengjielee.cn/post/express-gets-the-commit-data/</link>
      <pubDate>Sat, 20 Feb 2021 14:37:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/express-gets-the-commit-data/</guid>
      <description>获取url中的参数 app.get(&amp;#39;/blog/:id&amp;#39;, (req, res) =&amp;gt; { const id = req.params.id; console.log(id); res.send(id); }); 请求：/blog/1
输出：1
获取url中?后的参数 app.get(&amp;#39;/blog&amp;#39;, (req, res) =&amp;gt; { const query = req.query; res.send(query); }); 请求：/blog?id=1&amp;amp;name=jie
输出：{&amp;ldquo;id&amp;rdquo;:&amp;ldquo;1&amp;rdquo;,&amp;ldquo;name&amp;rdquo;:&amp;ldquo;jie&amp;rdquo;}
获取post提交的数据 Enctype: application/x-www-form-urlencoded (default)
app.post(&amp;#39;/blog&amp;#39;, (req, res) =&amp;gt; { res.send(req.body); }); &amp;lt;form action=&amp;#34;/blog&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;form-group&amp;#34;&amp;gt; &amp;lt;label&amp;gt; 标题： &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;title&amp;#34; /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;form-group&amp;#34;&amp;gt; &amp;lt;label&amp;gt; 日期： &amp;lt;input type=&amp;#34;date&amp;#34; name=&amp;#34;date&amp;#34; /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button&amp;gt;submit&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 提交form，输出：{&amp;ldquo;title&amp;rdquo;:&amp;ldquo;user&amp;rdquo;,&amp;ldquo;date&amp;rdquo;:&amp;ldquo;2021-02-05&amp;rdquo;}
获取post提交的数据 Enctype: multipart/form-data
const formidable = require(&amp;#39;formidable&amp;#39;); const uploadDir = path.</description>
    </item>
    
    <item>
      <title>Nodejs实现文件上传</title>
      <link>https://www.pengjielee.cn/post/nodejs-implements-file-uploading/</link>
      <pubDate>Sat, 20 Feb 2021 08:46:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/nodejs-implements-file-uploading/</guid>
      <description>Form上传 1、前端
&amp;lt;section&amp;gt; &amp;lt;h2&amp;gt;上传单个文件&amp;lt;/h2&amp;gt; &amp;lt;form action=&amp;#34;/api/upload/single&amp;#34; method=&amp;#34;post&amp;#34; enctype=&amp;#34;multipart/form-data&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;file&amp;#34; accept=&amp;#34;image/*&amp;#34; required=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;button&amp;gt;上传&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/section&amp;gt; 2、后端
var createError = require(&amp;#39;http-errors&amp;#39;); var express = require(&amp;#39;express&amp;#39;); var path = require(&amp;#39;path&amp;#39;); var cookieParser = require(&amp;#39;cookie-parser&amp;#39;); var logger = require(&amp;#39;morgan&amp;#39;); const fs = require(&amp;#39;fs-extra&amp;#39;); const multer = require(&amp;#39;multer&amp;#39;); var app = express(); const port = 3000; // view engine setup app.set(&amp;#39;views&amp;#39;, path.join(__dirname, &amp;#39;views&amp;#39;)); app.set(&amp;#39;view engine&amp;#39;, &amp;#39;pug&amp;#39;); app.use(logger(&amp;#39;dev&amp;#39;)); app.use(express.json()); app.use(express.urlencoded({ extended: false })); app.</description>
    </item>
    
    <item>
      <title>使用FileReader读取文件</title>
      <link>https://www.pengjielee.cn/post/use-filereader-to-read-the-file/</link>
      <pubDate>Fri, 19 Feb 2021 17:44:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/use-filereader-to-read-the-file/</guid>
      <description>HTML结构 &amp;lt;section class=&amp;#34;card&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; class=&amp;#34;input&amp;#34; accept=&amp;#34;text/*&amp;#34; id=&amp;#34;fileInput&amp;#34;/&amp;gt; &amp;lt;div class=&amp;#34;preview&amp;#34; id=&amp;#34;filePreview&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/section&amp;gt; 读取为文本内容 const fileInput = document.getElementById(&amp;#34;fileInput&amp;#34;); const filePreview = document.getElementById(&amp;#34;filePreview&amp;#34;); fileInput.addEventListener( &amp;#34;change&amp;#34;, function () { const file = this.files[0]; const reader = new FileReader(); reader.onload = function (evt) { const content = evt.target.result; filePreview.innerHTML = content; }; reader.readAsText(file); }, false ); 读取为Base64字符串 const file = fileInput.files[0]; const reader = new FileReader(); reader.onload = function (evt) { const content = evt.</description>
    </item>
    
    <item>
      <title>15.反转链表.md</title>
      <link>https://www.pengjielee.cn/post/reverse-a-linked-list/</link>
      <pubDate>Thu, 18 Feb 2021 10:11:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/reverse-a-linked-list/</guid>
      <description>题目 输入一个链表，反转链表后，输出新链表的表头。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function ReverseList(pHead) { // write code here if (pHead === null || pHead.next === null) { return pHead; } let prev = null; //记录节点的前一个节点 let next = null; //记录节点的后一个节点 while (pHead != null) { next = pHead.next; //记录当前节点的下一个节点位置； pHead.next = prev; //让当前节点指向前一个节点位置，完成反转 prev = pHead; //prev 往右走 pHead = next; //当前节点往右继续走 } return prev; } Test
var linkedlist = { length: 3, head: { value: 5, next: { value: 4, next: { value: 6, next: null } } }, }; ReverseList(linkedlist.</description>
    </item>
    
    <item>
      <title>16.合并两个排序的链表</title>
      <link>https://www.pengjielee.cn/post/merges-two-sorted-linked-lists/</link>
      <pubDate>Thu, 18 Feb 2021 10:11:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/merges-two-sorted-linked-lists/</guid>
      <description>题目 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
JS实现 1、递归实现
/*function ListNode(x){ this.val = x; this.next = null; }*/ function Merge(pHead1, pHead2) { if (pHead1 === null) { return pHead2; } if (pHead2 === null) { return pHead1; } if (pHead1.val &amp;lt; pHead2.val) { pHead1.next = Merge(pHead1.next, pHead2); return pHead1; } else { pHead2.next = Merge(pHead1, pHead2.next); return pHead2; } } 2、非递归实现
/*function ListNode(x){ this.val = x; this.next = null; }*/ function Merge(pHead1, pHead2) { // write code here if (pHead1 === null) { return pHead2; } if (pHead2 === null) { return pHead1; } let mergedHead = null; let current = null; while (pHead1 !</description>
    </item>
    
    <item>
      <title>36.两个链表的第一个公共结点</title>
      <link>https://www.pengjielee.cn/post/the-first-common-node-of-two-linked-lists/</link>
      <pubDate>Thu, 18 Feb 2021 09:30:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/the-first-common-node-of-two-linked-lists/</guid>
      <description>题目 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
思路 什么是公共节点，并不是两个节点的值相同就是公共节点。 而是在第一链表和第二链表中都存在一个节点，该节点往后的子链表在两个链表中是相同的。
如下图中链表6-7就是两个链表的公共链表，而节点6就是第一个公共节点。
1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 6 -&amp;gt; 7 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 如果两个链表存在公共节点，那么公共节点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，那么最后一个相同的节点就是我们要找的节点。但是这两个链表是单向的，要实现尾节点最先比较，我们可以借助两个辅助栈。分别将两个链表的节点放入两个栈中，这样栈顶就是两个链表的尾节点，比较两个栈顶节点是否相同，如果相同，将栈顶弹出比较下一个栈顶，直到找到最后一个相同的栈顶。时间复杂度O(m + n)。
JS实现 /*function ListNode(x){ this.val = x; this.next = null; }*/ function FindFirstCommonNode(pHead1, pHead2) { // write code here if (pHead1 === null || pHead2 === null) { return null; } let stack1 = [], stack2 = []; while (pHead1 != null) { stack1.push(pHead1); pHead1 = pHead1.</description>
    </item>
    
    <item>
      <title>判断单链表是否有环</title>
      <link>https://www.pengjielee.cn/algorithm/determine-if-a-single-linked-list-has-a-loop/</link>
      <pubDate>Wed, 10 Feb 2021 09:45:34 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/determine-if-a-single-linked-list-has-a-loop/</guid>
      <description>链表数据结构 // 节点类 class Node { constructor(value) { this.value = value; // 存储值 this.next = null; // 存储下一个节点的引用 } } //链表类 class LinkedList { constructor() { this.length = 0; //链表的长度 this.head = null; //链表的头结点 } //添加节点 append(value) { var node = new Node(value); //创建节点 if (!this.head) { this.head = node; //设置头结点 } else { var current = this.head; while (current.next) { //通过循环找到最后一个节点 current = current.next; } current.next = node; } this.</description>
    </item>
    
    <item>
      <title>55.链表中环的入口结点</title>
      <link>https://www.pengjielee.cn/post/the-entry-node-of-the-linked-list-loop/</link>
      <pubDate>Wed, 10 Feb 2021 08:52:23 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/the-entry-node-of-the-linked-list-loop/</guid>
      <description>题目 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
思路 1、设置快慢指针，假如有环，他们一定相遇在环中；
2、两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口；
JS实现 参考1
/*function ListNode(x){ this.val = x; this.next = null; }*/ function EntryNodeOfLoop(pHead) { // write code here //至少3个节点才能成环 if (!pHead || !pHead.next || !pHead.next.next) { return null; } //定义快慢指针 let slow = pHead.next; let fast = pHead.next.next; while (slow &amp;amp;&amp;amp; fast) { if (fast !== slow) { fast = fast.next.next; slow = slow.next; } else { break; } } //没有环 if (!fast || !slow) { return null; } fast = pHead; while (slow !</description>
    </item>
    
    <item>
      <title>字符串反转</title>
      <link>https://www.pengjielee.cn/algorithm/string-inversion/</link>
      <pubDate>Tue, 09 Feb 2021 15:13:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/algorithm/string-inversion/</guid>
      <description>JS实现 //实现1 var reverse1 = (str) =&amp;gt; { return str.split(&amp;#34;&amp;#34;).reverse().join(&amp;#34;&amp;#34;); }; //实现2 var reverse2 = (str) =&amp;gt; { let result = &amp;#34;&amp;#34;; for (let char of str) { result = char + result; } return result; }; //实现3 var reverse3 = (str) =&amp;gt; { return str.split(&amp;#34;&amp;#34;).reduce((result, char) =&amp;gt; char + result); }; var str = &amp;#39;hello&amp;#39;; console.log(reverse1(str)); //&amp;#39;olleh&amp;#39; console.log(reverse2(str)); //&amp;#39;olleh&amp;#39; console.log(reverse3(str)); //&amp;#39;olleh&amp;#39; Go实现 实现1:
package main import ( &amp;#34;fmt&amp;#34; ) func main() { str := &amp;#34;hello&amp;#34; result := Reverse(str) fmt.</description>
    </item>
    
    <item>
      <title>56.删除链表中重复的结点</title>
      <link>https://www.pengjielee.cn/post/delete-duplicate-nodes-in-the-linked-list/</link>
      <pubDate>Tue, 09 Feb 2021 14:23:46 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/delete-duplicate-nodes-in-the-linked-list/</guid>
      <description>题目 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5
思路 非递归的代码：
1、首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况；
2、设置 pre ，last 指针， pre指针指向当前确定不重复的那个节点，而last指针相当于工作指针，一直往后面搜索。
JS实现 // 非递归法 function deleteDuplication(pHead) { if (!pHead || !pHead.next) { return pHead; } let newHead = { val: &amp;#34;a&amp;#34;, next: pHead, }; let before = newHead; let current = newHead.next; while (current &amp;amp;&amp;amp; current.next) { if (current.val === current.next.val) { let val = current.val; while (current &amp;amp;&amp;amp; current.val === val) { current = current.next; } before.next = current; } else { current = current.</description>
    </item>
    
    <item>
      <title>JavaScript保护手机号隐私(中间4位用 * 号替换)</title>
      <link>https://www.pengjielee.cn/post/javascript-protects-the-privacy-of-the-phone-number/</link>
      <pubDate>Mon, 08 Feb 2021 10:34:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/javascript-protects-the-privacy-of-the-phone-number/</guid>
      <description>需求：将手机号码中间4位用 * 号替换，保护隐私。
使用正则 const encryptPhoneNumber = (str) =&amp;gt; { if (str) { str = str.trim(); const reg = /(\d{3})\d{4}(\d{3})/; str = str.replace(reg, &amp;#34;$1****$2&amp;#34;); } return str; }; encryptPhoneNumber(&amp;#34;18614023235&amp;#34;); //output: 186****3235 使用substring const encryptPhoneNumber = (str) =&amp;gt; { if (str) { str = str.trim(); str = str.substring(0,3) + &amp;#39;*&amp;#39;.repeat(4) + str.substring(str.length - 4); } return str; }; encryptPhoneNumber(&amp;#39;18614023235&amp;#39;); //output: 186****3235 加密身份证号 const encryptIDNumber = (str) =&amp;gt; { if (str) { str = str.</description>
    </item>
    
    <item>
      <title>读《关键对话：如何高效沟通》</title>
      <link>https://www.pengjielee.cn/post/read-critical-conversations-how-to-communicate-effectively/</link>
      <pubDate>Sun, 07 Feb 2021 17:10:11 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read-critical-conversations-how-to-communicate-effectively/</guid>
      <description>什么是关键对话 关键对话 我们所说的关键对话指的是每个人身上都会发生的和他人的互动行为，是指可影响你生活的那些日常对话。
关键对话有三个特征：
首先，对话双方的观点有很大差距。
其次，对话存在很高的风险。
最后，对话双方的情绪非常激烈。
关键对话指的是两人或多人之间的一种讨论，这种讨论具有三个特点：
1、高风险。
2、不同观点。
3、激烈情绪。
在面对关键对话时，我们通常有以下三种反映。 1、我们会逃避关键对话。
2、我们敢于面对，但往往处理不当。
3、我们敢于面对，而且处理得当。
关键对话失败的原因 1、人类的自然基因使然。
每当面对关键对话时我们便会下意识地采取人类面对危险时最原始的应对方式——暴力对抗或转身而逃，而不是采用机智的说服和友善的关注来解决问题。
当面对充满挑战的关键对话时，你的智力水平跟一只恒河猴差不了多少。你的身体准备应对的是一只剑齿虎的攻击，而不是老板、邻居或老公的批评指责。
2、我们都处在压力之下。
还有一点就是，由于关键对话经常是自发形成的，很多情况下它们都是毫无征兆地出现。
这就是我们在面对关键对话时的真实状态——棘手的问题、不依不饶的对手、高度缺血的大脑和无法正常工作的思维。这就是为什么我们平素表现得正常得体，可面对关键对话时却会变成十足的白痴。
3、我们被关键冲突问题难倒了。
我们不知道该如何开始关键对话。
和大家一样，你会采取临场发挥的办法来应对问题。你会抓住对方的言论，形成某种情绪，然后在此基础上决定下一步该怎么行动——当然，这一切都是在你那严重缺血的大脑中完成的。
4、我们经常是在搬起石头砸自己的脚。
换句话说，你的行为非但没有解决问题，反而导致你面对更加严重的、不愿看到的后果。你陷入了一个充满不健康影响的、自我伤害的怪圈而无法自拔。
容易带来灾难性后果的关键对话场景包括以下几方面 结束一段感情 和总是冒犯你或喜欢提建议的同事交谈 让朋友还钱 指出老板一些不对的做法 向经常言行不一的老板提出建议 批评同事的工作表现 让室友搬走 和前任配偶讨论孩子的监护权或探访权问题 应对处于青春期的叛逆儿女 指出队友违反承诺的表现 探讨关于出轨的问题 应对配偶严重的家庭暴力问题 和喜欢打听小道消息的同事交谈 做出不利的行为表现评价 说服配偶的家人不要干涉夫妻问题 提醒同事注意个人卫生 如何应对关键对话 应对关键对话的两大法宝 1、注意观察。
第一个能带来重要变化的法宝是注意观察。它指的是，善于改善对话技巧的人总是不停地问自己是否还在对话框架中，光是这一点就足以带来巨大的变化。
只要能关注自己是否陷入沉默或暴力状态就可以从这个原则中获益良多。
“我们是在装模作样还是真诚对话？”这个问题是实现对话的一个良好开端。
2、营造安全感。
营造安全感是健康对话的第二个法宝。
对话的基础是观点的自由交流，而阻塞这种交流的最大障碍就是缺乏安全感。
安全感是一项非常重要的对话原则，你应当努力让对方感到舒适自然，这样他才会产生交流的欲望。
两大法宝是正确识别、展开和维持对话的基础。
如何准备关键对话 1、从“心”开始。
首先问问自己你的真正目的是什么。
对话技巧：
关注你的真正目的；
拒绝做出“傻瓜式选择”；
关键问题：
我让人感觉自己的目的是什么？
我的真正目的是什么？（关于自己的、关于他人的、关于我们关系的）
怎样做才能实现这些真正目的？
我不希望怎样？
怎样才能真正实现希望的目的？
避免不希望实现的目的？
2、注意观察。
对话技巧：</description>
    </item>
    
    <item>
      <title>如何在React中全屏化页面</title>
      <link>https://www.pengjielee.cn/post/how-to-make-a-full-screen-page-in-react/</link>
      <pubDate>Thu, 04 Feb 2021 15:12:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/how-to-make-a-full-screen-page-in-react/</guid>
      <description>安装 $ npm install screenfull React中使用screenfull 1、引入
import screenfull from &amp;#39;screenfull&amp;#39;; 2、全屏
const handleClick = () =&amp;gt; { if (screenfull.isEnabled) { //全屏整个页面 //screenfull.request(); //全屏某个元素 screenfull.request(element); } }; 3、切换
const handleToggle = () =&amp;gt; { if (screenfull.isEnabled) { screenfull.toggle(); } }; 4、监听change事件
import React, { useEffect, useRef } from &amp;#34;react&amp;#34;; import screenfull from &amp;#34;screenfull&amp;#34;; const Component = () =&amp;gt; { useEffect(() =&amp;gt; { if (screenfull.isEnabled) { screenfull.on(&amp;#34;change&amp;#34;, () =&amp;gt; { console.log(&amp;#34;Am I fullscreen?</description>
    </item>
    
    <item>
      <title>使用shell脚本创建文件</title>
      <link>https://www.pengjielee.cn/post/use-shell-scripts-to-create-files/</link>
      <pubDate>Fri, 15 Jan 2021 16:24:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/use-shell-scripts-to-create-files/</guid>
      <description>文件名使用每日日期 newfile.sh
#!/bin/bash file_name=$(date +%Y.%m.%d) touch &amp;#34;${file_name}.md&amp;#34; 写入内容并创建文件 newfile.sh
#!/bin/bash file_name=$(date +%Y.%m.%d) echo &amp;#34;hello world&amp;#34; &amp;gt; &amp;#34;${file_name}.md&amp;#34; 批量创建文件 newfiles.sh
#!/bin/bash filenames=() filenames[0]=&amp;#39;CSS实现弹幕效果.md&amp;#39; filenames[1]=&amp;#39;CSS实现动画.md&amp;#39; filenames[1]=&amp;#39;CSS盒子模型.md&amp;#39; for filename in ${filenames[@]} do touch ${filename} done </description>
    </item>
    
    <item>
      <title>如何分析webpack构建时间</title>
      <link>https://www.pengjielee.cn/post/how-do-analyze-webpack-builds-time/</link>
      <pubDate>Thu, 14 Jan 2021 15:14:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/how-do-analyze-webpack-builds-time/</guid>
      <description>统计shell脚本执行时间 #!/bin/bash #记录开始时间 start_time=$(date +%s) #安装及构建 npm install npm run build #记录结束时间 end_time=$(date +%s) #计算执行时间 cost_time=$[ $end_time-$start_time ] #输出执行时间 echo $cost_time echo &amp;#34;cost time is $(($cost_time/60))min $(($cost_time%60))s&amp;#34; 分析webpack编译时间 1、安装speed-measure-webpack-plugin
$ npm install --save-dev speed-measure-webpack-plugin 2、更新webpack配置
Change your webpack config from
const webpackConfig = { plugins: [ new MyPlugin(), new MyOtherPlugin() ] } to
const SpeedMeasurePlugin = require(&amp;#34;speed-measure-webpack-plugin&amp;#34;); const smp = new SpeedMeasurePlugin(); const webpackConfig = smp.wrap({ plugins: [ new MyPlugin(), new MyOtherPlugin() ], }); </description>
    </item>
    
    <item>
      <title>好文收藏</title>
      <link>https://www.pengjielee.cn/post/other/articles/</link>
      <pubDate>Sat, 02 Jan 2021 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/articles/</guid>
      <description>框架 WTF is JSX
https://jasonformat.com/wtf-is-jsx/
React VS Vue：谁会成为2020年的冠军？
https://zhuanlan.zhihu.com/p/89416436
从头实现一个koa框架
https://zhuanlan.zhihu.com/p/35040744
不好意思！耽误你的十分钟，让MVVM原理还给你
https://juejin.cn/post/6844903586103558158
虚拟 DOM 到底是什么？
https://juejin.im/post/5d085ce85188255e1305cda1
从零开始实现一个React（一）：JSX和虚拟DOM
https://github.com/hujiulong/blog/issues/4
从零开始实现一个React（二）：组件和生命周期
https://github.com/hujiulong/blog/issues/5
从零开始实现一个React（三）：diff算法 https://github.com/hujiulong/blog/issues/6
从零开始实现一个React（四）：异步的setState
https://github.com/hujiulong/blog/issues/7
虚拟 DOM 库
https://github.com/snabbdom/snabbdom
https://github.com/Matt-Esch/virtual-dom
你需要的 Webpack 性能优化配置
https://mp.weixin.qq.com/s/sy_ZVJEqRvChLJWcx0o8rw
29行代码深入React Hooks原理（及原文）
https://juejin.cn/post/6844904128326434823
https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/
ReactHooks原理及简单实现
https://www.shymean.com/article/ReactHooks%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0
build-your-own-react
https://pomb.us/build-your-own-react/
didact
https://github.com/pomber/didact
深入理解React：事件机制原理
https://www.cnblogs.com/forcheng/p/13187388.html
谈谈React事件机制和未来(react-events)
https://bobi.ink/2019/07/29/react-event/
一文吃透 react 事件机制原理
https://cloud.tencent.com/developer/article/1516369
通过几个例子来理解 React 的事件系统
https://mp.weixin.qq.com/s/NLJlcdhMcPPgrS8KrnmQ9A
设计模式 观察者模式 vs 发布订阅模式（原文）
https://zhuanlan.zhihu.com/p/51357583
https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c 异步 面试官：“你能手写一个 Promise 吗”
https://zhuanlan.zhihu.com/p/183801144
当 async/await 遇上 forEach</description>
    </item>
    
    <item>
      <title>01.Electron应用创建.md</title>
      <link>https://www.pengjielee.cn/project/ikms-01/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-01/</guid>
      <description>创建Electron APP npx create-electron-app my-new-app # or yarn create electron-app my-new-app # then cd my-new-app npm start More electron-forge https://github.com/electron-userland/electron-forge</description>
    </item>
    
    <item>
      <title>02.Electron主进程代码.md</title>
      <link>https://www.pengjielee.cn/project/ikms-02/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-02/</guid>
      <description>main.js const { app, BrowserWindow } = require(&amp;#39;electron&amp;#39;); const path = require(&amp;#39;path&amp;#39;); // Handle creating/removing shortcuts on Windows when installing/uninstalling. if (require(&amp;#39;electron-squirrel-startup&amp;#39;)) { // eslint-disable-line global-require app.quit(); } // Keep a global reference of the window object, if you don&amp;#39;t, the window will // be closed automatically when the JavaScript object is garbage collected. let mainWindow; const createWindow = () =&amp;gt; { // Create the browser window. mainWindow = new BrowserWindow({ width: 800, height: 600, }); // and load the index.</description>
    </item>
    
    <item>
      <title>03.Electron注入环境变量.md</title>
      <link>https://www.pengjielee.cn/project/ikms-03/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-03/</guid>
      <description>package.json &amp;#34;scripts&amp;#34;: { &amp;#34;dev&amp;#34;: &amp;#34;export NODE_ENV=development &amp;amp;&amp;amp; electron-forge start&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;electron-forge start&amp;#34;, &amp;#34;package&amp;#34;: &amp;#34;electron-forge package&amp;#34;, &amp;#34;make&amp;#34;: &amp;#34;electron-forge make&amp;#34;, &amp;#34;publish&amp;#34;: &amp;#34;electron-forge publish&amp;#34; }, main.js // Open the DevTools. if (process.env.NODE_ENV === &amp;#34;development&amp;#34;) { mainWindow.webContents.openDevTools(); } </description>
    </item>
    
    <item>
      <title>04.Electron使用jQuery.md</title>
      <link>https://www.pengjielee.cn/project/ikms-04/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-04/</guid>
      <description>安装jQuery $ npm install jquery index.html &amp;lt;script&amp;gt; const $ = require(&amp;#34;jquery&amp;#34;); window.jQuery = $; &amp;lt;/script&amp;gt; </description>
    </item>
    
    <item>
      <title>05.Electron渲染进程报错.md</title>
      <link>https://www.pengjielee.cn/project/ikms-05/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-05/</guid>
      <description>报错信息 Uncaught ReferenceError: require is not defined at index.html:93 解决方法：设置 nodeIntegration: true mainWindow = new BrowserWindow({ minWidth: 300, backgroundColor: &amp;#34;#fff&amp;#34;, webPreferences: { nodeIntegration: true, }, }); </description>
    </item>
    
    <item>
      <title>06.Electron注册全局快捷键.md</title>
      <link>https://www.pengjielee.cn/project/ikms-06/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-06/</guid>
      <description>const { app, BrowserWindow, globalShortcut } = require(&amp;#39;electron&amp;#39;); const registerGlobalKey = () =&amp;gt; { const key = &amp;#39;CommandOrControl+Option+S&amp;#39;; const ret = globalShortcut.register(key, function () { console.log(`hello world from ${key}`) }); if(!ret){ console.log(`${key} registert failed`); } } const createWindow = () =&amp;gt; { mainWindow = new BrowserWindow({ minWidth: 300, backgroundColor: &amp;#34;#fff&amp;#34;, webPreferences: { nodeIntegration: true, }, }); registerGlobalKey(); }; </description>
    </item>
    
    <item>
      <title>07.Electron主进程向渲染进程发消息.md</title>
      <link>https://www.pengjielee.cn/project/ikms-07/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-07/</guid>
      <description>主进程：main.js mainWindow.webContents.send(&amp;#34;refresh-notes&amp;#34;, { message: &amp;#39;reload&amp;#39; }); 渲染进程：renderer.js const ipcRenderer = require(&amp;#34;electron&amp;#34;).ipcRenderer; ipcRenderer.on(&amp;#34;refresh-notes&amp;#34;, (event, data) =&amp;gt; { //getNotes(); }); </description>
    </item>
    
    <item>
      <title>08.Electron渲染进程向主进程发消息.md</title>
      <link>https://www.pengjielee.cn/project/ikms-08/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-08/</guid>
      <description>渲染进程：renderer.js const ipcRenderer = require(&amp;#34;electron&amp;#34;).ipcRenderer; ipcRenderer.send(&amp;#34;save-dialog&amp;#34;, { filename: filename, type: type }); 主进程：main.js const { ipcMain } = require(&amp;#34;electron&amp;#34;); ipcMain.on(&amp;#34;save-dialog&amp;#34;, (event, data) =&amp;gt; { }); </description>
    </item>
    
    <item>
      <title>09.Electron保存文件对话框.md</title>
      <link>https://www.pengjielee.cn/project/ikms-09/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-09/</guid>
      <description>const { dialog } = require(&amp;#34;electron&amp;#34;); const options = { title: &amp;#34;请选择要保存的文件名&amp;#34;, buttonLabel: &amp;#34;保存&amp;#34;, defaultPath: &amp;#39;test.txt&amp;#39;, filters: [{ name: &amp;#34;Custom File Type&amp;#34;, extensions: [&amp;#39;txt&amp;#39;] }], }; dialog.showSaveDialog(options).then((result) =&amp;gt; { if (!result.canceled) { console.log(result.filePath); } }); </description>
    </item>
    
    <item>
      <title>10.Electron设置系统托盘图标.md</title>
      <link>https://www.pengjielee.cn/project/ikms-10/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-10/</guid>
      <description>const trayIcon = new Tray(path.join(__dirname, &amp;#34;../assets/IconTemplate.png&amp;#34;)); trayIcon.on(&amp;#34;click&amp;#34;, function () { if (mainWindow === null) { return; } if (mainWindow.isVisible()) { mainWindow.hide(); } else { mainWindow.show(); } }); </description>
    </item>
    
    <item>
      <title>11.Electron设置Dock信息.md</title>
      <link>https://www.pengjielee.cn/project/ikms-11/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-11/</guid>
      <description>const { app } = require(&amp;#34;electron&amp;#34;); const path = require(&amp;#34;path&amp;#34;); app.dock.setIcon(path.join(__dirname, &amp;#34;../assets/IconTemplate@2x.png&amp;#34;)); const dockMenu = Menu.buildFromTemplate([ { label: &amp;#34;New Window&amp;#34;, click() { console.log(&amp;#34;New Window&amp;#34;); }, }, { label: &amp;#34;New Window with Settings&amp;#34;, submenu: [{ label: &amp;#34;Basic&amp;#34; }, { label: &amp;#34;Pro&amp;#34; }], }, { label: &amp;#34;New Command...&amp;#34; }, ]); app.dock.setMenu(dockMenu); app.dock.hide(); app.dock.isVisible(); app.setName(&amp;#34;我的粘贴板&amp;#34;); </description>
    </item>
    
    <item>
      <title>12.Electron设置程序菜单.md</title>
      <link>https://www.pengjielee.cn/project/ikms-12/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-12/</guid>
      <description>const { app, Menu } = require(&amp;#34;electron&amp;#34;); const setAppMenu = () =&amp;gt; { if (process.platform === &amp;#34;darwin&amp;#34;) { const template = [ { label: &amp;#34;Application&amp;#34;, submenu: [ { label: &amp;#34;Quit&amp;#34;, accelerator: &amp;#34;Command+Q&amp;#34;, click: function () { app.quit(); }, }, ], }, { label: &amp;#34;Edit&amp;#34;, submenu: [ { label: &amp;#34;Copy&amp;#34;, accelerator: &amp;#34;CmdOrCtrl+C&amp;#34;, selector: &amp;#34;copy:&amp;#34; }, { label: &amp;#34;Paste&amp;#34;, accelerator: &amp;#34;CmdOrCtrl+V&amp;#34;, selector: &amp;#34;paste:&amp;#34; }, ], }, ]; Menu.setApplicationMenu(Menu.buildFromTemplate(template)); } else { Menu.setApplicationMenu(null); } }; </description>
    </item>
    
    <item>
      <title>13.Electron使用粘贴板.md</title>
      <link>https://www.pengjielee.cn/project/ikms-13/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-13/</guid>
      <description>clipboard 模块在主进程和渲染进程中都可使用。
主进程中使用 const { clipboard } = require(&amp;#34;electron&amp;#34;); clipboard.readText(); 渲染进程中使用 const { clipboard } = require(&amp;#34;electron&amp;#34;); clipboard.writeText(&amp;#39;hello world&amp;#39;); clipboard.readText(); </description>
    </item>
    
    <item>
      <title>14.使用Nodejs保存文件.md</title>
      <link>https://www.pengjielee.cn/project/ikms-14/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-14/</guid>
      <description>const fs = require(&amp;#34;fs&amp;#34;); const filePath = &amp;#39;&amp;#39;; const content = &amp;#39;hello world&amp;#39;; fs.writeFileSync(filePath, content); </description>
    </item>
    
    <item>
      <title>15.Electron使用sqlite3.md</title>
      <link>https://www.pengjielee.cn/project/ikms-15/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-15/</guid>
      <description>安装 $ npm install sqlite3 $ npm install bluebird App Dao const sqlite3 = require(&amp;#34;sqlite3&amp;#34;); const Promise = require(&amp;#34;bluebird&amp;#34;); class AppDAO { constructor(dbFilePath) { this.db = new sqlite3.Database(dbFilePath, (err) =&amp;gt; { if (err) { console.log(&amp;#34;Could not connect to database&amp;#34;, err); } else { console.log(&amp;#34;Connected to database&amp;#34;); } }); } run(sql, params = []) { return new Promise((resolve, reject) =&amp;gt; { this.db.run(sql, params, function (err) { if (err) { console.log(&amp;#34;Error running sql &amp;#34; + sql); console.</description>
    </item>
    
    <item>
      <title>16.使用dayjs格式化日期.md</title>
      <link>https://www.pengjielee.cn/project/ikms-16/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-16/</guid>
      <description>安装 $ npm install dayjs 使用 const dayjs = require(&amp;#34;dayjs&amp;#34;); const now = dayjs(); const date = now.format(&amp;#34;YYYY-MM-DD&amp;#34;); const time = now.format(&amp;#34;HH:mm:ss&amp;#34;); const timestamp = now.valueOf(); More https://github.com/iamkun/dayjs</description>
    </item>
    
    <item>
      <title>17.Electron发送通知.md</title>
      <link>https://www.pengjielee.cn/project/ikms-17/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-17/</guid>
      <description>渲染进程（H5 Notification） const notifyMe = () =&amp;gt; { const message = &amp;#39;您有新的内容保存到粘贴板&amp;#39;; // Let&amp;#39;s check if the browser supports notifications if (!(&amp;#34;Notification&amp;#34; in window)) { alert(&amp;#34;This browser does not support desktop notification&amp;#34;); } // Let&amp;#39;s check whether notification permissions have already been granted else if (Notification.permission === &amp;#34;granted&amp;#34;) { // If it&amp;#39;s okay let&amp;#39;s create a notification var notification = new Notification(message); } // Otherwise, we need to ask the user for permission else if (Notification.</description>
    </item>
    
    <item>
      <title>18.编码解码.md</title>
      <link>https://www.pengjielee.cn/project/ikms-18/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-18/</guid>
      <description>const encode = (str) =&amp;gt; { var s = &amp;#34;&amp;#34;; if (str.length == 0) return &amp;#34;&amp;#34;; s = str.replace(/&amp;amp;/g, &amp;#34;&amp;amp;amp;&amp;#34;); s = s.replace(/&amp;lt;/g, &amp;#34;&amp;amp;lt;&amp;#34;); s = s.replace(/&amp;gt;/g, &amp;#34;&amp;amp;gt;&amp;#34;); s = s.replace(/\s/g, &amp;#34;&amp;amp;nbsp;&amp;#34;); s = s.replace(/\&amp;#39;/g, &amp;#34;&amp;amp;#39;&amp;#34;); s = s.replace(/\&amp;#34;/g, &amp;#34;&amp;amp;quot;&amp;#34;); return s; }; const decode = (str) =&amp;gt; { var s = &amp;#34;&amp;#34;; if (str.length == 0) return &amp;#34;&amp;#34;; s = str.replace(/&amp;amp;amp;/g, &amp;#34;&amp;amp;&amp;#34;); s = s.replace(/&amp;amp;lt;/g, &amp;#34;&amp;lt;&amp;#34;); s = s.replace(/&amp;amp;gt;/g, &amp;#34;&amp;gt;&amp;#34;); s = s.</description>
    </item>
    
    <item>
      <title>19.Electron在浏览器中打开新链接.md</title>
      <link>https://www.pengjielee.cn/project/ikms-19/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-19/</guid>
      <description>const { shell } = require(&amp;#34;electron&amp;#34;); shell.openExternal(&amp;#34;https://www.baidu.com&amp;#34;); </description>
    </item>
    
    <item>
      <title>20.Electron中使用Vue.md</title>
      <link>https://www.pengjielee.cn/project/ikms-20/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-20/</guid>
      <description>index.html &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;p class=&amp;#34;message&amp;#34;&amp;gt;{{ message }}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/vue@2.6.12/dist/vue.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/vue-router@3.4.3/dist/vue-router.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/element-ui/lib/index.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;renderer.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; /pages/home/index.js const Index = { template: ` &amp;lt;div class=&amp;#34;page-home&amp;#34;&amp;gt; Hello World! &amp;lt;/div&amp;gt; `, }; module.exports = Index; renderer.js const Home = require(&amp;#34;./pages/home/index.js&amp;#34;); const About = require(&amp;#34;./pages/about/index.js&amp;#34;); const Setting = require(&amp;#34;./pages/setting/index.js&amp;#34;); const routes = [ { path: &amp;#34;/&amp;#34;, component: Home }, { path: &amp;#34;/about&amp;#34;, component: About }, { path: &amp;#34;/setting&amp;#34;, component: Setting }, ]; const router = new VueRouter({ routes, }); var app = new Vue({ el: &amp;#34;#app&amp;#34;, router, created: function () {}, data: { message: &amp;#34;Hello Vue!</description>
    </item>
    
    <item>
      <title>21.使用hightlight.js输出代码.md</title>
      <link>https://www.pengjielee.cn/project/ikms-21/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-21/</guid>
      <description>install $ npm install highlight.js include &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; const hljs = require(&amp;#34;highlight.js&amp;#34;); Vue.use(hljs.vuePlugin); &amp;lt;/script&amp;gt; usage &amp;lt;highlightjs autodetect :code=&amp;#34;content&amp;#34; /&amp;gt; More https://github.com/highlightjs/highlight.js</description>
    </item>
    
    <item>
      <title>22.使用codemirror编辑器.md</title>
      <link>https://www.pengjielee.cn/project/ikms-22/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-22/</guid>
      <description>include &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;assets/codemirror/codemirror.css&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;assets/codemirror/codemirror.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; usage const Edit = { template: ` &amp;lt;div class=&amp;#34;pure-form pure-form-stacked&amp;#34;&amp;gt; &amp;lt;textarea ref=&amp;#34;code&amp;#34;&amp;gt;&amp;lt;/textarea&amp;gt; &amp;lt;el-button type=&amp;#34;primary&amp;#34; size=&amp;#34;medium&amp;#34; @click=&amp;#34;handleSave&amp;#34;&amp;gt;保存&amp;lt;/el-button&amp;gt; &amp;lt;/div&amp;gt; `, mounted: async function () { const editor = CodeMirror.fromTextArea(this.$refs.code, { lineNumbers: true, }); // editor.on(&amp;#39;change&amp;#39;, (codeMirror) =&amp;gt; {}); this.editor = editor; editor.doc.setValue(&amp;#39;hello world&amp;#39;); }, methods: { handleSave() { const content = this.editor.doc.getValue(); console.log(content); }, } }; More https://github.com/codemirror/CodeMirror</description>
    </item>
    
    <item>
      <title>23.使用prettier格式化代码.md</title>
      <link>https://www.pengjielee.cn/project/ikms-23/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-23/</guid>
      <description>install $ npm install prettier usage const prettier = require(&amp;#34;prettier&amp;#34;); const code = ` const now = dayjs() const date = now.format(&amp;#34;YYYY-MM-DD&amp;#34;) const time = now.format(&amp;#34;HH:mm:ss&amp;#34;) const timestamp = now.valueOf() `; const content = prettier.format(code, { parser: &amp;#34;babel&amp;#34;, semi: false }); </description>
    </item>
    
    <item>
      <title>24.Electron消息提示框.md</title>
      <link>https://www.pengjielee.cn/project/ikms-24/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-24/</guid>
      <description>const options = { type: &amp;#34;info&amp;#34;, title: &amp;#34;Information&amp;#34;, message: &amp;#39;hello world&amp;#39;, buttons: [&amp;#34;Yes&amp;#34;,&amp;#34;No&amp;#34;], }; dialog.showMessageBox(options); </description>
    </item>
    
    <item>
      <title>25.Electron备份还原sqlite数据库.md</title>
      <link>https://www.pengjielee.cn/project/ikms-25/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-25/</guid>
      <description>const backupDb = () =&amp;gt; { const options = { title: &amp;#34;请选择要备份的文件名&amp;#34;, buttonLabel: &amp;#34;保存&amp;#34;, defaultPath: &amp;#34;my.db&amp;#34;, filters: [{ name: &amp;#34;Custom File Type&amp;#34;, extensions: [&amp;#34;db&amp;#34;] }], }; dialog.showSaveDialog(options).then(async (result) =&amp;gt; { if (!result.canceled) { const fileReadStream = fs.createReadStream(path.join(__dirname, &amp;#34;my.db&amp;#34;)); const fileWriteStream = fs.createWriteStream(result.filePath); fileReadStream.pipe(fileWriteStream); fileWriteStream.on(&amp;#34;close&amp;#34;, function () { showMessage(&amp;#34;备份成功&amp;#34;); }); } }); }; const restoreDb = () =&amp;gt; { const options = { title: &amp;#34;请选择要还原的文件&amp;#34;, buttonLabel: &amp;#34;还原&amp;#34;, defaultPath: &amp;#34;my.db&amp;#34;, filters: [{ name: &amp;#34;Custom File Type&amp;#34;, extensions: [&amp;#34;db&amp;#34;] }], properties: [&amp;#34;openFile&amp;#34;], }; dialog.</description>
    </item>
    
    <item>
      <title>26.Electron隐藏显示开发者工具.md</title>
      <link>https://www.pengjielee.cn/project/ikms-26/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-26/</guid>
      <description>if (process.platform === &amp;#34;darwin&amp;#34;) { const template = [ { label: &amp;#34;我的知识库&amp;#34;, submenu: [ { label: &amp;#34;退出&amp;#34;, accelerator: &amp;#34;Command+Q&amp;#34;, click: function () { app.quit(); }, }, ], }, { label: &amp;#34;编辑&amp;#34;, submenu: [ { label: &amp;#34;复制&amp;#34;, accelerator: &amp;#34;CmdOrCtrl+C&amp;#34;, selector: &amp;#34;copy:&amp;#34; }, { label: &amp;#34;粘贴&amp;#34;, accelerator: &amp;#34;CmdOrCtrl+V&amp;#34;, selector: &amp;#34;paste:&amp;#34; }, ], }, { label: &amp;#34;开发&amp;#34;, submenu: [ { label: &amp;#34;DevTools&amp;#34;, accelerator: &amp;#34;CmdOrCtrl+Shift+I&amp;#34;, click(item, focusedWindow) { if (focusedWindow) focusedWindow.webContents.toggleDevTools(); }, }, ], }, ]; Menu.</description>
    </item>
    
    <item>
      <title>26.使用cheerio获取文章标题.md</title>
      <link>https://www.pengjielee.cn/project/ikms-26/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-26/</guid>
      <description>install $ npm install cheerio usage const cheerio = require(&amp;#34;cheerio&amp;#34;); const $ = cheerio.load(html); const title = $(&amp;#34;head title&amp;#34;).text(); More cheerio https://github.com/cheeriojs/cheerio</description>
    </item>
    
    <item>
      <title>27.使用request获取网页内容.md</title>
      <link>https://www.pengjielee.cn/project/ikms-27/</link>
      <pubDate>Sun, 20 Dec 2020 11:40:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/project/ikms-27/</guid>
      <description>install $ npm install request $ npm install request-promise usage const request = require(&amp;#39;request&amp;#39;); request(&amp;#39;https://www.baidu.com&amp;#39;, function (error, response, body) { console.error(&amp;#39;error:&amp;#39;, error); // Print the error if one occurred console.log(&amp;#39;statusCode:&amp;#39;, response &amp;amp;&amp;amp; response.statusCode); // Print the response status code if a response was received console.log(&amp;#39;body:&amp;#39;, body); // Print the HTML for the baidu homepage. }); 使用rp const rp = require(&amp;#39;request-promise&amp;#39;); rp(&amp;#39;https://www.baidu.com&amp;#39;) .then(function (htmlString) { // Process html... }) .catch(function (err) { // Crawling failed.</description>
    </item>
    
    <item>
      <title>我的prettier配置</title>
      <link>https://www.pengjielee.cn/post/my-prettier-config/</link>
      <pubDate>Tue, 08 Dec 2020 11:57:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/my-prettier-config/</guid>
      <description>创建文件 touch .prettierrc.js 内容 .prettier.js
module.exports = { arrowParens: &amp;#34;avoid&amp;#34;, bracketSpacing: true, printWidth: 120, semi: true, singleQuote: true, tabWidth: 4, trailingComma: &amp;#34;all&amp;#34;, jsxSingleQuote: false, jsxBracketSameLine: false, useTabs: false, overrides: [ { files: &amp;#34;*.html&amp;#34;, options: { parser: &amp;#34;angular&amp;#34;, htmlWhitespaceSensitivity: &amp;#34;ignore&amp;#34;, printWidth: 120, tabWidth: 4, }, }, { files: &amp;#34;*.wxss&amp;#34;, options: { parser: &amp;#34;css&amp;#34;, }, }, ], }; 说明 arrowParens: &amp;lsquo;avoid&amp;rsquo;,
在箭头函数参数周围包含圆括号，默认&amp;quot;always&amp;quot;；avoid:x =&amp;gt; x，always:(x) =&amp;gt; x
bracketSpacing: true,
是否在括号之间打印空格，默认true；true:{ foo: bar }，false:{foo:bar}</description>
    </item>
    
    <item>
      <title>我的bash配置</title>
      <link>https://www.pengjielee.cn/post/my-bash-config/</link>
      <pubDate>Tue, 08 Dec 2020 11:42:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/my-bash-config/</guid>
      <description>打开bash_profile $ cd ~ $ vi .bash_profile 内容 1、快速切换到常用目录
alias cd.pw=&amp;#34;cd /Users/pengjie/work/panda-wechat&amp;#34; alias cd.p5=&amp;#34;cd /Users/pengjie/work/panda-h5&amp;#34; alias cd.doc=&amp;#34;cd /Users/pengjie/www/doc.pengjielee.cn&amp;#34; alias cd.www=&amp;#34;cd /Users/pengjie/www&amp;#34; alias cd.try=&amp;#34;cd /Users/pengjie/try&amp;#34; alias cd.nginx=&amp;#34;cd /usr/local/etc/nginx/&amp;#34; 2、bash编辑更新
BASH_PROFILE_PATH=&amp;#34;$HOME/.bash_profile&amp;#34; alias bash.open=&amp;#34;open ${BASH_PROFILE_PATH}&amp;#34; alias bash.src=&amp;#34;source ${BASH_PROFILE_PATH}&amp;#34; 3、git操作快捷键
alias gs=&amp;#34;git status &amp;#34; alias ga=&amp;#34;git add &amp;#34; alias gaa=&amp;#34;git add -A &amp;#34; alias gb=&amp;#34;git branch &amp;#34; alias gc=&amp;#34;git commit &amp;#34; alias gcm=&amp;#34;git commit -m &amp;#34; alias gck=&amp;#34;git checkout &amp;#34; alias gp=&amp;#34;git push &amp;#34; 4、登录服务器</description>
    </item>
    
    <item>
      <title>Git tag操作</title>
      <link>https://www.pengjielee.cn/post/git-tag-operation/</link>
      <pubDate>Fri, 04 Dec 2020 13:53:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/git-tag-operation/</guid>
      <description>1. 显示所有tag git tag 2. 查看某个版本的tag git tag -l &amp;#39;v1.0.*&amp;#39; 3. 创建标签 git tag -a v1.0.0 -m &amp;#39;版本1.0&amp;#39; 4. 查看标签的详情，可以看到你commit的内容 git show v1.0.0 5. 推送标签 git push origin v1.0.0 6. 删除本地标签 git tag -d v1.0.0 7. 删除远程标签 git push origin :refs/tags/v1.0.0 More Git tag用法
https://www.jianshu.com/p/50c1b2433774</description>
    </item>
    
    <item>
      <title>Python基础：操作Mongodb</title>
      <link>https://www.pengjielee.cn/post/python-basic-operating-the-mongodb/</link>
      <pubDate>Tue, 17 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-operating-the-mongodb/</guid>
      <description>查看python版本/更新pip $ python3 --version $ pip install --upgrade pip 安装 pip install pymongo 连接mongodb from pymongo import MongoClient # 格式化输出 from pprint import pprint client = MongoClient(&amp;#39;mongodb://localhost:27017/&amp;#39;) # 指定数据库 db = client.wangyi # 指定集合 collection = db.playlist 插入 # 插入单条 result = collection.insert_one({&amp;#39;title&amp;#39;:&amp;#39;test&amp;#39;}) pprint(result) # 插入多条 result = collection.insert_many([{&amp;#39;title&amp;#39;:&amp;#39;test1&amp;#39;},{&amp;#39;title&amp;#39;:&amp;#39;test2&amp;#39;}]) pprint(result) 查询 # 查询一条 result = collection.find_one({}) pprint(result) # 查询多条 results = collection.find({}) pprint(results) for item in results: print(item) # 条件查询 results = collection.</description>
    </item>
    
    <item>
      <title>Python基础：操作Mysql</title>
      <link>https://www.pengjielee.cn/post/python-basic-operating-the-mysql/</link>
      <pubDate>Mon, 16 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-operating-the-mysql/</guid>
      <description>导入pymysql import pymysql.cursors 连接数据库 import pymysql.cursors def connect(): return pymysql.connect(host=&amp;#39;localhost&amp;#39;, port=3306, user=&amp;#39;root&amp;#39;, password=&amp;#39;386mysql.&amp;#39;, database=&amp;#39;test&amp;#39;, charset=&amp;#39;utf8mb4&amp;#39;, cursorclass=pymysql.cursors.DictCursor) 插入数据 def insert(): conn = connect() cursor = conn.cursor() try: sql = &amp;#34;INSERT INTO `users` (`email`) VALUES (%s)&amp;#34; cursor.execute(sql, (&amp;#39;386276251@qq.com&amp;#39;)) conn.commit() except Exception as e: print(e) conn.rollback() finally: cursor.close() conn.close() 插入多条数据 def insertMany(): conn = connect() cursor = conn.cursor() try: emails = [&amp;#39;386276252@qq.com&amp;#39;, &amp;#39;386276253@qq.com&amp;#39;, &amp;#39;386276254@qq.com&amp;#39;] sql = &amp;#34;INSERT INTO `users` (`email`) VALUES (%s)&amp;#34; cursor.executemany(sql, emails) conn.</description>
    </item>
    
    <item>
      <title>Python基础：读写CSV</title>
      <link>https://www.pengjielee.cn/post/python-basic-reading-and-writing-csv/</link>
      <pubDate>Sun, 15 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-reading-and-writing-csv/</guid>
      <description>CSV (Comma Separated Values)，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号。
引入python csv import csv 使用csv reader读取 contacts.csv
10,jim,18614023231 11,tom,18614023232 12,mike,18614023233 with open(contacts.csv,newline=&amp;#39;&amp;#39;) as csvfile: reader=csv.reader(csvfile,delimiter=&amp;#39;,&amp;#39;) for row in reader: print(row) #print(&amp;#39;, &amp;#39;.join(row)) #print(row[0]+&amp;#39;,&amp;#39;+row[1]+&amp;#39;,&amp;#39;+row[2]) &amp;#34;&amp;#34;&amp;#34; output: [&amp;#39;10&amp;#39;, &amp;#39;jim&amp;#39;, &amp;#39;18614023231&amp;#39;] [&amp;#39;11&amp;#39;, &amp;#39;tom&amp;#39;, &amp;#39;18614023232&amp;#39;] [&amp;#39;12&amp;#39;, &amp;#39;mike&amp;#39;, &amp;#39;18614023233&amp;#39;] &amp;#34;&amp;#34;&amp;#34; 使用csv reader读取其他分隔符 contacts.csv
10|jim|18614023231 11|tom|18614023232 12|mike|18614023233 with open(contacts.csv,newline=&amp;#39;&amp;#39;) as csvfile: reader=csv.reader(csvfile,delimiter=&amp;#39;|&amp;#39;) for row in reader: print(row) &amp;#34;&amp;#34;&amp;#34; output: [&amp;#39;10&amp;#39;, &amp;#39;jim&amp;#39;, &amp;#39;18614023231&amp;#39;] [&amp;#39;11&amp;#39;, &amp;#39;tom&amp;#39;, &amp;#39;18614023232&amp;#39;] [&amp;#39;12&amp;#39;, &amp;#39;mike&amp;#39;, &amp;#39;18614023233&amp;#39;] &amp;#34;&amp;#34;&amp;#34; 使用csv dictreader读取 contacts.csv</description>
    </item>
    
    <item>
      <title>Python基础：发送网络请求</title>
      <link>https://www.pengjielee.cn/post/python-basic-sending-a-network-request/</link>
      <pubDate>Sat, 14 Nov 2020 19:00:45 +0801</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-sending-a-network-request/</guid>
      <description>安装 pip install requests 导入 import requests 发送get请求 r = requests.get(&amp;#39;http://www.baidu.com&amp;#39;) r.status_code #200 r.text r.encoding r.cookies r.headers r.headers[&amp;#39;content-type&amp;#39;] 发送post请求（自定义头部） headers = { &amp;#39;Authorization&amp;#39;: &amp;#39;bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiI1YzA3MzdmZTExNGZhZDExMmM5NDg4YmMiLCJpYXQiOjE1NDc3OTQyNDEsImV4cCI6MTU0Nzk2NzA0MX0.BVBqJizBOqlnVa0xQvWsoAAAY9loBpjs7En0WapEA2Q&amp;#39; } r = requests.post(&amp;#39;http://api.xxx.cn/notes&amp;#39;, headers=headers, data = {&amp;#39;title&amp;#39;:&amp;#39;hello1&amp;#39;,&amp;#39;content&amp;#39;:&amp;#39;hello&amp;#39;,&amp;#39;tags&amp;#39;:&amp;#39;hello&amp;#39;}) r.status_code #200 发送delete请求（自定义头部） r = requests.delete(&amp;#39;http://api.xxx.cn/notes/5c417a9d9bc6b3248bac3cba&amp;#39; ,headers=headers ) r.status_code #200 r.json() 发送put请求（自定义头部） r = requests.put(&amp;#39;http://api.xxx.cn/notes&amp;#39;, headers=headers, data = {&amp;#39;id&amp;#39;:&amp;#39;5c417d339bc6b3248bac3cbb&amp;#39;,&amp;#39;title&amp;#39;:&amp;#39;hello1&amp;#39;,&amp;#39;content&amp;#39;:&amp;#39;hello1&amp;#39;,&amp;#39;tags&amp;#39;:&amp;#39;hello1&amp;#39;}) r.status_code #200 发送get请求（带参数） r = requests.get(&amp;#39;http://api.xxx.cn/notes&amp;#39;, params={&amp;#39;id&amp;#39;:&amp;#39;5c088665cc0e141e46580592&amp;#39;}) r.status_code #200 r.text r.json() More http://cn.python-requests.org/zh_CN/latest/</description>
    </item>
    
    <item>
      <title>Python基础：异常处理</title>
      <link>https://www.pengjielee.cn/post/python-basic-exception-handling/</link>
      <pubDate>Fri, 13 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-exception-handling/</guid>
      <description>触发异常 创建 division.py 文件
result = 2 / 0 print(result) 程序报错：
Traceback (most recent call last): File &amp;#34;division.py&amp;#34;, line 1, in &amp;lt;module&amp;gt; result = 2 / 0 ZeroDivisionError: division by zero 捕获异常 try: result = 2 / 0 print(result) except ZeroDivisionError: print(&amp;#39;除数不能为0&amp;#39;) # output: 除数不能为0 try-except-else 出错时捕获异常，成功时执行else代码块。
print(&amp;#39;给两个数字，计算商：(按q退出)&amp;#39;) while True: first_number = input(&amp;#39;被除数：&amp;#39;) if first_number == &amp;#39;q&amp;#39;: break second_number = input(&amp;#39;除数：&amp;#39;) try: answer = int(first_number) / int(second_number) except ZeroDivisionError: print(&amp;#39;警告：除数不能为0&amp;#39;) else: print(answer) 异常类型 1、ZeroDivisionError 除数为 0 引发此异常</description>
    </item>
    
    <item>
      <title>18个tar命令例子</title>
      <link>https://www.pengjielee.cn/post/18-examples-of-tar-command/</link>
      <pubDate>Wed, 11 Nov 2020 10:52:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/18-examples-of-tar-command/</guid>
      <description>Prepare $ mkdir dist $ cd dist $ touch file1.txt file2.txt $ mkdir js 1. Create tar Archive File $ tar -cvf dist.tar ./dist a dist a dist/file2.txt a dist/file1.txt a dist/js NOTE: c – Creates a new .tar archive file. v – Verbosely show the .tar file progress. f – File name type of the archive file.
2. Create tar.gz Archive File $ tar cvzf dist.tar.gz ./dist or $ tar cvzf dist.</description>
    </item>
    
    <item>
      <title>React Hook使用</title>
      <link>https://www.pengjielee.cn/post/the-react-hook-use/</link>
      <pubDate>Wed, 11 Nov 2020 10:34:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/the-react-hook-use/</guid>
      <description>useState import React, { useState } from &amp;#39;react&amp;#39;; function Counter() { const [count, setCount] = useState(0); return ( &amp;lt;div&amp;gt; &amp;lt;p className=&amp;#39;title&amp;#39;&amp;gt;You clicked {count} times&amp;lt;/p&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt;Click me&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); } export default Counter; useEffect：设置标题 import React, { useState, useEffect } from &amp;#39;react&amp;#39;; function Counter() { const [count, setCount] = useState(0); useEffect(() =&amp;gt; { document.title = `You clicked ${count} times`; }); return ( &amp;lt;div&amp;gt; &amp;lt;p className=&amp;#39;title&amp;#39;&amp;gt;You clicked {count} times&amp;lt;/p&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt;Click me&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); } export default Counter; useEffect：监听滚动/移除滚动 import React, { useState, useEffect } from &amp;#39;react&amp;#39;; function Counter() { const [count, setCount] = useState(0); useEffect(() =&amp;gt; { document.</description>
    </item>
    
    <item>
      <title>React中使用TypeScript</title>
      <link>https://www.pengjielee.cn/post/use-typescript-in-react/</link>
      <pubDate>Wed, 11 Nov 2020 10:34:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/use-typescript-in-react/</guid>
      <description>初始化 $ mkdir react-ts-app $ cd react-ts-app $ npm init -y $ npm install react react-dom $ mkdir src $ cd src $ touch index.html $ touch App.tsx src/index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;React + TypeScript&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;main&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;./App.tsx&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 安装Parcel $ npm i parcel-bundler -D $ npm i typescript -D $ npm i -D @types/react @types/react-dom package.</description>
    </item>
    
    <item>
      <title>React高阶组件</title>
      <link>https://www.pengjielee.cn/post/the-react-higher-order-component/</link>
      <pubDate>Wed, 11 Nov 2020 10:34:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/the-react-higher-order-component/</guid>
      <description>高阶组件（HOC），High Order Component。 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。
高阶组件是参数为组件，返回值为新组件的函数。
class NoteList extends React.Component { constructor(props) { super(props); } render() { return ( &amp;lt;div className=&amp;#34;list&amp;#34;&amp;gt; { this.props.list.map(function(item, index) { return ( &amp;lt;div className=&amp;#34;list-item&amp;#34;&amp;gt; &amp;lt;a className=&amp;#34;title&amp;#34;&amp;gt;{item.title}&amp;lt;/a&amp;gt; &amp;lt;div className=&amp;#34;content&amp;#34; dangerouslySetInnerHTML={{__html: item.content}}&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ); }) } &amp;lt;/div&amp;gt; ); } } class BlogList extends React.Component { constructor(props) { super(props); this.handleRemove = this.handleRemove.bind(this); } handleRemove(id,e){ this.props.handleRemove(id,e); } renderList(){ const self = this; return this.</description>
    </item>
    
    <item>
      <title>Python基础：文件读写</title>
      <link>https://www.pengjielee.cn/post/python-basic-reading-and-writing-file/</link>
      <pubDate>Tue, 10 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-reading-and-writing-file/</guid>
      <description>准备工作 1、文件结构
python_work（目录） -- hello.txt -- read_all.py -- read_by_line.py -- write_file.py -- append_file.py 2、创建hello.txt，内容如下：
hello world hello tomorrow hello time hello myself 读取整个文件 创建read_all.py，内容如下：
with open(&amp;#39;hello.txt&amp;#39;) as file_reader: content = file_reader.read() print(content) 逐行读取文件 创建read_by_line.py，内容如下：
with open(&amp;#39;hello.txt&amp;#39;) as file_reader: for line in file_reader: print(line.strip()) 写入空文件 创建write_file.py，内容如下：
# newfile.txt不存在，会创建；如果存在，会重新写入内容（覆盖原来内容） with open(&amp;#39;newfile.txt&amp;#39;, &amp;#39;w&amp;#39;) as file_writer: file_writer.write(&amp;#39;Hello World.&amp;#39;) 追加写入文件 创建append_file.py，内容如下：
# appendfile.txt不存在，会创建；如果存在，会追加写入内容（不会覆盖原来内容） with open(&amp;#39;appendfile.txt&amp;#39;, &amp;#39;a&amp;#39;) as file_writer: file_writer.write(&amp;#39;Hello World.&amp;#39;) </description>
    </item>
    
    <item>
      <title>Python基础：类</title>
      <link>https://www.pengjielee.cn/post/python-basic-class/</link>
      <pubDate>Mon, 09 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-class/</guid>
      <description>创建类 创建 animal.py 文件，定义动物类。
class Animal: &amp;#34;&amp;#34;&amp;#34;初始化方法&amp;#34;&amp;#34;&amp;#34; def __init__(self, name, age): self.name = name self.age = age &amp;#34;&amp;#34;&amp;#34;方法eat&amp;#34;&amp;#34;&amp;#34; def eat(self): print(self.name.title() + &amp;#39; &amp;#39; + &amp;#39;is eating.&amp;#39;) &amp;#34;&amp;#34;&amp;#34;方法run&amp;#34;&amp;#34;&amp;#34; def run(self): print(self.name.title() + &amp;#39; &amp;#39; + &amp;#39;is running.&amp;#39;) 创建实例 创建动物类的实例。
dog = Animal(&amp;#39;xiaohua&amp;#39;, 6) print(dog.name) # 访问属性name print(dog.age) # 访问属性age dog.eat() # 调用方法eat() dog.run() # 调用方法run() # output: &amp;#34;&amp;#34;&amp;#34; xiaohua 6 Xiaohua is eating. Xiaohua is running. &amp;#34;&amp;#34;&amp;#34; 继承 创建 dog.py 文件，定义 Dog 类，Dog 类 继承 Animal类。</description>
    </item>
    
    <item>
      <title>Python基础：函数</title>
      <link>https://www.pengjielee.cn/post/python-basic-function/</link>
      <pubDate>Sun, 08 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-function/</guid>
      <description>定义函数 # 定义函数 def hello(): print(&amp;#39;hello world!&amp;#39;) # 调用函数 hello() # Prints out: hello world! 参数传递 1、设置参数
def hello(name): print(&amp;#39;hello %s&amp;#39; % name) temp = hello(&amp;#39;jack&amp;#39;) # Prints out: hello jack print(temp) # Prints out: None def sum(a, b): return a + b sum(1, 2) # Prints out: 3 2、参数默认值
def hello(name=&amp;#39;jack&amp;#39;): print(&amp;#39;hello %s&amp;#39; % name) hello() # Prints out: hello jack hello(&amp;#39;jim&amp;#39;) # Prints out: hello jim def sum(a,b=2): return a + b sum(1) # Prints out: 3 sum(2) # Prints out: 4 # 注意：带默认值的参数必须放在不带默认值的参数之后 def sum(a=1,b): # SyntaxError: non-default argument follows default argument return a + b 2、可变参数</description>
    </item>
    
    <item>
      <title>Python基础：元组</title>
      <link>https://www.pengjielee.cn/post/python-baisc-tuple/</link>
      <pubDate>Sat, 07 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-baisc-tuple/</guid>
      <description>创建元组 # 定义空元组 t1 = () print(t1) # Prints out: () print(type(t1)) # Prints out: &amp;lt;class &amp;#39;tuple&amp;#39;&amp;gt; # 定义一元组 t2 = (2,) print(t2) # Prints out: (2,) print(type(t2)) # Prints out: &amp;lt;class &amp;#39;tuple&amp;#39;&amp;gt; # 定义三元组 t3 = (30, 10, 55) print(t3) # Prints out: (30, 10, 55) print(type(t3)) # Prints out: &amp;lt;class &amp;#39;tuple&amp;#39;&amp;gt; 访问元组 t1 = (1,3,5,7,9) print(t1[0]) # Prints out: 1 print(t1[5]) # IndexError: tuple index out of range print(t1[1:3]) # Prints out: (3, 5) print(t1[-2]) # Prints out: 7 修改元组 t1 = (1,3,5,7,9) t1[0] = 2 # TypeError: &amp;#39;tuple&amp;#39; object does not support item assignment t2 = (2,4) t3 = t1 + t2 print(t3) # Prints out: (1, 3, 5, 7, 9, 2, 4) 删除元组 t1 = (1,3,5,7,9) print(t1) # Prints out: (1, 3, 5, 7, 9) del t1 print(t1) # NameError: name &amp;#39;t1&amp;#39; is not defined 元组运算 # 计算元素个数 t1 = (1,3,5,7,9) print(len(t1)) # Prints out: 5 # 连接 t1 = (1,3,5,7,9) t2 = (2,4) print(t1 + t2) # Prints out: (1, 3, 5, 7, 9, 2, 4) # 复制 t1 = (2,4) print(t1 * 3) # Prints out: (2, 4, 2, 4, 2, 4) # 元素是否存在 t1 = (2,4) print(2 in t1) # Prints out: True # 遍历 t1 = (2,4) for x in t1: print(x) # 截取元素 t1 = (1,3,5,7,9) print(t1[1:]) # Prints out: (3, 5, 7, 9) 元组与列表 Python的元组与列表类似，不同之处在于元组的元素不能修改。</description>
    </item>
    
    <item>
      <title>Python基础：字典</title>
      <link>https://www.pengjielee.cn/post/python-basic-dict/</link>
      <pubDate>Fri, 06 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-dict/</guid>
      <description>创建字典 1、使用{}字面量
person = { &amp;#39;id&amp;#39;: 1, &amp;#39;name&amp;#39;: &amp;#39;peng&amp;#39;, &amp;#39;age&amp;#39;: 20, &amp;#39;address&amp;#39;: &amp;#39;Beijing&amp;#39; } print(person) # Prints out: {&amp;#39;id&amp;#39;: 1, &amp;#39;name&amp;#39;: &amp;#39;peng&amp;#39;, &amp;#39;age&amp;#39;: 20, &amp;#39;address&amp;#39;: &amp;#39;Beijing&amp;#39;} 2、使用内置函数dict
person = dict(id=1, name=&amp;#39;peng&amp;#39;, age=20, address=&amp;#39;Beijing&amp;#39;) print(person) # Prints out: {&amp;#39;id&amp;#39;: 1, &amp;#39;name&amp;#39;: &amp;#39;peng&amp;#39;, &amp;#39;age&amp;#39;: 20, &amp;#39;address&amp;#39;: &amp;#39;Beijing&amp;#39;} 3、用字典生成式语法创建字典
items3 = {x: x ** 3 for x in range(1, 6)} print(items3) # {1: 1, 2: 8, 3: 27, 4: 64, 5: 125} 访问字典的值 person = { &amp;#39;id&amp;#39;: 1, &amp;#39;name&amp;#39;: &amp;#39;peng&amp;#39;, &amp;#39;age&amp;#39;: 20, &amp;#39;address&amp;#39;: &amp;#39;Beijing&amp;#39; } print(person[&amp;#39;id&amp;#39;]) # Prints out: 1 print(person[&amp;#39;hobby&amp;#39;]) # KeyError: &amp;#39;hobby&amp;#39; # 使用get方法 print(person.</description>
    </item>
    
    <item>
      <title>Python基础：集合</title>
      <link>https://www.pengjielee.cn/post/python-basic-set/</link>
      <pubDate>Thu, 05 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-set/</guid>
      <description>集合特性 集合（set）是一个无序的不重复元素序列。
确定性。 互异性。 无序性。 创建集合 1、使用大括号 {} 创建
colors = { &amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;, &amp;#39;blue&amp;#39; } print(colors) # Prints out: {&amp;#39;green&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;blue&amp;#39;} numbers = { 1, 2, 3, 3, 4 } print(numbers) # Prints out: {1, 2, 3, 4} 2、使用 set() 函数创建
colors = set((&amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;, &amp;#39;blue&amp;#39;)) print(colors) # Prints out: {&amp;#39;green&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;blue&amp;#39;} numbers = set([1,2,3,3,4]) print(numbers) # Prints out: {1, 2, 3, 4} words = set(&amp;#39;python&amp;#39;) print(words) # Prints out: {&amp;#39;p&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;o&amp;#39;} 注意：创建一个空集合必须用 set() 而不是 {}，因为 {} 是用来创建一个空字典。</description>
    </item>
    
    <item>
      <title>Python基础：语句</title>
      <link>https://www.pengjielee.cn/post/python-basic-statement/</link>
      <pubDate>Wed, 04 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-statement/</guid>
      <description>if语句 1、if
print(&amp;#39;请输入用户名：&amp;#39;) name = input() if name == &amp;#39;peng&amp;#39;: print(&amp;#39;登录成功&amp;#39;) 2、if&amp;hellip;else
print(&amp;#39;请输入登录用户名：&amp;#39;) name = input() print(&amp;#39;请输入登录密码：&amp;#39;) password = input() if name == &amp;#39;admin&amp;#39; and password == &amp;#39;123456&amp;#39;: print(&amp;#39;登录成功!&amp;#39;) else: print(&amp;#39;用户名或密码错误!!!&amp;#39;) 3、if&amp;hellip;elif&amp;hellip;else
print(&amp;#39;请输入登录用户名：&amp;#39;) name = input() print(&amp;#39;请输入登录密码：&amp;#39;) password = input() if name == &amp;#39;admin&amp;#39; and password == &amp;#39;123456&amp;#39;: print(&amp;#39;admin登录成功!&amp;#39;) elif name == &amp;#39;peng&amp;#39; and password == &amp;#39;654321&amp;#39;: print(&amp;#39;peng登录成功!&amp;#39;) else: print(&amp;#39;用户名或密码错误!!!&amp;#39;) for-in语句 # Prints out: P,y,t,h,o,n for letter in &amp;#39;Python&amp;#39;: print(letter) # Prints out: red,green,blue for color in [&amp;#39;red&amp;#39;,&amp;#39;green&amp;#39;,&amp;#39;blue&amp;#39;]: print(color) # Prints out: 0:red,1:green,2:blue colors = [&amp;#39;red&amp;#39;,&amp;#39;green&amp;#39;,&amp;#39;blue&amp;#39;] for index in range(len(colors)): print(&amp;#39;%s:%s&amp;#39; % (index, colors[index])) # Prints out: 1,2,3,4 for number in range(1,5): print(number) # Prints out: 1,2,3,4 and then it prints &amp;#34;number value reached 4&amp;#34; for number in range(1,5): print(number) else: print(&amp;#34;number value reached %d&amp;#34; %(number)) while语句 # Prints out: 0,1,2,3,4,5,6,7,8 count = 0 while (count &amp;lt; 9): print(count) count = count + 1 break语句 # Prints out: P,y,t for letter in &amp;#39;Python&amp;#39;: if letter == &amp;#39;h&amp;#39;: break print(letter) # Prints out: 0,1,2,3,4 count = 0 while (count &amp;lt; 9): print(count) count = count + 1 if(count == 5): break continue语句 # Prints out: P,y,t,o,n for letter in &amp;#39;Python&amp;#39;: if letter == &amp;#39;h&amp;#39;: continue print(letter) # Prints out: 1,2,3,4,6,7,8,9 count = 0 while (count &amp;lt; 9): count = count + 1 if(count == 5): continue print(count) pass语句 pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。</description>
    </item>
    
    <item>
      <title>Python基础：列表</title>
      <link>https://www.pengjielee.cn/post/python-basic-list/</link>
      <pubDate>Tue, 03 Nov 2020 19:00:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-list/</guid>
      <description>创建列表 1、使用[]字面量
numbers = [1,3,5,7,9,10] print(numbers) # Prints out: [1, 3, 5, 7, 9, 10] 2、使用list()函数创建
numbrers = list((1,3,5,7,9,10)) print(numbers) # Prints out: [1, 3, 5, 7, 9, 10] str = list(&amp;#39;python&amp;#39;) print(str) # Prints out: [&amp;#39;p&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;n&amp;#39;] 访问列表 list1 = [&amp;#39;red&amp;#39;,&amp;#39;green&amp;#39;,&amp;#39;blue&amp;#39;] list2 = [1,3,5,7,9] print(list1[0]) # Prints out: red print(list2[1:5]) # Prints out: [3, 5, 7, 9] 更新列表 list1 = [&amp;#39;red&amp;#39;,&amp;#39;green&amp;#39;,&amp;#39;blue&amp;#39;] print(list1[0]) # Prints out: red list1[0] = &amp;#39;black&amp;#39; print(list1[0]) # Prints out: black 遍历列表 list1 = [&amp;#39;red&amp;#39;,&amp;#39;green&amp;#39;,&amp;#39;blue&amp;#39;] # Prints out: red green blue for item in list1: print(item) # Prints out: red green blue for index in range(len(list1)): print(list1[index]) 列表方法 list1 = [1,2,3,4] # 在尾部添加元素 list1.</description>
    </item>
    
    <item>
      <title>Python基础：字符串</title>
      <link>https://www.pengjielee.cn/post/python-basic-string/</link>
      <pubDate>Tue, 03 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-string/</guid>
      <description>创建字符串 使用单引号&amp;rsquo; &amp;rsquo; 或 双引号 &amp;quot; &amp;quot; 来创建字符串
str1 = &amp;#34;Jack&amp;#34; str2 = &amp;#39;Jim&amp;#39; 字符串操作 1、 字符串索引访问
message = &amp;#39;hello&amp;#39; print(message[0]) # Prints out: h print(message[1]) # Prints out: e print(message[-1]) # Prints out: o print(message[-2]) # Prints out: l print(message[5]) # IndexError: string index out of range 2、字符串拼接
last_name = &amp;#39;lee&amp;#39; first_name = &amp;#39;pengjie&amp;#39; full_name = first_name + &amp;#34; &amp;#34; + last_name print(full_name) # Prints out: pengjie lee 3、重复输出字符串</description>
    </item>
    
    <item>
      <title>Python基础：用户输入</title>
      <link>https://www.pengjielee.cn/post/python-basic-user-input/</link>
      <pubDate>Mon, 02 Nov 2020 19:00:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-user-input/</guid>
      <description>接受用户名问好 name = input(&amp;#39;Please enter your name: &amp;#39;) print(&amp;#39;Hello,&amp;#39; + name + &amp;#39;!&amp;#39;) 接受一个数值 age = input(&amp;#39;How old are you? &amp;#39;) if (age.isdigit()): if (int(age) &amp;gt; 18): print(&amp;#34;You&amp;#39;re not a kid anymore.&amp;#34;) else: print(&amp;#34;You&amp;#39;re just a kid.&amp;#34;) else: print(&amp;#39;Please enter a number.&amp;#39;) </description>
    </item>
    
    <item>
      <title>Python基础：输出Hello World</title>
      <link>https://www.pengjielee.cn/post/python-basic-hello-world/</link>
      <pubDate>Mon, 02 Nov 2020 19:00:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/python-basic-hello-world/</guid>
      <description>创建hello_world.py文件 print(&amp;#34;Hello World&amp;#34;) 运行 python3 hello_world.py # output: Hello World </description>
    </item>
    
    <item>
      <title>如何创建一个Node CLI工具</title>
      <link>https://www.pengjielee.cn/post/how-do-create-a-node-cli-tool/</link>
      <pubDate>Thu, 15 Oct 2020 17:08:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/how-do-create-a-node-cli-tool/</guid>
      <description>开始 我们的命令行工具起名xun-cli，实现功能有：
显示当前时间； 查询天气； 查看本地IP； 创建目录 $ mkdir xun-cli $ cd xun-cli $ npm init -y $ mkdir src $ cd src $ touch index.js 问好 1、index.js
#!/usr/bin/env node console.log(&amp;#34;hello xun-cli&amp;#34;) 2、执行
$ node src/index.js //output: hello xun-cli 输出一个漂亮的LOGO 1、安装依赖
$ npm install chalk #在命令行输出各种颜色的文字 $ npm install figlet #在命令行输出艺术字 2、index.js
#!/usr/bin/env node const chalk = require(&amp;#34;chalk&amp;#34;); const figlet = require(&amp;#34;figlet&amp;#34;); // 输出一个漂亮的LOGO console.log(chalk.yellow(figlet.textSync(&amp;#34;xun-CLI&amp;#34;, { horizontalLayout: &amp;#34;full&amp;#34; }))); 3、执行
$ node src/index.</description>
    </item>
    
    <item>
      <title>微信小程序中使用Sass</title>
      <link>https://www.pengjielee.cn/post/wechat-miniprogram-use-sass/</link>
      <pubDate>Fri, 09 Oct 2020 11:25:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/wechat-miniprogram-use-sass/</guid>
      <description>实现思路 使用脚本监听某个目录文件变化，把sass文件内容编译成wxss后缀的文件。
目录结构 --assets（存放静态资源目录） ----scss（存放scss源文件目录） ----wxss（存放编译后的wxss文件目录） scss源文件结构 1、变量文件_var.scss
$primary-color: #31373F; $secondary-color: #99A0AA; $third-color: #989FA9; $primary-font: 38rpx; 2、混合器文件_mixin.scss
@mixin center { display: flex; align-items: center; justify-content: center; } @mixin between { display: flex; align-items: center; justify-content: space-between; } 3、全局文件global.scss
@import &amp;#34;var&amp;#34;; @import &amp;#34;mixin&amp;#34;; .page { background: red; } 4、首页home.scss
@import &amp;#34;var&amp;#34;; @import &amp;#34;mixin&amp;#34;; .page-home { background: blue; } Nodejs监听sass文件 1、安装依赖
npm install -save-dev chokidar node-sass 2、watcher.js
const chokidar = require(&amp;#39;chokidar&amp;#39;); const sass = require(&amp;#39;node-sass&amp;#39;); const path = require(&amp;#39;path&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); //监听的文件 const watchFile = path.</description>
    </item>
    
    <item>
      <title>Git获取最新远程分支信息</title>
      <link>https://www.pengjielee.cn/post/git-gets-the-latest-remote-branch-information/</link>
      <pubDate>Wed, 23 Sep 2020 10:34:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/git-gets-the-latest-remote-branch-information/</guid>
      <description>问题：git pull后用git branch -a取不到最新分支信息。
查看远程分支信息，发现不是最新的 $ git pull origin branchname $ git branch -a 解决办法：执行下面命令即可 $ git fetch origin $ git remote prune origin //可以用这个命令清除无效分支 </description>
    </item>
    
    <item>
      <title>Weekly-20200828</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.08.28/</link>
      <pubDate>Fri, 28 Aug 2020 14:14:47 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.08.28/</guid>
      <description>CDN 如何部署 CDN 网络
https://cloud.tencent.com/developer/article/1358553
已经部署的程序，如何正确的加上CDN
https://segmentfault.com/q/1010000004629138
程序员都应了解的 CDN 是什么？
https://mp.weixin.qq.com/s/XxGQ4431yOfpkK759EuBHw
React 通过几个例子来理解 React 的事件系统
https://mp.weixin.qq.com/s/NLJlcdhMcPPgrS8KrnmQ9A
Reactjs里面如何判断页面滚动到底部
http://react-china.org/t/reactjs/6822/2
React 开发 GitHub 文件搜索
https://mp.weixin.qq.com/s/zVwQDw1hjyv9oGgAY4ZcWw
Electron 如何基于 Electron 开发跨终端的应用
https://mp.weixin.qq.com/s/1U9hL6ar54e1aB4LJss0tg
Electron 和当下其他的桌面开发方法相比如何？
https://www.zhihu.com/question/264999651?sort=created
用Electron开发桌面应用
http://get.ftqq.com/7870.get
Awesome Electron
https://github.com/sindresorhus/awesome-electron
23 Best Electron Apps (2020 Edition)
https://www.omgubuntu.co.uk/2019/02/best-electron-apps
Electron Forge
https://github.com/electron-userland/electron-forge
Menubar
https://github.com/maxogden/menubar
electron 监听U盘插拔事件,并获得U盘路径 - clgGlobal - 博客园
https://www.cnblogs.com/caolonggang/p/13178158.html
Electron中require报错的解决与分析 - zion03 - 博客园
https://www.cnblogs.com/cdyang/p/electron-require-error.html
electron中JS报错：require is not defined的问题解决方法
https://blog.csdn.net/u012442504/article/details/98875496
发布 手把手教你搭建一个灰度发布环境
https://mp.weixin.qq.com/s/iNbXwJr7K2OxzU9IIHNEUQ
从0到1，Vue大牛的前端搭建——异常监控系统</description>
    </item>
    
    <item>
      <title>Weekly-20200821</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.08.21/</link>
      <pubDate>Fri, 21 Aug 2020 14:14:39 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.08.21/</guid>
      <description>技术 浅谈3种css技巧——两端对齐
http://www.divcss5.com/jiqiao/j50659.shtml
相见恨晚的 Mac 技巧（二十八）
https://mp.weixin.qq.com/s?__biz=MzAxNzcwMTA4Ng==&amp;amp;mid=2247487752&amp;amp;idx=1&amp;amp;sn=681c9a53ff39fd9782a80b937d6851bd&amp;amp;chksm=9be0d0b9ac9759af962b5f4388d6765d0ed3459ae430844bbcb3d143d968849d880f6cd0fea3&amp;amp;scene=21#wechat_redirect
有什么让你相见恨晚的 MacBook 神器？
https://www.zhihu.com/question/41049134/answer/549975533
一步一步，开始上手Mac 开发（一）
https://www.jianshu.com/p/feadeb1ae7ae
国内为什么写不出操作系统和编程语言？
https://mp.weixin.qq.com/s/hd6pyux3zdUeHGP0Pbh6wA</description>
    </item>
    
    <item>
      <title>Weekly-20200814</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.08.14/</link>
      <pubDate>Fri, 14 Aug 2020 14:14:33 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.08.14/</guid>
      <description>技术 在react中使用防抖以及节流函数_smz8023的博客-CSDN博客_react中使用防抖函数
https://blog.csdn.net/smz8023/article/details/103428483
微信小程序封装wx.request方法 - 日暮途远i - 博客园
https://www.cnblogs.com/rmty/p/10905859.html
6种移动端 1px 解决方案(完整版)
https://mp.weixin.qq.com/s/V9Kohm5aNppkHE38TYmRnQ
前端异常监控解决方案研究
https://mp.weixin.qq.com/s/ZQ-gSPy6lTSaiF393YZfAQ
20个 CSS 快速提升技巧
https://mp.weixin.qq.com/s/YkDccxhVwPdOmmi44V7Heg
一行 CSS 为网页添加暗黑模式支持
https://mp.weixin.qq.com/s/mEHbfBiSD-Ube3SggWEUMA
ES6展开运算符（扩展运算符）
https://juejin.im/post/6844903585960951815
使用 react-docgen 自动生成组件文档
https://mp.weixin.qq.com/s/gLKiyRwkRKVdZMzTBmBcVg
前端常用的15个linux命令
https://mp.weixin.qq.com/s/8CQCG7mEcWy6oFxiePeQRg</description>
    </item>
    
    <item>
      <title>Weekly-20200807</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.08.07/</link>
      <pubDate>Fri, 07 Aug 2020 14:14:25 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.08.07/</guid>
      <description>CSS 10个前端开发人员必须知道的CSS框架
https://mp.weixin.qq.com/s/T2qZ4YrVuwZ_3xTlis3Jow
React React Hooks踩坑分享
https://mp.weixin.qq.com/s/w9XhwjF3F6oJBUdD1rp2BQ
用React Hooks做一个搜索栏
https://mp.weixin.qq.com/s/Jv-jByVRPWUCfOdj1q00Bg
我读完了React的API，并为新手送上了一些建议
https://mp.weixin.qq.com/s/OXx_Pb3QXs6uPg6V3ZYJsQ
前端，react，动画
https://tech.youzan.com/react-animations/
Implementing Infinite Scroll And Image Lazy Loading In React
https://www.smashingmagazine.com/2020/03/infinite-scroll-lazy-image-loading-react/
编程技巧 15个简单的JS编码标准让你的代码更整洁
https://mp.weixin.qq.com/s/3KR1AYsTfXPWvDO_FMgMXQ
15年程序员经验分享：40个改变你编程技能的小技巧！
https://mp.weixin.qq.com/s/QbYXuvjdG1znFaE3d2HSow
可能是目前最详细从零开始配置 TypeScript 项目的教程
https://mp.weixin.qq.com/s/PVr6Pjuf8Bm69xTLuqLxkw
Python 非常有用的 Python 技巧
https://mp.weixin.qq.com/s/hdV4aQUDdMyIWvNorbzXcA
这些Python库虽然冷门，但功能真的很强大！
https://mp.weixin.qq.com/s/RKJQbDDYbVFnpyR3Y5BKbw
这些自动化场景，批处理脚本完全可以取代 Python！
https://mp.weixin.qq.com/s/WEC58p7AZdmzosvKhP_0fw
用 Python 写个消消乐小游戏
https://mp.weixin.qq.com/s/3YTq7rRB9WEGya7pZ_nJ-Q
微信小程序 如何在微信小程序中使用sass
https://www.dazhuanlan.com/2020/01/06/5e1299e987cc4/ https://segmentfault.com/a/1190000015807708
微信小程序封装wx.request方法
https://www.cnblogs.com/rmty/p/10905859.html
微信小程序，封装axios请求数据_WhyBecause的博客-CSDN博客_小程序使用axios
https://blog.csdn.net/qq_41287423/article/details/93668025?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;amp;depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase
Other 前端 - Page 2 - 有赞技术团队
https://tech.youzan.com/tag/front-end/page/2/
yapi
https://github.com/ymfe/yapi
数据解构
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring
rel=noopener
https://mathiasbynens.github.io/rel-noopener/#hax
node_modules 困境</description>
    </item>
    
    <item>
      <title>Weekly-20200731</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.07.31/</link>
      <pubDate>Fri, 31 Jul 2020 14:13:56 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.07.31/</guid>
      <description>CSS css处理文字不换行、换行截断、溢出省略号
https://www.cnblogs.com/nanyang520/p/11358623.html
一行 CSS 代码搞定响应式布局
https://mp.weixin.qq.com/s/Wc8BgdCGB7e5k-zASQxtHQ
可能是最全的 “文本溢出截断省略” 方案合集
https://mp.weixin.qq.com/s/HhSdZ1RBSRZt9I84qZj6oA
14条 Scss 缩减50%样式代码的实战经验总结
https://mp.weixin.qq.com/s/bwku4EINn591j0avhqzXQQ
生成Mock数据 chancejs
https://chancejs.com/web/tld.html
faker.js
https://github.com/Marak/faker.js
Intersection_Observer_API MDN
https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
IntersectionObserver API 使用教程
http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html
Intersection Observer: Track Elements Scrolling Into View
https://webdesign.tutsplus.com/tutorials/how-to-intersection-observer--cms-30250
骨架屏 如何让你的网页“看起来”展现地更快 —— 骨架屏二三事
https://mp.weixin.qq.com/s/aTeojlmlb1S3QSPV-PL2Sg
前端骨架屏都是如何生成的
https://mp.weixin.qq.com/s/ABUFDk5SB1D9CqpLly51tg
一种自动化生成骨架屏的方案
https://mp.weixin.qq.com/s/LPU9_mkLP134EBVrSg6mVg
React Hook React hook 10种 Hook （详细介绍及使用)
https://juejin.im/post/6844903989696282631
一个很有意思的hook库：react-hanger
https://mp.weixin.qq.com/s/i6pQu4-_AgCUKpfyc7VI3g
源码解析React Hook构建过程：没有设计就是最好的设计
https://mp.weixin.qq.com/s/968ukIjEhhEOeLD5SQoKaw
React Hook源码解析（一）
https://mp.weixin.qq.com/s/qXaeSV1PC-ekftJ9AvyKyg
简化React Hook的5种方法
https://mp.weixin.qq.com/s/5NnQgk8LgIU5F9WY7pONvQ
【译】使用React Hook加载图片
https://mp.weixin.qq.com/s/ZuYGJDLNTYK_LP4eI8BIBg
10个案例让你彻底理解React hooks的渲染逻辑
https://mp.weixin.qq.com/s/t3sBaKXIb023t3pTpdBCtg
React 使用React实现无限滚动和图像懒加载</description>
    </item>
    
    <item>
      <title>Weekly-20200724</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.07.24/</link>
      <pubDate>Fri, 24 Jul 2020 14:13:31 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.07.24/</guid>
      <description>2020.07.20 git回退单个文件到指定版本
https://www.jianshu.com/p/37dd49e59e87
git回滚部分文件到某个版本
https://www.cnblogs.com/acm-bingzi/p/gitCheckout.html
手机端css实现横向滚动但不显示滚动条
https://blog.csdn.net/zuoyiran520081/article/details/88413969
高斯滤镜模糊CSS3
https://www.cnblogs.com/zhp404/articles/4168262.html
line-clampin
https://css-tricks.com/line-clampin/
2020.07.21 Why I Stopped Using Redux https://dev.to/g_abud/why-i-quit-redux-1knl
react query docs
https://react-query.tanstack.com/docs/overview https://react-query.tanstack.com/docs/comparison
2020.07.22 What is React Query?
https://www.leniolabs.com/software/development/2020/07/14/react-query.html
CSS实现单行、多行文本溢出显示省略号
https://www.cnblogs.com/gopark/p/8875655.html
2020.07.24 React context
https://react.docschina.org/docs/context.html
Redux started
https://redux.js.org/introduction/getting-started
Need Redux?
https://redux.js.org/faq/general#when-should-i-use-redux
you-might-not-need-redux
https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367
idiomatic-redux-tao-of-redux-part
https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/
https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/</description>
    </item>
    
    <item>
      <title>Weekly-20200717</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.07.17/</link>
      <pubDate>Fri, 17 Jul 2020 14:13:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.07.17/</guid>
      <description>2020.07.13 1、Vue vs React:
关于Vue和React的一些对比及个人思考（上）
https://juejin.im/post/5e153e096fb9a048297390c1
对比其他框架
https://cn.vuejs.org/v2/guide/comparison.html
React VS Vue：谁会成为2020年的冠军？
https://zhuanlan.zhihu.com/p/89416436
React还是Vue：选哪个？
https://mp.weixin.qq.com/s/IIz7WAuPTqjPRMgAybO1fg
React与Vue的抉择
https://mp.weixin.qq.com/s/WLagtOEbmbm5v0Vduc6btA
React还是Vue？
https://segmentfault.com/a/1190000009268926
react VS vue 我们究竟该如何选择(从项目的角度帮你分析)
https://www.cnblogs.com/pengfei-nie/p/9087844.html
angular-vs-vue-vs-react
https://www.codeinwp.com/blog/angular-vs-vue-vs-react/
survey2020
https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-web-frameworks-loved2
vue-vs-react-2020
https://www.monterail.com/blog/vue-vs-react-2020
你觉得 Vue 好在哪里，我们为什么要用它换掉现在的框架呢？
这时候，很多同学的第一反应可能是这样的：
Vue 性能很优秀！
Vue 体积很小巧！
Vue 开发很方便！
Vue 代码很优雅！
对于切换一种新技术栈，很容易想到这些问题：
怎样处理老项目的技术债？
怎样确定新框架支撑得起复杂项目？
怎样沉淀并推广最佳实践？
怎样培训团队，是否方便后续招人？
2、重复造轮子
不要重复造轮子？
https://mp.weixin.qq.com/s/-ON19-0PmdpxfY44hTN40w
到底要不要重复造轮子?
https://mp.weixin.qq.com/s/ahHO38Qky40uFkahJi5aew
互联网行业流行一句话叫“不要重复造轮子”，那么核心技术的轮子要不要重新造呢？
https://mp.weixin.qq.com/s/fqgNIyC4yNWZHhfc2cWSRg
关于不要重复造轮子的二三事
https://mp.weixin.qq.com/s/RFP-u3i0ripw4FLhzrkMuA
3、Typescript
TypeScript被吹过头了？
https://mp.weixin.qq.com/s/U7Mgks8vx0RCL26dLuLBFA
TypeScript被吹过头了？
https://mp.weixin.qq.com/s/Wkxz3m0_2CYVP5_vC_PA3A
技术周刊 · 为什么你还不使用 TypeScript
https://mp.weixin.qq.com/s/T_B8rwVgxJNC98lBNq-JWQ
JavaScript 败北，TypeScript 大势所趋？*
https://mp.weixin.qq.com/s/KE-FWfU7NdJS6fI6mkDlwA
技术选型：没有谷歌的命，得了谷歌的病</description>
    </item>
    
    <item>
      <title>Weekly-20200710</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.07.10/</link>
      <pubDate>Fri, 10 Jul 2020 14:13:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.07.10/</guid>
      <description>2020.07.06 1、前端如何快速的搞懂公司/部门的业务模型？
https://www.zhihu.com/question/309488771/answer/1312341416
2、前端p6什么水平？如何衡量？
https://www.zhihu.com/question/61281984/answer/1306626251
3、git commit message提交规范
Commit message 和 Change log 编写指南 http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html
你可能会忽略的 Git 提交规范
https://juejin.im/entry/5b429be75188251ac85830ff
优雅的提交你的 Git Commit Message
https://juejin.im/post/5afc5242f265da0b7f44bee4
Cz工具集使用介绍 - 规范Git提交说明
https://juejin.im/post/5cc4694a6fb9a03238106eb9
commitizen
https://github.com/commitizen/cz-cli
commitlint
https://github.com/conventional-changelog/commitlint
4、原生微信小程序配置ESlint总结
https://zhuanlan.zhihu.com/p/84283104
5、使用husky创建git hooks时，hook没有执行的情况 https://blog.csdn.net/qq_43048784/article/details/105241872
6、微信小程序UI组件库合集 https://developers.weixin.qq.com/community/develop/article/doc/000ecc775a86807f7ba9b7dc956c13
7、weui-miniprogram
https://github.com/wechat-miniprogram/weui-miniprogram
2020.07.07 1、wx.request 经 Promise 封装后，如何拿到requestTask https://developers.weixin.qq.com/community/develop/doc/00064cc26bc058a6a848f238351c00
2、我的开发之路系列 - 微信开发指南
https://www.kancloud.cn/xiaoyulive/wechat/524892
2020.07.08 微信小程序获取用户手机号，利用云开发云函数拿到session_key https://www.jianshu.com/p/9651cc121afe
微信小程序获取用户手机号，利用云开发云函数拿到用户手机号 https://blog.csdn.net/HZmcl/article/details/105978268
Mac下安装WordPress
https://www.jianshu.com/p/4134fece6cc9
2020.07.09 Mac效率神器-Alfred以及使用的一些奇技淫巧
https://www.jianshu.com/p/1efc688d6095
修改最后一次提交
https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2
[前端采坑]lint-staged就是匹配不到文件
https://zhuanlan.zhihu.com/p/102104085
我为什么推荐Prettier来统一代码风格
https://zhuanlan.zhihu.com/p/30442913
stylelint
https://stylelint.io/user-guide/rules/unit-whitelist
https://www.cnblogs.com/jiaoshou/p/11284204.html</description>
    </item>
    
    <item>
      <title>Weekly-20200703</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.07.03/</link>
      <pubDate>Fri, 03 Jul 2020 14:11:26 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.07.03/</guid>
      <description>摘录 1、
什么叫作风雨，风雨就是一个人无论出身寒门还是富裕之家，虽然无从选择自己的出身，却可以选择自己未来可以成为什么样的人。一路走来，所经历的那点事儿就叫风雨。
2、
What-How-Why(3W)
What - 了解完这个东西是什么？
How - 再了解这个东西它是怎么使用的？
Why - 最终再去了解原理
3、
5W+1H：是对选定的项目、工序或操作，都要从
原因（何因Why）、
对象（何事What）、
地点（何地Where）、
时间（何时When）、
人员（何人Who）、
方法（何法How）等六个方面提出问题进行思考。
来源：5W1H分析法
技术 1、Python字典
https://www.runoob.com/python/python-dictionary.html
https://github.com/jackfrued/Python-Core-50-Courses/blob/master/%E7%AC%AC015%E8%AF%BE%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8.md
2、Typescript入门
https://www.typescriptlang.org/index.html
3、snowpack
https://github.com/pikapkg/snowpack
4、查看git配置的用户名和邮箱
$ git config user.name $ git config user.email or $ cd ~ $ cat .gitconfig 5、多端开发
Taro
https://github.com/NervJS/taro
https://juejin.im/entry/5b19155bf265da6e083be667
https://mp.weixin.qq.com/s?__biz=MzIxMzExMjYwOQ%3D%3D&amp;amp;mid=2651890991&amp;amp;idx=1&amp;amp;sn=6dcf81fd2639bc20d7245990a30fefd0&amp;amp;scene=45#wechat_redirect
mpvue
https://github.com/Meituan-Dianping/mpvue
6、uni-app官网
https://uniapp.dcloud.io/README
7、深入测试一周，主流多端框架大比武（uni-app团队）
https://mp.weixin.qq.com/s/jIDEHfuMnED6HTfNgjsW4w
8、小程序端框架全面测评（taro团队）
https://aotu.io/notes/2019/03/12/mini-program-framework-full-review/
9、各框架star数，截止2020.07.02
uni-app,23k
https://github.com/dcloudio/uni-app
taro,25.9k
https://github.com/NervJS/taro
mpvue,19.9k
https://github.com/Meituan-Dianping/mpvue
wepy,20.4k
https://github.com/Tencent/wepy
chameleon,7.6k</description>
    </item>
    
    <item>
      <title>Weekly-20200626</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.06.26/</link>
      <pubDate>Fri, 26 Jun 2020 16:06:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.06.26/</guid>
      <description>2020.06.22 1、VPN技术
https://zhuanlan.zhihu.com/p/112797914
2、MAC VPN连接，L2TP需要共享密钥的问题
http://www.0x55aa.com/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/1769.html
sudo vim /etc/ppp/options 内容： plugin L2TP.ppp l2tpnoipsec 3、C++实现的任天堂红白机模拟器 （https://github.com/amhndu/SimpleNES） https://www.zhihu.com/question/28341521/answer/1182970959
4、 C++ 简介
https://www.w3cschool.cn/cpp/cpp-intro.html
5、WTF is JSX
https://jasonformat.com/wtf-is-jsx/
6、build-your-own-x
https://github.com/danistefanovic/build-your-own-x
7、snake
https://www.freecodecamp.org/news/think-like-a-programmer-how-to-build-snake-using-only-javascript-html-and-css-7b1479c3339e/
8、无论为谁打工，都不要忘记提升自己。
9、怎么学C语言?
https://www.zhihu.com/question/337800410/answer/770024881
2020.06.24 1、回溯算法
https://leetcode-cn.com/tag/backtracking/
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。
许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。
2、怎么自学python，大概要多久？
https://www.zhihu.com/question/300985609/answer/1293193482
3、Python 人脸识别库
https://github.com/ageitgey/face_recognition
4、Python 中文分词组件
https://github.com/fxsjy/jieba https://github.com/isnowfy/snownlp</description>
    </item>
    
    <item>
      <title>Weekly-20200619</title>
      <link>https://www.pengjielee.cn/post/weekly/weekly-2020.06.19/</link>
      <pubDate>Fri, 19 Jun 2020 16:06:30 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/post/weekly/weekly-2020.06.19/</guid>
      <description>2020.06.15 1、从“懂管理的IT人”，到“懂IT的管理者”
https://mp.weixin.qq.com/s/sj9z5nwKytD8eOquOiwORA
“懂IT的管理者”和“懂管理的IT人”，到底有什么区别？
对“懂管理的IT人”来说，管理只是拱卫IT的能力之一，补齐短板所需，他考虑的坐标系仍然是IT，许多从IT出身的领导都是这样。 对“懂IT的管理者”而言，IT只是众多技能中的一项，无甚稀奇，他考虑和决策的标准是生意，是通盘的管理。
沟通交流的目的，绝不是需要草草敷衍，然后可以让自己醉心编码，而是保证自己的信息灵通，协作顺畅。这一切都搞定之后才轮到处理具体事务，IT只是诸多“具体事务”中的一项而已。
要想明白，绝大多数公司都不是科研机构，而是基于利益的组织。在这种组织里，整齐有序、逻辑顺畅、善于学习等等，作为自己的追求很好，但未必是唯一的工作方式，甚至不是所有人都认可的工作方式。
比较可取的办法是先着眼于目的，摸索出各方的最大公约数。
你们把系统做好，公司当然喜欢，但更重要的是，你们应当从价值链的角度出发，找到自己的定位。
什么意思？IT虽然很强大，可以大大提升效率，但公司是追求利润的组织，利润是由各个部门、各个团队一起贡献的，换句话说，大家形成了一条价值链。更微妙的是，价值链上谁重要谁不重要，谁更灿烂谁更黯淡，往往并没有客观的标准，而是根据大家的印象来作出判断。
所谓“价值链”，其实也没有那么玄乎，一般来说，主要包含两大因素：人事、财务。无论在哪家公司，这两大因素基本都是不变的，剩下的只是你如何从这两个角度展开，看待和证明自己的价值。
什么是技术的焦虑感？就是面对层出不穷的新技术，永远在学习，永远在追赶，永远担心被拉下的忧虑。
为什么“懂IT的管理人”可以摆脱这种焦虑？因为相比技术的更新速度，生意和组织的更新速度要慢得多。实际上，如果我们把目光从头部的那几家“技术弄潮儿”移开，就会发现很难有公司一直引领技术潮流，甚至大部分公司（恰恰是它们解决了大部分IT就业）根本不需要那么高精尖的技术，它们更需要的是用合适的技术去解决自己生意中的具体问题。
所谓“合适的技术”，并不是把最新技术降几级就可以直接得到。这个“合适”，需要你懂得取舍，需要你懂得与人交流协作，需要你找到共同认可的工作方式，需要你看得到整条价值链，找得到自己的定位。然后就会有越来越多的人愿意承认，你是能让他们放心解决IT问题的人。
2、从头实现一个koa框架
https://zhuanlan.zhihu.com/p/35040744
3、认知的九个层级，你在哪一层？
https://mp.weixin.qq.com/s/PjgclXWoBWppI3rVLussyQ
什么叫智商？什么又叫认知？ 智商，是一个人的智力商数。认知，是对自己智商的运用。
辗压智商的第一种力量，是压根就没智商，这是认知的最低层，是庞雄。不肯动脑子的人，死先。 第二种力量，是时运，立于风口，盆满钵满，是袁农。比认知和努力更强大的，是时运。时运是世间最强大的力量。 第三种力量，是贫穷，这是马小五。贫穷压制智商，让你失去机会。 第四种力量，是过低的社会地位，怎么选择都是错，这是宫庶。社会地位过低，就没得挑选，怎么选择都是错。 第五种力量，是所面对的局超过人力控制，这是高占龙。再大的饼，也大不过锅。再高的智商，也高不过更大的局。 第六种力量，是大环境，形势比人强，这是田湖。智商靠不住，形势比人强。 第七种力量，是命运，是智商顶尖的女主韩冰。最强大的，始终是命运，如果不了解对方，所有的付出，终归失其意义。
(1) 微笑第一。从来不发火，始终不动怒。生气是用别人的错误，惩罚自己。发火动怒，更是无端伤害自己。 (2) 担当第二。 (3) 专注第三。专注于业务。 (4) 隐忍第四。认真不得，生气不得，马虎不得。对人宽，对事严。 (5) 狠辣第五。惹我你就死定了。
认知第九层，也就是最高的认知，是人间真情，是对家人的爱，是对朋友的义，是对爱人的恋。 只有回归于亲情友情与爱情，我们才会与世界和解，找回自己，归于快乐。
4、村上春树 我告诉你我喜欢你 并不是一定要和你在一起 只是希望今后的你 在遭遇人生低谷的时候 不要灰心 至少曾经有人被你的魅力所吸引 曾经是，以后也会是
5、剪绳子
https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&amp;amp;f=discussion
6、剑指offer
https://www.nowcoder.com/ta/coding-interviews
2020.06.16 1、 learn Python
https://www.learnpython.org/en/Welcome
2、 30分钟精通React Hooks
https://juejin.im/post/5be3ea136fb9a049f9121014
3、 React 16 加载性能优化指南
https://juejin.im/post/5b506ae0e51d45191a0d4ec9
2020.06.17 React面试题
https://juejin.im/post/5d5f44dae51d4561df7805b4
https://juejin.im/post/5c989ea76fb9a070ad504cd8 https://juejin.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/webpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/webpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/</guid>
      <description>准备 $ mkdir webpack-multi-page-demo $ cd webpack-multi-page-demo $ mkdir src $ npm init -y 安装依赖 $ npm install webpack webpack-cli html-webpack-plugin --save-dev 创建多个页面js $ touch home.js //home.js export default function index() { return &amp;#39;Home Page&amp;#39;; } document.getElementById(&amp;#39;app&amp;#39;).innerHTML = index(); $ touch blog.js //blog.js export default function index() { return &amp;#39;Blog Page&amp;#39;; } document.getElementById(&amp;#39;app&amp;#39;).innerHTML = index(); $ touch about.js //about.js export default function index() { return &amp;#39;About Page&amp;#39;; } document.getElementById(&amp;#39;app&amp;#39;).innerHTML = index(); $ touch template.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8html5-web-worker%E8%AE%A1%E7%AE%97%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8html5-web-worker%E8%AE%A1%E7%AE%97%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>未使用Web Worker计算斐波那契数列 计算较小数时，浏览器还可以快速响应； 计算大数时，浏览器的UI已经不可以操作了； 刷新一下页面，发现浏览器仍然处于卡死状态； 使用Web Worker计算斐波那契数列 1、创建项目
$ mkdir webworker-demo $ cd webworker-demo $ touch index.html main.js worker.js 2、index.html
&amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;计算斐波那契数列（使用Web Worker）&amp;lt;/title&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;计算斐波那契数列（使用Web Worker）&amp;lt;/h3&amp;gt; &amp;lt;div class=&amp;#34;inner&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;number&amp;#34; id=&amp;#34;number&amp;#34; /&amp;gt; &amp;lt;button id=&amp;#34;calc&amp;#34;&amp;gt;calculate&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script src=&amp;#34;main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; 3、main.js
const resultEle = document.querySelector(&amp;#39;#result&amp;#39;); // 判断是否支持Worker if(window.Worker){ // 创建Worker const myWorker = new Worker(&amp;#34;worker.js&amp;#34;); // 监听消息 myWorker.onmessage = e =&amp;gt; { const result = e.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%B8%80%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%B8%80%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/</guid>
      <description>1、创建项目目录
mkdir my-expressjs-api &amp;amp;&amp;amp; cd my-expressjs-api 2、初始化package.json文件
npm init -y 3、安装express
npm install express --save 4、创建src/server.js
const express = require(&amp;#34;express&amp;#34;); const app = express(); const port = 3000; app.get(&amp;#34;/&amp;#34;, (req, res) =&amp;gt; { res.send(&amp;#34;Hello World!&amp;#34;); }); app.listen(port, () =&amp;gt; { console.log(`My app listening at http://localhost:${port}`); }); 5、更新package.json
{ ... &amp;#34;scripts&amp;#34;: { &amp;#34;dev&amp;#34;: &amp;#34;node src/server.js&amp;#34; }, ... } 6、运行项目
npm run dev 输出：
&amp;gt; node src/server.js My app listening at http://localhost:3000 访问浏览器http://localhost:3000，页面返回 Hello World!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%B8%83%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%B8%83%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/</guid>
      <description>实现注册 1、安装依赖
npm install blueimp-md5 bcrypt 2、修改src/routes/user.js
const express = require(&amp;#39;express&amp;#39;); const { header, body } = require(&amp;#39;express-validator&amp;#39;); const router = express.Router(); const Controller = require(&amp;#39;../controllers/user&amp;#39;); router.post( &amp;#39;/register&amp;#39;, body(&amp;#39;username&amp;#39;).isLength({ min: 2 }).withMessage(&amp;#39;用户名最小长度为2&amp;#39;), body(&amp;#39;password&amp;#39;).isLength({ min: 6 }).withMessage(&amp;#39;密码最小长度为6&amp;#39;), Controller.register ); 3、修改src/controllers/user.js
const jwt = require(&amp;#34;jsonwebtoken&amp;#34;); const bcrypt = require(&amp;#34;bcrypt&amp;#34;); const md5 = require(&amp;#34;blueimp-md5&amp;#34;); const { validationResult } = require(&amp;#34;express-validator&amp;#34;); const User = require(&amp;#34;../models/user&amp;#34;); const config = require(&amp;#34;../config&amp;#34;); exports.register = async (req, res, next) =&amp;gt; { //检查提交参数 const errors = validationResult(req); if (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%B8%89%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%B8%89%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
      <description>1、定义项目结构
src /controllers /user.js /middlewares /models /user.js /routes /user.js /config.js /server.js 2、定义Model
src/models/user.js
const mongoose = require(&amp;#39;mongoose&amp;#39;); const Schema = mongoose.Schema; const modelSchema = new Schema( { username: String, email: String, password: String, create_date: { type: Date, default: Date.now }, update_date: { type: Date, default: Date.now }, }, { timestamps: { createdAt: &amp;#39;create_date&amp;#39;, updatedAt: &amp;#39;update_date&amp;#39; } } ); module.exports = db.model(&amp;#39;User&amp;#39;, modelSchema); 3、定义Controller
src/controllers/user.js
const Model = require(&amp;#39;../models/user&amp;#39;); //获取用户列表 exports.list = async (req, res, next) =&amp;gt; { let { page = 1, size = 10 } = req.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%B9%9D%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%B9%9D%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>1、安装依赖
npm install chai chai-http mocha nyc --save-dev 2、更新package.json
&amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;nyc -a mocha --recursive&amp;#34;, }, 3、创建test目录
mkdir test/test.js 目录结构： /app --/src --/test ----test.js	--package.json 4、更新src/server.js
const express = require(&amp;#39;express&amp;#39;); const app = express(); app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; { res.status(200).send(&amp;#39;Hello World!&amp;#39;); }); app.get(&amp;#39;/hello&amp;#39;, (req, res) =&amp;gt; { res.status(200).send(&amp;#39;Hello World!&amp;#39;); }); //404错误处理 app.use(function (req, res, next) { res.status(404).send(&amp;#39;Not Found&amp;#39;); }); module.exports = app.listen(port, () =&amp;gt; { console.log(`My app listening at http://localhost:${port}`); }); 5、更新test/test.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%BA%8C%E8%BF%9E%E6%8E%A5mongodb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%BA%8C%E8%BF%9E%E6%8E%A5mongodb/</guid>
      <description>1、操作mongodb
# 创建数据库 $ use testdb; switched to db testdb # 查看数据库，刚刚创建的并未显示 $ show dbs; admin 0.000GB config 0.000GB local 0.000GB # 插入一条记录 $ db.testdb.insert({&amp;#34;name&amp;#34;:&amp;#34;testdb&amp;#34;}) WriteResult({ &amp;#34;nInserted&amp;#34; : 1 }) # 再次查看数据库 $ show dbs; admin 0.000GB config 0.000GB local 0.000GB testdb 0.000GB # 创建集合 $ db.createCollection(&amp;#34;users&amp;#34;) { &amp;#34;ok&amp;#34; : 1 } # 往集合中插入一条记录 $ db.users.insert({&amp;#34;name&amp;#34; : &amp;#34;admin&amp;#34;}) WriteResult({ &amp;#34;nInserted&amp;#34; : 1 }) # 查看集合 $ show tables; //or show collections; # 查看集合中的数据	$ db.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%BA%94%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%89%B4%E6%9D%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E4%BA%94%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%89%B4%E6%9D%83/</guid>
      <description>1、添加授权中间件
src/middlewares/auth.js
const passport = require(&amp;#39;passport&amp;#39;); const auth = (req, res, next) =&amp;gt; { passport.authenticate(&amp;#39;jwt&amp;#39;, function (err, user, info) { if (err) { return next(err); } if (user) { req.user = user; return next(); } else { return res.status(401).json({ status: 0, message: &amp;#39;需要授权&amp;#39; }); } })(req, res, next); }; module.exports = { auth: auth, }; 2、使用中间件
修改 src/routes/user.js
const middleware = require(&amp;#39;../middlewares/auth&amp;#39;); router.post(&amp;#39;/profile&amp;#39;, middleware.auth, Controller.profile); 修改 src/controllers/user.js
exports.profile = (req, res) =&amp;gt; { res.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E5%85%AB%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E5%85%AB%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>1、处理404
在Express里404不被认为是出错的结果，我们要做的只是在代码底部加一个中间件去处理没有返回的情况，并且手动返回一个404
app.use(function(req, res, next){ res.status(404).send(&amp;#39;Not Found&amp;#39;); }); 2、全局异常错误
定义错误处理的中间件跟定义普通的中间件没有什么区别，仅仅是参数必须定义为4个，它们定义如下 (err, req, res, next)
//添加全局错误处理 app.use(function (err, req, res, next) { console.error(err.stack); return res.status(500).json({ status: 500, message: &amp;#39;内部错误&amp;#39; }); }); 3、注意位置
//404错误处理 app.use(function (req, res, next) { res.status(404).send(&amp;#39;Not Found&amp;#39;); }); //添加全局错误处理 app.use(function (err, req, res, next) { return res.status(500).json({ status: 500, message: &amp;#39;内部错误&amp;#39; }); }); module.exports = app.listen(port, () =&amp;gt; { console.log(`My app listening at http://localhost:${port}`); }); </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E5%85%AD%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E5%85%AD%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</guid>
      <description>1、安装express-validator
npm install express-validator 2、修改src/routes/user.js
const express = require(&amp;#34;express&amp;#34;); const { header, body } = require(&amp;#34;express-validator&amp;#34;); const router = express.Router(); const Controller = require(&amp;#39;../controllers/user&amp;#39;); // 修改密码 router.post( &amp;#34;/changepwd&amp;#34;, header(&amp;#34;Authorization&amp;#34;).exists(), Controller.changePwd ); router.post( &amp;#34;/register&amp;#34;, body(&amp;#34;username&amp;#34;) .isLength({ min: 5 }) .withMessage(&amp;#34;用户名最小长度为5&amp;#34;), body(&amp;#34;password&amp;#34;) .isLength({ min: 6 }) .withMessage(&amp;#34;密码最小长度为6&amp;#34;), Controller.register ); module.exports = router; 3、修改src/controllers/user.js
const { validationResult } = require(&amp;#34;express-validator&amp;#34;); exports.changePwd = async (req, res, next) =&amp;gt; { const errors = validationResult(req); if (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E5%9B%9B%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/fe/%E4%BD%BF%E7%94%A8node.js%E5%AE%9E%E7%8E%B0restful-api%E5%9B%9B%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83/</guid>
      <description>1、安装passport及passport-jwt
npm install passport passport-jwt 2、添加passport授权
修改server.js
const passport = require(&amp;#34;passport&amp;#34;); const passportJWT = require(&amp;#39;passport-jwt&amp;#39;); const { port, secret } = require(&amp;#39;./config&amp;#39;); const ExtractJwt = passportJWT.ExtractJwt; const JwtStrategy = passportJWT.Strategy; const User = require(&amp;#34;./models/user&amp;#34;); passport.use( new JwtStrategy( { jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), secretOrKey: secret, }, async (jwtPayload, next) =&amp;gt; { //根据jwt中的id，查找数据库中是否存在该用户 const user = await User.findOne({ _id: jwtPayload.id }); if (user) { next(null, user); } else { next(null, false); } } ) ); const app = express(); app.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/leetcode/238.movezero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/leetcode/238.movezero/</guid>
      <description>[0,1,0,3,12]
0、 left = 0, right = 0, nums = [0,1,0,3,12]
1、 left = 0 right = 0 nums[right] = nums[0] = 0
nums[0] === 0 {
} right++ nums = [0,1,0,3,12]
2、 left = 0 right = 1 nums[right] = nums[1] = 1
nums[1] != 0 { nums = [1,0,0,2,12] left++ } right++ nums = [1,0,0,2,12]
3、 left = 1 right = 2 nums[right] = nums[2] = 0
nums[2] === 0 {</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/other/%E4%BD%BF%E7%94%A8python%E8%84%9A%E6%9C%AC%E6%9B%BF%E6%8D%A2%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/%E4%BD%BF%E7%94%A8python%E8%84%9A%E6%9C%AC%E6%9B%BF%E6%8D%A2%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7/</guid>
      <description>需求 后端模板文件引用前端资源，发布时，使用Python脚本自动替换前端资源的版本。
准备工作 前端使用Webpack构建，每次构建完成时，会生成一个buildfile.json
buildfile.json
{ &amp;#34;about.css&amp;#34;: &amp;#34;about-ca3f85cec35d3ab39ac0.css&amp;#34;, &amp;#34;about.js&amp;#34;: &amp;#34;about-613281148cb8885f2b3d.js&amp;#34;, &amp;#34;home.css&amp;#34;: &amp;#34;home-94093b44a5a85be01f38.css&amp;#34;, &amp;#34;home.js&amp;#34;: &amp;#34;home-6dd4e116818ee4945f65.js&amp;#34; } 读取前端构建文件 import os import json BUILD_FILES = {} def get_build_files(): build_file_path = &amp;#39;/Users/pengjie/try/iseo2/dist/buildfile.json&amp;#39; if(os.path.exists(build_file_path)): with open(build_file_path,&amp;#39;r&amp;#39;) as f: return json.load(f) else: print(&amp;#39;build file not exists.&amp;#39;) return &amp;#39;&amp;#39; BUILD_FILES = get_build_files(); 获取所有模板文件 def get_template_files(): template_path = &amp;#39;/Users/pengjie/try/iseo2/tmpviews&amp;#39; template_files = [] for dirpath, dirnames, filenames in os.walk(template_path): for filename in filenames: if(filename[0] != &amp;#39;.&amp;#39;): filepath = os.path.join(dirpath,filename) template_files.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/other/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%AE%A8%E8%AE%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%AE%A8%E8%AE%BA/</guid>
      <description>讨论过程 李朋杰 @10:44 场景：开发小程序版本（原微信公众号h5）
1.微信原生开发 只支持微信版；
2.使用跨端框架开发； 可选的框架： uni-app,23k,vue语法 https://github.com/dcloudio/uni-app taro,25.9k,react语法 https://github.com/NervJS/taro mpvue,19.9k,vue语法 https://github.com/Meituan-Dianping/mpvue wepy,20.4k,vue语法 https://github.com/Tencent/wepy chameleon,7.6k https://github.com/didi/chameleon
3.对比： 深入测试一周，主流多端框架大比武（uni-app团队） https://mp.weixin.qq.com/s/jIDEHfuMnED6HTfNgjsW4w 小程序端框架全面测评（taro团队） https://aotu.io/notes/2019/03/12/mini-program-framework-full-review/ 跨端开发框架深度横评之2020版 https://juejin.im/post/5e8e8d5a6fb9a03c6d3d9f42
温伟东 @10:52 个人还是比较倾向于原生小程序开发，那些框架，都是坑，保不齐啥时候就没了（国内）
马敬涛 @10:53 这个我们之前进行过调研https://pddoctor.yuque.com/lqkyef/gzb8ni/rb01gw，如果从公司长期开发、维护、高可用上考虑，我们更倾向于原生
马敬涛 @10:53 对于公司快速开发，维护人员少的更适合三方，taro坑也不少，taro算是做的好的
马啸天 @10:59 我个人还是更倾向于原生开发的，最重要的一点还是稳定性的问题，第三方框架保不准什么时候就不更新维护或者消失了，并且咱们公司目前没有很大的需求需要同时开发多端的小程序，原生开发已经可以满足了，还有一点就是框架中可能会遇到很多未知的坑，毕竟还没有实打实的去使用
马敬涛 @11:02 还是需要从开发、维护、稳定上出发，保不齐有些就是公司KPI产物，国内公司大家都懂得。
温伟东 @11:03 对头，个人也觉得原生开发已经很好用了，工具啥的也很强大，
讨论结果 大家都倾向于使用微信原生开发。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/other/%E7%9F%A5%E8%AF%86%E8%90%A5%E9%94%80%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%BE%AE%E4%BF%A1%E8%A7%86%E9%A2%91%E5%8F%B7%E9%93%BE%E6%8E%A5%E4%B8%8D%E6%98%BE%E7%A4%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/%E7%9F%A5%E8%AF%86%E8%90%A5%E9%94%80%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%BE%AE%E4%BF%A1%E8%A7%86%E9%A2%91%E5%8F%B7%E9%93%BE%E6%8E%A5%E4%B8%8D%E6%98%BE%E7%A4%BA/</guid>
      <description>问题 先说结论 微信视频号比较封闭，只能在微信内分享。这个与 App 自身基因有关，抖音、快手等作为短视频平台，需要依靠社交平台分享传播，而视频号作为微信未来视频业务的一部分，目前只能在微信内打开和观看，无法在外部分享，也无法通过浏览器打开，这也导致了常规视频解析下载方法失灵。
解决方案 使用【微信视频下载工具】 把 微信视频号视频下载到本地； 把下载到本地的视频 通过运营后台， 上传工具上传，获取上传的地址，然后在知识营销里用。 详细步骤 下载【微信视频下载工具】 下载地址：https://www.123pan.com/s/FBJrVv-23nPA
登录微信视频号后台 https://channels.weixin.qq.com/platform/login 打开 【微信视频下载工具】，在视频号后台播放一下这个视频 ，就能识别出这个视频 ，就可以把这个视频下载到本地，格式是mp4。 把下载到本地的视频 通过运营后台https://app.doctorpanda.com/operation/#/login， 常用工具 -&amp;gt; 上传文件，复制链接地址，然后在知识营销里用。 参考：
两款简单好用的微信视频号下载工具 https://www.ittel.cn/archives/10482.html
微信视频号下载工具（windows版） WeChatVideoDownloader.Setup.1.0.0PC安装包.rar</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/other/%E8%99%9A%E6%8B%9Fdom%E5%BA%93snabbdom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/other/%E8%99%9A%E6%8B%9Fdom%E5%BA%93snabbdom/</guid>
      <description>定义虚拟节点 //vnode.js
function vnode(sel, data, children, text, elm) { const key = data === undefined ? undefined : data.key; return { sel, data, children, text, elm, key }; } 辅助方法 //is.js
function primitive(s) { return typeof s === &amp;#34;string&amp;#34; || typeof s === &amp;#34;number&amp;#34;; } const is = { primitive: primitive, array: Array.isArray, }; h函数 h.js
function h(sel, b, c) { let data = {}; let children; let text; let i; if (c !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E7%8E%8B%E5%8A%9B%E9%9B%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E5%85%B6%E4%BB%96/%E7%8E%8B%E5%8A%9B%E9%9B%84/</guid>
      <description>王力雄：天葬——西藏的命运 前言 北京和达兰萨拉，两边所说都有真实的成分，同时也都一样存在许多谎言
尽管达赖喇嘛的个人人格值得尊敬，但他的宣传机器为了政治目的而进行的宣传离事实真相之远，与北京实在也是伯仲难分。
1、清代对藏的经营 藏传佛教逐步成为蒙古全民族的信仰，达赖与班禅也成为所有蒙古人共同的精神领袖。
如果能够控制西藏和西藏的的宗教领袖，那就可以在很大程度上控制蒙古人。反之，如果不进行这种控制，让西藏和蒙古自己联合起来，就很容易形成祸根。
盖中外黄教总司以此二人（指达赖和班禅──作者），各蒙古一心归之。兴黄教，即所以安众蒙古，所系非小。
卫藏安而西北之边境安，黄教服而准蒙之番民皆服”
各方势力都需要寻求自己的靠山和保护者，也需要一个居高临下的仲裁权威，清王朝正好就是这样一个角色。
对于驻藏大臣的角色，今天的北京与达兰萨拉的宣传机器各执一词。北京方面一直宣称驻藏大臣是中国对西藏具有主权的标志，是代表中央政府对西藏地方实施主权管理的官员。达赖方面则说驻藏大臣不过是满清皇帝的大使，负责传递消息而已，顶多对西藏政务充当一下顾问的角色，从来没有实际权力。
2、是主权还是宗主权 研究结果，卡罗向沈宗濂说，对这个词还很难下定义，宗主权的伸缩性很大，这要看中央政府对一个地方的权力贯彻到什么程度。如果全部贯彻了，那就是主权，不然，就是宗主权吧。
根源就在于上述章程在西藏远非全部兑现，大部分时间仅停留于名义而已。
5、东方式关系 即便在清朝最强盛的时期，中国对西藏的宗主权“从来没有形式化过，而且也没有任何的条约或是其他和谈来确定双方的权力和义务”
西藏统治者以其特有的圆滑和耐性，通过架空驻藏大臣维持了实质上的独立。
清朝设置驻藏大臣的目的，只是维持一个统治西藏的象征，而不是进行具体的统治。
古代中国从来不以法律界定自己的领土，只要在文化或政治上表示巨服，就一概被认为属于中国。
加上“无为而治”的传统帝王哲学，宁愿让那些“化外之邦”自己管理自己，所以古代中国的边界一直十分模糊。
除非你有让人家服从你的实力，否则只有接受人家的规则。不改变就挨打──这就是国际“丛林”的规则。
按照主权的定义，西藏人可以认为自己一直拥有实质上的主权，它有符合独立国家定义的领土、人民和政权三要素，有独立的军队，发行自己的货币，并有自己独特的文化。而中国则以西藏历史上的臣服姿态为根据，宣称自己拥有法律意义上的主权。
。这种意识不仅存在于北京的王宫，也已经成为大多数中国人的集体意识，而且可以很自然地与近代主权概念画上等号。
1、西方出现 英国人这才认识到，中国对西藏的权力只是个名义，实际是不能控制西藏的，敲开西藏的大门，必须和西藏统治者直接打交道。
西方人就是这样，只要你违反了我的标准，我就认为你违反了天意公理，是不文明的，就要上去揪你的脖子。
这种时候，你要是伸张自己的文明和标准，除非你有反过来揪住对方脖子的实力。
2、大炮上课 从第一次英藏战争到第二次英藏战争之间的十几年中，西藏人一直就在跟英国人玩这种东方式的游戏，指望以推托扯皮消磨对方，将己所不欲之事化解于不了了之中。
在对西藏政策问题上，我们似乎在一个恶性循环的圈子里转圈。如果我们与西藏交涉，要么得不到答复，要么就是叫我们去同驻藏大臣打交道；如果我们与驻藏大臣交涉，他就会寻找借口，说他无力对西藏施加任何压力。
英国人也有办法，你对我不闻不问，我就揍你，打疼了你，你就不得不睁开眼睛，跟我对话了
。有泰倒不一定是有意丧权辱国，而是他首先还没有懂得什么是主权，什么是现代意义上的国家。
尽管面对的已经是一个全新的时代和全新的对象，他仍然以为可以像线装书记载的老祖宗们那样，玩弄“以夷制夷”的古老把戏罢。
3、清末对西藏的新政 中国迅速地行动起来。英军对拉萨的占领和其后西藏人在刺刀逼迫下签署的拉萨条约极大地刺激了中国统治者和精英集团，也由此剧烈地改变了中国对西藏历来采取的无为而治的政策。他们认识到，如果再用以往那种东方式的关系维系西藏，则西藏无需日久就将彻底丧失。
当时的情况有点像两个势均力敌的强盗，都不愿意让一件财宝落入对方手中，为了避免彼此拔刀相见，两败俱伤，宁愿承认财宝属于一个弱小的第三者。
这些条约是西方对中国拥有西藏的正式认可，为后来中国全面统治西藏提供了国际公法方面的依据，其延续的影响至今仍然束缚着西方各国的官方政策，而不论他们在内心对西藏独立运动多么同情。
事实却证明，除非有极大的利益吸引或是强大的武力威慑，谁也不会甘心头顶还有更高的权力。
晚清政府一方面在外交场合坚持中国对西藏的主权，同时则抓紧开始在西藏实行新政，目的就是要控制西藏政权。
。老百姓喜欢“包公”式的清官，此乃不分民族的群众心理
西藏介居英俄两大国之间，因系中国属土，故英未敢吞并。如有奸臣进谗，或劝袒英，或劝袒俄，此皆可杀。或英俄行反间之计，劝尔背汉自立，归他保护，此系吞并之诡谋，切宜勿听。中国抚有西藏二百余年，未尝取西藏一文钱入中国，反为西藏糜费去数千百万。实念西藏百姓与中国血脉一线，如同胞兄弟一样。大皇帝抚莫大之恩，尔子孙世世不可忘。
仔细琢磨，你会发现，今天中共统治西藏的方法，仍在张荫棠的十九条里打转，甚至连具体到联络尼泊尔以制约印度，今天都照办不误。
所谓改土归流，就是把当地世袭的土司，换成由清政府任命的、可以随时流动的外来满汉官员，消除土司割据的政体，纳入与中国内地一致的州县制政权体系。
。但是张荫棠、赵尔丰共犯一个通病，即在收权之外，还企图以汉文明改造藏人。
对西藏收权，威胁的仅是原来掌权的西藏上层统治集团，即使遇到反抗，范围也有限。只要日子过得好（或至少不比原来坏），多数老百姓对到底由谁掌权并不真正关心。然而对西藏社会实行同化政策，就等于把冲突的对象扩展到全体百姓。歧视一个民族的传统风俗文化并强行其改变，一定会激起民众的共同愤恨。一旦民众与民族上层站到一起进行反抗，收权和同化就可能都遭到失败，且由此播下的民族仇恨，也将长期难以化解。
对异质化程度较高的民族实行主权统治，不收政权是不行的──即需要保证政权的“同构”，但同时应该特别注意文化上的宽容，给其社会生活方面的“异质”以充分的自由空间。这两方面应该是相反相成的关系，才能达成一种平衡状态。
4、西藏有了选择 何况，日趋没落的晚清中国还能给西藏什么利益呢？西藏以往臣服北京的理由──寻求保护和仲裁──已不存在。
十三世达赖喇嘛曾经把寻找新靠山的希望寄托于俄国。他把俄国当成信奉佛教的国家，从而希望能重现元朝那种结构──由西藏人充当精神领袖，一个强大的世俗帝国充当信徒、施主兼军事上的保护者。
多数史书认为他与中国的最终决裂，在于慈禧太后坚持要他见面时下跪。虽然西藏在世俗权力中臣服中国，但是达赖喇嘛从来认为自己的宗教地位至高无上。
为了解决这个争执，十三世达赖喇嘛觐见的时间拖后了半个月，最终的妥协是达赖喇嘛以单腿跪拜慈禧太后与光绪皇帝。这对从来以神自居的达赖喇嘛，内心屈辱是可想而知的。而这种屈辱是迫于没有民族前途的无奈，痛苦就会更深，也必然使他产生更强烈的逆反心理。
以十三世达赖喇嘛的此次逃亡为起点，西藏上层社会改变了历史上一贯臣服北京的政治路线，开始了以争取西方支持为资源的近代“西藏独立”运动，一直延续到今天。
我西藏国与满清国之间仅属施主和福田之关系，并无领属关系。为了逐步灭掉我西藏国，诱惑藏民，企图夺取所有权力，伤害佛教，杀害僧侣，强夺财物，其虐待难以言表，这种践踏仍在继续。因此，无法与之保持近亲之关系。西藏之事全靠俄英两国缔结条约，方才维持到今日，现在西藏国全体君臣一致要求依靠两个大国实现独立。
为如此荒凉巨大的西藏承担责任过于沉重，且看不出能得到多少回报，莫不如让中国继续它的宗主权，维持原有格局。为了对英国人表示俄国没有私下与藏人交易，俄皇还把达赖的信转给了英国，使达赖一度在收留他流亡的英国人面前极为尴尬。
中国在其本身最衰落的时期，却对西藏实现了有史以来最有力的控制
流亡印度的十三世达赖喇嘛此时返回西藏，领导藏人开展了全面驱赶中国人的独立战争。
当汉军知道不战再无生还希望时，才开始“死力抗拒”，连汉人百姓也加入了战斗。
对中国来讲，由内地军阀控制西藏怎么也比让西藏自立有利于中国对西藏的主权。当时的战况表明，即使国乱当头，但靠内地一省之兵，西藏也难以抵抗，并不需要中国以举国之力。
十三世达赖喇嘛在历尽了多年挫折和绝望之后，终于实现了彻底摆脱中国人的目标。他明智地认识到，“西藏之所以得救，应当归功于中国革命的爆发，而不应当归于别的原因”。然而多数藏人则把中国革命解释为报应──“中国军队侵占拉萨一年半以后，中国就爆发了革命，清朝皇帝就被推翻，为什么？因为它虐待宗教领袖达赖喇嘛”。
5、民国对西藏的口头主权 随着矛盾尖锐，最终发展到九世班禅于1923年底逃亡中国，投奔民国政府，从此成为西藏“亲汉派”的领袖及十三世达赖的终生敌手。 2、中印在西藏边境的战争 今天，中国出版的地图继续按传统划界，印度地图则早已经把“麦克马洪线”当成了正式的合法边界。
1950年以前，不管双方的地图怎么画，那片争议地区地区没有驻军，不设边防，行政建制也不存在或徒有虚名，老百姓按照祖祖辈辈的方式生活，国际政治与他们无关。
我认为最重要的因素，还是要归结到一个老老实实的技术问题（当然也是实力问题）──在西藏高原上保障后勤的困难。
当时中国军队得到战区老百姓的支持，未见得是把他们当成共产党汉人的军队，而是从统一西藏的角度。那一带历史上一直为藏文明覆盖。
那种靠牦牛和老百姓的双肩维系的后勤支援，不可能长久，也只适用于最前线。战争主要的物资供应，是靠汽车从上千公里外的中国内地运上来。
在西藏高原上进行主权之争，对实力的要求是格外高的。
4、中国必守之地 依靠西藏自己的人口和资源，肯定无法建立足以抵抗外部军事威胁的边防，甚至难以建立可以有效遏止外部流民蚕食的边防，而西藏又不能不建立边防，那么它唯一的选择就是只有依靠一个大国，以获得建立边防的人力物力，或者干脆由那个大国为它承担整个防务。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/2022.11.11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/2022.11.11/</guid>
      <description>什么是正义？ 什么是自由？ 什么是真的？ 什么是好的社会？ 什么是好的政府？
中国 什么是民主？ 中国是民主国家吗？
什么是国体？ 什么是政体？ 中国是国体和政体？
什么是自由？
什么是威权主义？ 什么是极权主义？
什么是历史？ 有真实的历史吗？ 历史虚无主义？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E4%B8%AD%E5%9B%BD%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E4%B8%AD%E5%9B%BD%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>中国的问题.md</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E6%88%91%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E6%88%91%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>中国是工人阶级领导的，以工农联盟为基础的社会主义国家。
新中国，“新”在哪？ 什么是无产阶级？ 什么是社会主义？ 中国是工人阶级领导的国家吗？ 什么是人民民主专政？ 共产党执政的合法性在哪？ 中国现在的统治阶级是谁？ 中国的国家机器镇压的是谁？ 共产党要统计中国一万年吗？ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E7%A5%9E%E4%B8%8D%E6%AD%A3%E4%B9%89%E4%BA%BA%E6%80%8E%E4%B9%88%E5%8A%9E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E7%A5%9E%E4%B8%8D%E6%AD%A3%E4%B9%89%E4%BA%BA%E6%80%8E%E4%B9%88%E5%8A%9E/</guid>
      <description>2022.10.27
神不正义，人怎么办？ 党不正义，人怎么办？ 国家不正义，人怎么办？ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D1-chapter7%E7%94%9F%E6%B4%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D1-chapter7%E7%94%9F%E6%B4%BB/</guid>
      <description>title: &amp;ldquo;与神对话1 - chapter7生活&amp;rdquo; date: 2022-10-12T11:02:58+08:00 categories: &amp;lsquo;read&amp;rsquo; draft: true
生活没什么可怕的，前提是你不执着于结果。
你选择的东西，你统统能够得到。
只要永远忠于真实——你的真实经验——就好了。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D1/</guid>
      <description>2022.10.12
生活的意义不在于抵达任何地方——而在于发现你在那里，向来在那里，已经在那里。你永远处在纯粹创造的时刻中。因此生活的意义就是创造——创造出你的身份和本质，然后去经验它。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E4%B8%96%E7%95%8C%E5%B0%BD%E5%A4%B4%E7%9A%84%E5%92%96%E5%95%A1%E9%A6%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E4%B8%96%E7%95%8C%E5%B0%BD%E5%A4%B4%E7%9A%84%E5%92%96%E5%95%A1%E9%A6%86/</guid>
      <description>2022.10.09
三个问题： 你为什么在这里？ 你害怕死亡吗？ 你满足吗？ 问自己： 我为什么在这里？ 我为什么在新世纪？ 我为什么在北京？ 我为什么工作？ 我为什么而存在？ 我害怕死亡吗？ 我满足吗？ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E8%AF%BB%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D/</guid>
      <description>2022.10.09
真正严肃的哲学问题只有一个：自杀。
问自己： 我为什么不自杀？ 我为什么而活着？ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E9%97%AE%E4%B8%AD%E5%9B%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/post/read/%E8%87%AA%E5%B7%B1/%E9%97%AE%E4%B8%AD%E5%9B%BD/</guid>
      <description>1. 中国是民主国家吗？ 不是。
2. 中国是法治国家吗？ 不是。
3. 中国的政体是什么？ 一党专制。
4. 中国在实行愚民政策吗？ 是的。
5. 中国是由谁统治的？ 共产党寡头制（寡头制，统治者是一小部分人）。
6. 中国有自由吗？ 没有。
7. 爱党等于爱国吗？ 爱党 != 爱国
8. 中共歪曲历史吗？ 歪曲。
9. 中国是社会主义国家吗？ 不是。
10. 中国改革开放失败了吗？ 失败了。
11. 中共统治中国的合法性？ 枪杆子里面出政权。</description>
    </item>
    
  </channel>
</rss>
