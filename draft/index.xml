<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Drafts on Pengjielee&#39;s blog</title>
    <link>https://www.pengjielee.cn/draft/</link>
    <description>Recent content in Drafts on Pengjielee&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 26 Aug 2021 17:15:09 +0800</lastBuildDate><atom:link href="https://www.pengjielee.cn/draft/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>20.表示数值的字符串</title>
      <link>https://www.pengjielee.cn/draft/sword2/_20.%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 26 Aug 2021 17:15:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_20.%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>19.正则表达式匹配</title>
      <link>https://www.pengjielee.cn/draft/sword2/_19.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Thu, 26 Aug 2021 17:14:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_19.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>17.打印从1到最大的n位数</title>
      <link>https://www.pengjielee.cn/draft/sword2/_17.%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Thu, 26 Aug 2021 17:14:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_17.%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>16.数值的整数次方</title>
      <link>https://www.pengjielee.cn/draft/sword2/_16.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</link>
      <pubDate>Thu, 26 Aug 2021 17:14:23 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_16.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>15.二进制中1的个数</title>
      <link>https://www.pengjielee.cn/draft/sword2/_15.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Thu, 26 Aug 2021 17:14:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_15.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>14-ii.剪绳子ii</title>
      <link>https://www.pengjielee.cn/draft/sword2/_14-ii.%E5%89%AA%E7%BB%B3%E5%AD%90ii/</link>
      <pubDate>Thu, 26 Aug 2021 17:14:01 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_14-ii.%E5%89%AA%E7%BB%B3%E5%AD%90ii/</guid>
      <description>题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]&amp;hellip;k[m - 1] 。请问 k[0]k[1]&amp;hellip;*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：
2 &amp;lt;= n &amp;lt;= 1000 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var cuttingRope = function(n) { }; </description>
    </item>
    
    <item>
      <title>14-i.剪绳子</title>
      <link>https://www.pengjielee.cn/draft/sword2/_14-i.%E5%89%AA%E7%BB%B3%E5%AD%90/</link>
      <pubDate>Thu, 26 Aug 2021 17:13:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_14-i.%E5%89%AA%E7%BB%B3%E5%AD%90/</guid>
      <description>题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]&amp;hellip;k[m-1] 。请问 k[0]k[1]&amp;hellip;*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：
2 &amp;lt;= n &amp;lt;= 58 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var cuttingRope = function(n) { }; </description>
    </item>
    
    <item>
      <title>13.机器人的运动范围</title>
      <link>https://www.pengjielee.cn/draft/sword2/_13.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Thu, 26 Aug 2021 17:13:34 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_13.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>12.矩阵中的路径</title>
      <link>https://www.pengjielee.cn/draft/sword2/_12.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Thu, 26 Aug 2021 17:13:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_12.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>11.旋转数组的最小数字</title>
      <link>https://www.pengjielee.cn/draft/sword2/_11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link>
      <pubDate>Thu, 26 Aug 2021 17:13:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>07.重建二叉树</title>
      <link>https://www.pengjielee.cn/draft/sword2/_07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 26 Aug 2021 17:12:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>68-i.二叉搜索树的最近公共祖先</title>
      <link>https://www.pengjielee.cn/draft/sword2/_68-i.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Wed, 25 Aug 2021 15:05:08 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_68-i.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>68-ii.二叉树的最近公共祖先</title>
      <link>https://www.pengjielee.cn/draft/sword2/_68-ii.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Wed, 25 Aug 2021 15:04:32 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_68-ii.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>66.构建乘积数组</title>
      <link>https://www.pengjielee.cn/draft/sword2/_66.%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 25 Aug 2021 15:03:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_66.%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>65.不用加减乘除做加法</title>
      <link>https://www.pengjielee.cn/draft/sword2/_65.%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</link>
      <pubDate>Wed, 25 Aug 2021 15:03:25 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_65.%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</guid>
      <description>题目 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
示例: 输入: a = 1, b = 1 输出: 2 提示：
a, b 均可能是负数或 0 结果不会溢出 32 位整数
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} a * @param {number} b * @return {number} */ var add = function(a, b) { }; </description>
    </item>
    
    <item>
      <title>62.圆圈中最后剩下的数字</title>
      <link>https://www.pengjielee.cn/draft/sword2/_62.%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 25 Aug 2021 14:04:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_62.%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>61.扑克牌中的顺子</title>
      <link>https://www.pengjielee.cn/draft/sword2/_61.%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</link>
      <pubDate>Wed, 25 Aug 2021 14:03:57 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_61.%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>60.n个骰子的点数</title>
      <link>https://www.pengjielee.cn/draft/sword2/_60.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 25 Aug 2021 14:02:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_60.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</guid>
      <description>题目 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
示例 1:
输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示2:
输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
限制：
1 &amp;lt;= n &amp;lt;= 11
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number[]} */ var dicesProbability = function(n) { }; </description>
    </item>
    
    <item>
      <title>46</title>
      <link>https://www.pengjielee.cn/draft/sword2/_46.%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 25 Aug 2021 09:04:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_46.%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>42.连续子数组的最大和</title>
      <link>https://www.pengjielee.cn/draft/sword2/_42.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link>
      <pubDate>Wed, 25 Aug 2021 09:03:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_42.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid>
      <description>题目 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。
示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示：
1 &amp;lt;= arr.length &amp;lt;= 10^5 -100 &amp;lt;= arr[i] &amp;lt;= 100 注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var maxSubArray = function(nums) { }; </description>
    </item>
    
    <item>
      <title>63.股票的最大利润</title>
      <link>https://www.pengjielee.cn/draft/sword2/_63.%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</link>
      <pubDate>Wed, 25 Aug 2021 08:59:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_63.%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</guid>
      <description>题目 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制：
0 &amp;lt;= 数组长度 &amp;lt;= 10^5
注意：本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { }; </description>
    </item>
    
    <item>
      <title>10-II.青蛙跳台阶问题</title>
      <link>https://www.pengjielee.cn/draft/sword2/_10-ii.%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 25 Aug 2021 08:58:18 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_10-ii.%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</guid>
      <description>题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：2 示例 2：
输入：n = 7 输出：21 示例 3：
输入：n = 0 输出：1 提示：
0 &amp;lt;= n &amp;lt;= 100 注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var numWays = function(n) { }; </description>
    </item>
    
    <item>
      <title>10-I.斐波那契数列</title>
      <link>https://www.pengjielee.cn/draft/sword2/_10-i.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Wed, 25 Aug 2021 08:57:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_10-i.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>题目 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1： 输入：n = 2 输出：1 示例 2： 输入：n = 5 输出：5 提示：
0 &amp;lt;= n &amp;lt;= 100
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var fib = function(n) { }; </description>
    </item>
    
    <item>
      <title>58.II.左旋转字符串</title>
      <link>https://www.pengjielee.cn/draft/sword2/_58.ii.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 24 Aug 2021 15:04:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_58.ii.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>35.复杂链表的复制</title>
      <link>https://www.pengjielee.cn/draft/sword2/_35.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Tue, 24 Aug 2021 13:35:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/_35.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid>
      <description>题目 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：
输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]]
示例 3：
输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]]
示例 4： 输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。
提示：
-10000 &amp;lt;= Node.val &amp;lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。
注意：本题与主站 138 题相同：https://leetcode-cn.com/problems/copy-list-with-random-pointer/
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * // Definition for a Node. * function Node(val, next, random) { * this.val = val; * this.</description>
    </item>
    
    <item>
      <title>131</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Wed, 21 Jul 2021 10:50:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>133</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_133.%E5%85%8B%E9%9A%86%E5%9B%BE/</link>
      <pubDate>Wed, 21 Jul 2021 10:50:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_133.%E5%85%8B%E9%9A%86%E5%9B%BE/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>134</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_134.%E5%8A%A0%E6%B2%B9%E7%AB%99/</link>
      <pubDate>Wed, 21 Jul 2021 10:50:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_134.%E5%8A%A0%E6%B2%B9%E7%AB%99/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>139</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</link>
      <pubDate>Wed, 21 Jul 2021 10:50:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>140</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_140.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii/</link>
      <pubDate>Wed, 21 Jul 2021 10:50:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_140.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>146</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_146.lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 21 Jul 2021 10:46:43 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_146.lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>147</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_147.%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 21 Jul 2021 10:46:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_147.%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>149</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_149.%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 21 Jul 2021 10:46:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_149.%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>150</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
      <pubDate>Wed, 21 Jul 2021 10:46:16 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>126.单词接龙II</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99ii/</link>
      <pubDate>Wed, 21 Jul 2021 09:34:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99ii/</guid>
      <description>题目 按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; &amp;hellip; -&amp;gt; sk 这样的单词序列，并满足：
每对相邻的单词之间仅有单个字母不同。 转换过程中的每个单词 si（1 &amp;lt;= i &amp;lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。 sk == endWord 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, &amp;hellip;, sk] 的形式返回。
示例 1： 输入：beginWord = &amp;#34;hit&amp;#34;, endWord = &amp;#34;cog&amp;#34;, wordList = [&amp;#34;hot&amp;#34;,&amp;#34;dot&amp;#34;,&amp;#34;dog&amp;#34;,&amp;#34;lot&amp;#34;,&amp;#34;log&amp;#34;,&amp;#34;cog&amp;#34;] 输出：[[&amp;#34;hit&amp;#34;,&amp;#34;hot&amp;#34;,&amp;#34;dot&amp;#34;,&amp;#34;dog&amp;#34;,&amp;#34;cog&amp;#34;],[&amp;#34;hit&amp;#34;,&amp;#34;hot&amp;#34;,&amp;#34;lot&amp;#34;,&amp;#34;log&amp;#34;,&amp;#34;cog&amp;#34;]] 解释：存在 2 种最短的转换序列： &amp;#34;hit&amp;#34; -&amp;gt; &amp;#34;hot&amp;#34; -&amp;gt; &amp;#34;dot&amp;#34; -&amp;gt; &amp;#34;dog&amp;#34; -&amp;gt; &amp;#34;cog&amp;#34; &amp;#34;hit&amp;#34; -&amp;gt; &amp;#34;hot&amp;#34; -&amp;gt; &amp;#34;lot&amp;#34; -&amp;gt; &amp;#34;log&amp;#34; -&amp;gt; &amp;#34;cog&amp;#34; 示例 2： 输入：beginWord = &amp;#34;hit&amp;#34;, endWord = &amp;#34;cog&amp;#34;, wordList = [&amp;#34;hot&amp;#34;,&amp;#34;dot&amp;#34;,&amp;#34;dog&amp;#34;,&amp;#34;lot&amp;#34;,&amp;#34;log&amp;#34;] 输出：[] 解释：endWord &amp;#34;cog&amp;#34; 不在字典 wordList 中，所以不存在符合要求的转换序列。 提示：</description>
    </item>
    
    <item>
      <title>123.买卖股票的最佳时机III</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_123._%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii/</link>
      <pubDate>Wed, 21 Jul 2021 09:34:14 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_123._%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii/</guid>
      <description>题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 输入：prices = [1] 输出：0 提示：</description>
    </item>
    
    <item>
      <title>130.被围绕的区域</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Wed, 21 Jul 2021 09:33:13 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</guid>
      <description>题目 给你一个 m x n 的矩阵 board ，由若干字符 &amp;lsquo;X&amp;rsquo; 和 &amp;lsquo;O&amp;rsquo; ，找到所有被 &amp;lsquo;X&amp;rsquo; 围绕的区域，并将这些区域里所有的 &amp;lsquo;O&amp;rsquo; 用 &amp;lsquo;X&amp;rsquo; 填充。 示例 1： &amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34; &amp;#34;X&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;X&amp;#34; &amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;X&amp;#34; &amp;#34;X&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34; || &amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34; &amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34; &amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34; &amp;#34;X&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34; 输入：board = [[&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;],[&amp;#34;X&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;X&amp;#34;],[&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;X&amp;#34;],[&amp;#34;X&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;]] 输出：[[&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;],[&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;],[&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;],[&amp;#34;X&amp;#34;,&amp;#34;O&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;X&amp;#34;]] 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &amp;#39;O&amp;#39; 都不会被填充为 &amp;#39;X&amp;#39;。 任何不在边界上，或不与边界上的 &amp;#39;O&amp;#39; 相连的 &amp;#39;O&amp;#39; 最终都会被填充为 &amp;#39;X&amp;#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 示例 2： 输入：board = [[&amp;#34;X&amp;#34;]] 输出：[[&amp;#34;X&amp;#34;]] 提示：
m == board.length n == board[i].length 1 &amp;lt;= m, n &amp;lt;= 200 board[i][j] 为 &amp;lsquo;X&amp;rsquo; 或 &amp;lsquo;O&amp;rsquo; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/surrounded-regions 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</description>
    </item>
    
    <item>
      <title>127.单词接龙</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</link>
      <pubDate>Wed, 21 Jul 2021 09:33:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</guid>
      <description>题目 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：
序列中第一个单词是 beginWord 。 序列中最后一个单词是 endWord 。 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典 wordList 中的单词。 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。
示例 1： 输入：beginWord = &amp;#34;hit&amp;#34;, endWord = &amp;#34;cog&amp;#34;, wordList = [&amp;#34;hot&amp;#34;,&amp;#34;dot&amp;#34;,&amp;#34;dog&amp;#34;,&amp;#34;lot&amp;#34;,&amp;#34;log&amp;#34;,&amp;#34;cog&amp;#34;] 输出：5 解释：一个最短转换序列是 &amp;#34;hit&amp;#34; -&amp;gt; &amp;#34;hot&amp;#34; -&amp;gt; &amp;#34;dot&amp;#34; -&amp;gt; &amp;#34;dog&amp;#34; -&amp;gt; &amp;#34;cog&amp;#34;, 返回它的长度 5。 示例 2： 输入：beginWord = &amp;#34;hit&amp;#34;, endWord = &amp;#34;cog&amp;#34;, wordList = [&amp;#34;hot&amp;#34;,&amp;#34;dot&amp;#34;,&amp;#34;dog&amp;#34;,&amp;#34;lot&amp;#34;,&amp;#34;log&amp;#34;] 输出：0 解释：endWord &amp;#34;cog&amp;#34; 不在字典中，所以无法进行转换。 提示：</description>
    </item>
    
    <item>
      <title>128.最长连续序列</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</link>
      <pubDate>Wed, 21 Jul 2021 09:33:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</guid>
      <description>题目 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
示例 1： 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 提示：
0 &amp;lt;= nums.length &amp;lt;= 10^5 -10^9 &amp;lt;= nums[i] &amp;lt;= 10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-consecutive-sequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var longestConsecutive = function(nums) { }; </description>
    </item>
    
    <item>
      <title>129.求根节点到叶节点数字之和</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Wed, 21 Jul 2021 09:33:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。 每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -&amp;gt; 2 -&amp;gt; 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。
示例 1： 1 / \	2 3 输入：root = [1,2,3] 输出：25 解释： 从根到叶子节点路径 1-&amp;gt;2 代表数字 12 从根到叶子节点路径 1-&amp;gt;3 代表数字 13 因此，数字总和 = 12 + 13 = 25 示例 2： 4 / \ 9 0	/ \ 5 1 输入：root = [4,9,0,5,1] 输出：1026 解释： 从根到叶子节点路径 4-&amp;gt;9-&amp;gt;5 代表数字 495 从根到叶子节点路径 4-&amp;gt;9-&amp;gt;1 代表数字 491 从根到叶子节点路径 4-&amp;gt;0 代表数字 40 因此，数字总和 = 495 + 491 + 40 = 1026 提示：</description>
    </item>
    
    <item>
      <title>190.颠倒二进制位</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_190.%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</link>
      <pubDate>Mon, 19 Jul 2021 11:32:02 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_190.%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</guid>
      <description>题目 颠倒给定的 32 位无符号整数的二进制位。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
进阶: 如果多次调用这个函数，你将如何优化你的算法？
示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 示例 1： 输入：n = 00000010100101000001111010011100 输出：964176192 (00111001011110000010100101000000) 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：n = 11111111111111111111111111111101 输出：3221225471 (10111111111111111111111111111111) 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 提示：</description>
    </item>
    
    <item>
      <title>185.部门工资前三高的所有员工</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_185.%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_185.%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5/</guid>
      <description>题目 Employee 表包含所有员工信息，每个员工有其对应的工号 Id，姓名 Name，工资 Salary 和部门编号 DepartmentId 。
+----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 85000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | | 5 | Janet | 69000 | 1 | | 6 | Randy | 85000 | 1 | | 7 | Will | 70000 | 1 | +----+-------+--------+--------------+ Department 表包含公司所有部门的信息。</description>
    </item>
    
    <item>
      <title>186.翻转字符串里的单词II</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_186._%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8Dii/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_186._%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8Dii/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>187.重复的DNA序列</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_187.%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_187.%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%BA%8F%E5%88%97/</guid>
      <description>题目 所有 DNA 都由一系列缩写为 &amp;lsquo;A&amp;rsquo;，&amp;lsquo;C&amp;rsquo;，&amp;lsquo;G&amp;rsquo; 和 &amp;lsquo;T&amp;rsquo; 的核苷酸组成，例如：&amp;ldquo;ACGAATTCCG&amp;rdquo;。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。
编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。 示例 1： 输入：s = &amp;#34;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;#34; 输出：[&amp;#34;AAAAACCCCC&amp;#34;,&amp;#34;CCCCCAAAAA&amp;#34;] 示例 2： 输入：s = &amp;#34;AAAAAAAAAAAAA&amp;#34; 输出：[&amp;#34;AAAAAAAAAA&amp;#34;] 提示：
0 &amp;lt;= s.length &amp;lt;= 105 s[i] 为 &amp;lsquo;A&amp;rsquo;、&amp;lsquo;C&amp;rsquo;、&amp;lsquo;G&amp;rsquo; 或 &amp;lsquo;T&amp;rsquo; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/repeated-dna-sequences 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @return {string[]} */ var findRepeatedDnaSequences = function(s) { }; </description>
    </item>
    
    <item>
      <title>188.买卖股票的最佳时机IV</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_188._%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiv/</link>
      <pubDate>Mon, 19 Jul 2021 11:30:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_188._%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiv/</guid>
      <description>题目 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示：</description>
    </item>
    
    <item>
      <title>173</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Mon, 19 Jul 2021 11:21:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>174</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_174.%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Mon, 19 Jul 2021 11:21:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_174.%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>175</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_175.%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/</link>
      <pubDate>Mon, 19 Jul 2021 11:21:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_175.%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>176</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_176.%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</link>
      <pubDate>Mon, 19 Jul 2021 11:21:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_176.%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>177</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_177.%E7%AC%ACn%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</link>
      <pubDate>Mon, 19 Jul 2021 11:21:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_177.%E7%AC%ACn%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>178</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_178.%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/</link>
      <pubDate>Mon, 19 Jul 2021 11:21:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_178.%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>179</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_179.%E6%9C%80%E5%A4%A7%E6%95%B0/</link>
      <pubDate>Mon, 19 Jul 2021 11:21:35 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_179.%E6%9C%80%E5%A4%A7%E6%95%B0/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>172.阶乘后的零</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_172.%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</link>
      <pubDate>Mon, 19 Jul 2021 11:10:24 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_172.%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</guid>
      <description>题目 给定一个整数 n，返回 n! 结果尾数中零的数量。
示例 1: 输入: 3 输出: 0 解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5 输出: 1 解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var trailingZeroes = function(n) { }; </description>
    </item>
    
    <item>
      <title>171.Excel表列序号</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_171.excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</link>
      <pubDate>Mon, 19 Jul 2021 11:08:47 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_171.excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</guid>
      <description>题目 给定一个Excel表格中的列名称，返回其相应的列序号。
例如，
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... 示例 1: 输入: &amp;#34;A&amp;#34; 输出: 1 示例 2: 输入: &amp;#34;AB&amp;#34; 输出: 28 示例 3: 输入: &amp;#34;ZY&amp;#34; 输出: 701 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/excel-sheet-column-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} columnTitle * @return {number} */ var titleToNumber = function(columnTitle) { }; </description>
    </item>
    
    <item>
      <title>168.Excel表列名称</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_168.excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</link>
      <pubDate>Mon, 19 Jul 2021 10:56:40 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_168.excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</guid>
      <description>题目 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。
例如：
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... 示例 1： 输入：columnNumber = 1 输出：&amp;#34;A&amp;#34; 示例 2： 输入：columnNumber = 28 输出：&amp;#34;AB&amp;#34; 示例 3： 输入：columnNumber = 701 输出：&amp;#34;ZY&amp;#34; 示例 4： 输入：columnNumber = 2147483647 输出：&amp;#34;FXSHRXW&amp;#34; 提示：
1 &amp;lt;= columnNumber &amp;lt;= 2^31 - 1
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/excel-sheet-column-title 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} columnNumber * @return {string} */ var convertToTitle = function(columnNumber) { }; </description>
    </item>
    
    <item>
      <title>166.分数到小数</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_166.%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</link>
      <pubDate>Mon, 19 Jul 2021 10:53:42 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_166.%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</guid>
      <description>题目 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。
如果小数部分为循环小数，则将循环的部分括在括号内。
如果存在多个答案，只需返回 任意一个 。
对于所有给定的输入，保证 答案字符串的长度小于 104 。
示例 1： 输入：numerator = 1, denominator = 2 输出：&amp;#34;0.5&amp;#34; 示例 2： 输入：numerator = 2, denominator = 1 输出：&amp;#34;2&amp;#34; 示例 3： 输入：numerator = 2, denominator = 3 输出：&amp;#34;0.(6)&amp;#34; 示例 4： 输入：numerator = 4, denominator = 333 输出：&amp;#34;0.(012)&amp;#34; 示例 5： 输入：numerator = 1, denominator = 5 输出：&amp;#34;0.2&amp;#34; 提示：
-2^31 &amp;lt;= numerator, denominator &amp;lt;= 2^31 - 1 denominator !</description>
    </item>
    
    <item>
      <title>165.比较版本号</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_165.%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</link>
      <pubDate>Mon, 19 Jul 2021 10:50:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_165.%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</guid>
      <description>题目 给你两个版本号 version1 和 version2 ，请你比较它们。
版本号由一个或多个修订号组成，各修订号由一个 &amp;lsquo;.&amp;rsquo; 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &amp;lt; 1 。
返回规则如下：
如果 version1 &amp;gt; version2 返回 1， 如果 version1 &amp;lt; version2 返回 -1， 除此之外返回 0。 示例 1： 输入：version1 = &amp;#34;1.01&amp;#34;, version2 = &amp;#34;1.001&amp;#34; 输出：0 解释：忽略前导零，&amp;#34;01&amp;#34; 和 &amp;#34;001&amp;#34; 都表示相同的整数 &amp;#34;1&amp;#34; 示例 2： 输入：version1 = &amp;#34;1.</description>
    </item>
    
    <item>
      <title>164.最大间距</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_164.%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D/</link>
      <pubDate>Mon, 19 Jul 2021 10:30:30 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_164.%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D/</guid>
      <description>题目 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。
如果数组元素个数小于 2，则返回 0。
示例 1: 输入: [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 输入: [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 说明:
你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-gap 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var maximumGap = function(nums) { }; </description>
    </item>
    
    <item>
      <title>162.寻找峰值</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_162.%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</link>
      <pubDate>Mon, 19 Jul 2021 10:27:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_162.%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</guid>
      <description>题目 峰值元素是指其值大于左右相邻值的元素。
给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞ 。
示例 1： 输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2： 输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示：
1 &amp;lt;= nums.length &amp;lt;= 1000 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] 进阶：你可以实现时间复杂度为 O(logN) 的解决方案吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-peak-element 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var findPeakElement = function(nums) { }; </description>
    </item>
    
    <item>
      <title>087.扰乱字符串</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_087.%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 14 Jul 2021 15:50:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_087.%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止； 如果字符串的长度 &amp;gt; 1 ，执行下述步骤： 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。
示例 1： 输入：s1 = &amp;#34;great&amp;#34;, s2 = &amp;#34;rgeat&amp;#34; 输出：true 解释：s1 上可能发生的一种情形是： &amp;#34;great&amp;#34; --&amp;gt; &amp;#34;gr/eat&amp;#34; // 在一个随机下标处分割得到两个子字符串 &amp;#34;gr/eat&amp;#34; --&amp;gt; &amp;#34;gr/eat&amp;#34; // 随机决定：「保持这两个子字符串的顺序不变」 &amp;#34;gr/eat&amp;#34; --&amp;gt; &amp;#34;g/r / e/at&amp;#34; // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割 &amp;#34;g/r / e/at&amp;#34; --&amp;gt; &amp;#34;r/g / e/at&amp;#34; // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」 &amp;#34;r/g / e/at&amp;#34; --&amp;gt; &amp;#34;r/g / e/ a/t&amp;#34; // 继续递归执行此算法，将 &amp;#34;at&amp;#34; 分割得到 &amp;#34;a/t&amp;#34; &amp;#34;r/g / e/ a/t&amp;#34; --&amp;gt; &amp;#34;r/g / e/ a/t&amp;#34; // 随机决定：「保持这两个子字符串的顺序不变」 算法终止，结果字符串和 s2 相同，都是 &amp;#34;rgeat&amp;#34; 这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true 示例 2： 输入：s1 = &amp;#34;abcde&amp;#34;, s2 = &amp;#34;caebd&amp;#34; 输出：false 示例 3： 输入：s1 = &amp;#34;a&amp;#34;, s2 = &amp;#34;a&amp;#34; 输出：true 提示：</description>
    </item>
    
    <item>
      <title>091.解码方法</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_091.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 14 Jul 2021 11:20:58 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_091.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</guid>
      <description>题目 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
&amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 ... &amp;#39;Z&amp;#39; -&amp;gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&amp;ldquo;11106&amp;rdquo; 可以映射为：
&amp;#34;AAJF&amp;#34; ，将消息分组为 (1 1 10 6) &amp;#34;KJF&amp;#34; ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 &amp;ldquo;06&amp;rdquo; 不能映射为 &amp;ldquo;F&amp;rdquo; ，这是由于 &amp;ldquo;6&amp;rdquo; 和 &amp;ldquo;06&amp;rdquo; 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
示例 1： 输入：s = &amp;#34;12&amp;#34; 输出：2 解释：它可以解码为 &amp;#34;AB&amp;#34;（1 2）或者 &amp;#34;L&amp;#34;（12）。 示例 2： 输入：s = &amp;#34;226&amp;#34; 输出：3 解释：它可以解码为 &amp;#34;BZ&amp;#34; (2 26), &amp;#34;VF&amp;#34; (22 6), 或者 &amp;#34;BBF&amp;#34; (2 2 6) 。 示例 3： 输入：s = &amp;#34;0&amp;#34; 输出：0 解释：没有字符映射到以 0 开头的数字。 含有 0 的有效映射是 &amp;#39;J&amp;#39; -&amp;gt; &amp;#34;10&amp;#34; 和 &amp;#39;T&amp;#39;-&amp;gt; &amp;#34;20&amp;#34; 。 由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。 示例 4： 输入：s = &amp;#34;06&amp;#34; 输出：0 解释：&amp;#34;06&amp;#34; 不能映射到 &amp;#34;F&amp;#34; ，因为字符串含有前导 0（&amp;#34;6&amp;#34; 和 &amp;#34;06&amp;#34; 在映射中并不等价）。 提示：</description>
    </item>
    
    <item>
      <title>007.整数反转</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_007.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Thu, 20 May 2021 10:00:21 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_007.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      <description>题目 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0 提示：
-2^31 &amp;lt;= x &amp;lt;= 2^31 - 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-integer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 以数字123为例：
1、将123 % 10 得到3，再将123 / 10 2、将12 % 10 得到2，再将12 / 10 3、将1 % 10 得到1，再将1 / 10</description>
    </item>
    
    <item>
      <title>739.每日温度</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_739._%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</link>
      <pubDate>Wed, 12 May 2021 11:20:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_739._%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</guid>
      <description>题目 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如， 给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]， 你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/daily-temperatures 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} T * @return {number[]} */ var dailyTemperatures = function(T) { }; </description>
    </item>
    
    <item>
      <title>279.完全平方数</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</link>
      <pubDate>Wed, 12 May 2021 09:39:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</guid>
      <description>题目 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, &amp;hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9 提示：
1 &amp;lt;= n &amp;lt;= 10^4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/perfect-squares 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 我们将问题重新表述成：
给定一个完全平方数列表和正整数 n，求出完全平方数组合成 n 的组合，要求组合中的解拥有完全平方数的最小个数。
注：可以重复使用列表中的完全平方数。
作者：LeetCode 链接：https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {number} */ var numSquares = function(n) { }; </description>
    </item>
    
    <item>
      <title>137.只出现一次的数字II</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_137.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97ii/</link>
      <pubDate>Sat, 08 May 2021 13:47:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_137.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97ii/</guid>
      <description>题目 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
示例 1： 输入：nums = [2,2,3,2] 输出：3 示例 2： 输入：nums = [0,1,0,1,0,1,99] 输出：99 提示：
1 &amp;lt;= nums.length &amp;lt;= 3 * 10^4 -2^31 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-number-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { }; </description>
    </item>
    
    <item>
      <title>029.两数相除</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_029.%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</link>
      <pubDate>Thu, 06 May 2021 16:52:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_029.%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</guid>
      <description>题目 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1: 输入: dividend = 10, divisor = 3 输出: 3 解释: 10/3 = truncate(3.33333..) = truncate(3) = 3 示例 2: 输入: dividend = 7, divisor = -3 输出: -2 解释: 7/-3 = truncate(-2.33333..) = -2 提示：
被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>413.等差数列划分</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_413.%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</link>
      <pubDate>Thu, 06 May 2021 15:47:04 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_413.%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</guid>
      <description>题目 如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。
例如
以下数列为等差数列: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 以下数列不是等差数列。 1, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&amp;lt;=P&amp;lt;Q&amp;lt;N 。
如果满足以下条件，则称子数组(P, Q)为等差数组：
元素 A[P], A[p + 1], &amp;hellip;, A[Q - 1], A[Q] 是等差的。并且 P + 1 &amp;lt; Q 。
函数要返回数组 A 中所有为等差数组的子数组个数。
示例:
A = [1, 2, 3, 4] 返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>406.根据身高重建队列</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 06 May 2021 14:00:50 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>665.非递减数列</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_665.%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</link>
      <pubDate>Thu, 06 May 2021 13:48:12 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_665.%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</guid>
      <description>题目 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &amp;lt;= i &amp;lt;= n-2)，总满足 nums[i] &amp;lt;= nums[i + 1]。
示例 1: 输入: nums = [4,2,3] 输出: true 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 输入: nums = [4,2,1] 输出: false 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 提示：
1 &amp;lt;= n &amp;lt;= 10 ^ 4 -10 ^ 5 &amp;lt;= nums[i] &amp;lt;= 10 ^ 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-decreasing-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} nums * @return {boolean} */ var checkPossibility = function(nums) { }; </description>
    </item>
    
    <item>
      <title>076.最小覆盖子串</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_076.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 06 May 2021 11:03:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_076.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</guid>
      <description>题目 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &amp;quot;&amp;quot; 。
注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。
示例 1： 输入：s = &amp;#34;ADOBECODEBANC&amp;#34;, t = &amp;#34;ABC&amp;#34; 输出：&amp;#34;BANC&amp;#34; 示例 2： 输入：s = &amp;#34;a&amp;#34;, t = &amp;#34;a&amp;#34; 输出：&amp;#34;a&amp;#34; 提示：
1 &amp;lt;= s.length, t.length &amp;lt;= 10^5 s 和 t 由英文字母组成 进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-window-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { }; </description>
    </item>
    
    <item>
      <title>227.基本计算器II</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_227.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8ii/</link>
      <pubDate>Tue, 27 Apr 2021 11:36:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_227.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8ii/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>028.实现strStr()</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_028.%E5%AE%9E%E7%8E%B0strstr/</link>
      <pubDate>Tue, 27 Apr 2021 11:33:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_028.%E5%AE%9E%E7%8E%B0strstr/</guid>
      <description>题目 实现 strStr() 函数。
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。
说明：
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例：
示例 1： 输入：haystack = &amp;#34;hello&amp;#34;, needle = &amp;#34;ll&amp;#34; 输出：2 示例 2： 输入：haystack = &amp;#34;aaaaa&amp;#34;, needle = &amp;#34;bba&amp;#34; 输出：-1 示例 3： 输入：haystack = &amp;#34;&amp;#34;, needle = &amp;#34;&amp;#34; 输出：0 提示：
0 &amp;lt;= haystack.length, needle.length &amp;lt;= 5 * 10^4 haystack 和 needle 仅由小写英文字符组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>696.计数二进制子串</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_696._%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 27 Apr 2021 10:57:09 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_696._%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>647.回文子串</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 27 Apr 2021 10:56:56 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>题目 JS实现 </description>
    </item>
    
    <item>
      <title>452.用最少数量的箭引爆气球</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</link>
      <pubDate>Mon, 26 Apr 2021 14:46:38 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</guid>
      <description>题目 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 示例 3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 示例 4： 输入：points = [[1,2]] 输出：1 示例 5： 输入：points = [[2,3],[2,3]] 输出：1 提示：
0 &amp;lt;= points.length &amp;lt;= 10^4 points[i].length == 2 -2^31 &amp;lt;= xstart &amp;lt; xend &amp;lt;= 2^31 - 1</description>
    </item>
    
    <item>
      <title>605.种花问题</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_605.%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 26 Apr 2021 14:39:51 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_605.%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</guid>
      <description>题目 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。
示例 1： 输入：flowerbed = [1,0,0,0,1], n = 1 输出：true 示例 2： 输入：flowerbed = [1,0,0,0,1], n = 2 输出：false 提示：
1 &amp;lt;= flowerbed.length &amp;lt;= 2 * 104 flowerbed[i] 为 0 或 1 flowerbed 中不存在相邻的两朵花 0 &amp;lt;= n &amp;lt;= flowerbed.length 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/can-place-flowers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} flowerbed * @param {number} n * @return {boolean} */ var canPlaceFlowers = function(flowerbed, n) { }; </description>
    </item>
    
    <item>
      <title>022.括号生成</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_022.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</link>
      <pubDate>Sun, 25 Apr 2021 11:27:59 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_022.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</guid>
      <description>题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例 1： 输入：n = 3 输出：[&amp;#34;((()))&amp;#34;,&amp;#34;(()())&amp;#34;,&amp;#34;(())()&amp;#34;,&amp;#34;()(())&amp;#34;,&amp;#34;()()()&amp;#34;] 示例 2： 输入：n = 1 输出：[&amp;#34;()&amp;#34;] 提示：
1 &amp;lt;= n &amp;lt;= 8
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/generate-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { }; </description>
    </item>
    
    <item>
      <title>005.最长回文子串</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_005.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Sun, 25 Apr 2021 11:11:33 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_005.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>题目 给你一个字符串 s，找到 s 中最长的回文子串。
示例 1： 输入：s = &amp;#34;babad&amp;#34; 输出：&amp;#34;bab&amp;#34; 解释：&amp;#34;aba&amp;#34; 同样是符合题意的答案。 示例 2： 输入：s = &amp;#34;cbbd&amp;#34; 输出：&amp;#34;bb&amp;#34; 示例 3： 输入：s = &amp;#34;a&amp;#34; 输出：&amp;#34;a&amp;#34; 示例 4： 输入：s = &amp;#34;ac&amp;#34; 输出：&amp;#34;a&amp;#34; 提示：
1 &amp;lt;= s.length &amp;lt;= 1000 s 仅由数字和英文字母（大写和/或小写）组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindromic-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 回文串：是从左到右读，从右到左读都一样的字符串。具有轴对称的特点。 子串：是原始字符串的一个连续子集。 子序列：是原始字符串的一个子集。 JS实现 /** * @param {string} s * @return {string} */ var longestPalindrome = function(s) { }; </description>
    </item>
    
    <item>
      <title>377.组合总和Ⅳ</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 23 Apr 2021 09:58:22 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>题目 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。
示例 1： 输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2： 输入：nums = [9], target = 3 输出：0 提示：
1 &amp;lt;= nums.length &amp;lt;= 200 1 &amp;lt;= nums[i] &amp;lt;= 1000 nums 中的所有元素 互不相同 1 &amp;lt;= target &amp;lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>040.组合总和II</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii/</link>
      <pubDate>Fri, 23 Apr 2021 09:52:27 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii/</guid>
      <description>题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
说明：
所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例：
示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combination-sum-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum2 = function(candidates, target) { }; </description>
    </item>
    
    <item>
      <title>148.排序链表</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 21 Apr 2021 09:06:41 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
进阶： 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例 1： 4 -&amp;gt; 2 -&amp;gt; 1 -&amp;gt; 3 排序后： 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2： -1 -&amp;gt; 5 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 0 排序后： 1 -&amp;gt; 0 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5] 示例 3： 输入：head = [] 输出：[] 提示：
链表中节点的数目在范围 [0, 5 * 10^4] 内 -10^5 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>124.二叉树中的最大路径和</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Tue, 20 Apr 2021 16:03:05 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description>题目 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。
示例 1： 1 / 2 3 输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -&amp;gt; 1 -&amp;gt; 3 ，路径和为 2 + 1 + 3 = 6
示例 2： -10 / 9 20 / 15 7 输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&amp;gt; 20 -&amp;gt; 7 ，路径和为 15 + 20 + 7 = 42
提示：
树中节点数目范围是 [1, 3 * 10^4] -1000 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>437.路径总和III</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciii/</link>
      <pubDate>Tue, 20 Apr 2021 15:50:48 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Ciii/</guid>
      <description>题目 给定一个二叉树，它的每个结点都存放着一个整数值。
找出路径和等于给定数值的路径总数。
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
示例：
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -&amp;gt; 3 2. 5 -&amp;gt; 2 -&amp;gt; 1 3. -3 -&amp;gt; 11 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/path-sum-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ?</description>
    </item>
    
    <item>
      <title>371.两整数之和</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_371.%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 15 Apr 2021 16:34:43 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_371.%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
示例 1: 输入: a = 1, b = 2 输出: 3 示例 2: 输入: a = -2, b = 3 输出: 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sum-of-two-integers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * @param {number} a * @param {number} b * @return {number} */ var getSum = function(a, b) { }; </description>
    </item>
    
    <item>
      <title>278.第一个错误的版本</title>
      <link>https://www.pengjielee.cn/draft/leetcode/_278.%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</link>
      <pubDate>Fri, 19 Mar 2021 17:10:44 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/_278.%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</guid>
      <description>题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, &amp;hellip;, n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
示例:
给定 n = 5，并且 version = 4 是第一个错误的版本。
调用 isBadVersion(3) -&amp;gt; false
调用 isBadVersion(5) -&amp;gt; true
调用 isBadVersion(4) -&amp;gt; true
所以，4 是第一个错误的版本。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/first-bad-version 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
JS实现 /** * Definition for isBadVersion() * * @param {integer} version number * @return {boolean} whether the version is bad * isBadVersion = function(version) { * ... * }; */ /** * @param {function} isBadVersion() * @return {function} */ var solution = function(isBadVersion) { /** * @param {integer} n Total versions * @return {integer} The first bad version */ return function(n) { }; }; </description>
    </item>
    
    <item>
      <title>49</title>
      <link>https://www.pengjielee.cn/draft/sword/_49.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</link>
      <pubDate>Fri, 12 Mar 2021 15:16:54 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword/_49.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>48.不用加减乘除做加法</title>
      <link>https://www.pengjielee.cn/draft/sword/_48.%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</link>
      <pubDate>Fri, 12 Mar 2021 15:16:45 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword/_48.%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>65</title>
      <link>https://www.pengjielee.cn/draft/sword/_65.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Fri, 12 Mar 2021 15:15:03 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword/_65.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description></description>
    </item>
    
    <item>
      <title>64</title>
      <link>https://www.pengjielee.cn/draft/sword/_64.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Fri, 12 Mar 2021 15:14:55 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword/_64.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description></description>
    </item>
    
    <item>
      <title>62</title>
      <link>https://www.pengjielee.cn/draft/sword/_62.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</link>
      <pubDate>Fri, 12 Mar 2021 15:14:29 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword/_62.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</guid>
      <description></description>
    </item>
    
    <item>
      <title>61</title>
      <link>https://www.pengjielee.cn/draft/sword/_61.%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 12 Mar 2021 15:14:19 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword/_61.%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description></description>
    </item>
    
    <item>
      <title>60</title>
      <link>https://www.pengjielee.cn/draft/sword/_60.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</link>
      <pubDate>Fri, 12 Mar 2021 15:14:06 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword/_60.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</guid>
      <description></description>
    </item>
    
    <item>
      <title>66</title>
      <link>https://www.pengjielee.cn/draft/sword/_66.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Fri, 12 Mar 2021 15:13:36 +0800</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword/_66.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/codetop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/codetop/</guid>
      <description>https://codetop.cc/home var rows = document.querySelectorAll(&amp;#39;.el-table__row&amp;#39;); var results = []; rows.forEach(item =&amp;gt; { const tds = item.querySelectorAll(&amp;#39;td&amp;#39;); const title = tds[0].innerText.replace(&amp;#39;.&amp;#39;,&amp;#39;、&amp;#39;); const hard = tds[1].innerText const count = tds[3].innerText results.push(`${title}, ${hard}, ${count}`) }); copy(results.join(&amp;#39;;;&amp;#39;)); 数组 15、 三数之和, 中等, 275;; 53、 最大子序和, 容易, 243;; 1、 两数之和, 容易, 216;; 33、 搜索旋转排序数组, 中等, 198;; 121、 买卖股票的最佳时机, 容易, 194;; 88、 合并两个有序数组, 容易, 188;; 54、 螺旋矩阵, 中等, 172;; 42、 接雨水, 困难, 139;; 4、 寻找两个正序数组的中位数, 困难, 114;; 56、 合并区间, 中等, 107;; 31、 下一个排列, 中等, 105;; 41、 缺失的第一个正数, 困难, 92;; 105、 从前序与中序遍历序列构造二叉树, 中等, 80;; 78、 子集, 中等, 76;; 64、 最小路径和, 中等, 68;; 39、 组合总和, 中等, 64;; 48、 旋转图像, 中等, 64;; 169、 多数元素, 容易, 61;; 34、 在排序数组中查找元素的第一个和最后一个位置, 中等, 58;; 718、 最长重复子数组, 中等, 58</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/gin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/gin/</guid>
      <description>go中文 https://go-zh.org/
https://tour.go-zh.org/list
https://mikespook.com/tag/golang/
go tour https://golang.google.cn/tour/welcome/1
getting-started https://golang.google.cn/doc/tutorial/getting-started
电子书build-web-application-with-golang https://github.com/astaxie/build-web-application-with-golang
电子书the-way-to-go https://github.com/Unknwon/the-way-to-go_ZH_CN
Go 语言官方教程中文版 https://github.com/Go-zh/tour
如何使用Go编程 https://go-zh.org/doc/code.html
编写web应用 https://go-zh.org/doc/articles/wiki/
the-way-to-go在线 https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/preface.md
github镜像 https://doc.fastgit.org/zh-cn/guide.html
gvm https://github.com/moovweb/gvm.git
bash &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) studygolang https://studygolang.com/
go123 https://hao.studygolang.com/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/leetcode/00.leetcode-basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/00.leetcode-basic/</guid>
      <description>数组 删除排序数组中的重复项;; 买卖股票的最佳时机 II;; 旋转数组;; 存在重复元素;; 只出现一次的数字;; 两个数组的交集 II;; 066.加一;; 283.移动零;; 两数之和;; 036.有效的数独;; 048.旋转图像;; 字符串 反转字符串;; 整数反转;; 字符串中的第一个唯一字符;; 有效的字母异位词;; 验证回文串;; 字符串转换整数 (atoi);; 实现 strStr();; 外观数列;; 最长公共前缀;; 链表 删除链表中的节点;; 删除链表的倒数第N个节点;; 反转链表;; 合并两个有序链表;; 回文链表;; 环形链表;; 树 二叉树的最大深度;; 验证二叉搜索树;; 对称二叉树;; 二叉树的层序遍历;; 将有序数组转换为二叉搜索树;; 排序和搜索 合并两个有序数组;; 第一个错误的版本;; 动态规划 爬楼梯;; 买卖股票的最佳时机;; 最大子序和;; 打家劫舍;; 设计问题 打乱数组;; 最小栈;; 数学 Fizz Buzz;; 计数质数;; 3的幂;; 罗马数字转整数;; 其他 位1的个数;; 汉明距离;; 颠倒二进制位;; 杨辉三角;; 有效的括号;; 缺失数字;; 获取页面上的结果：
var each = () =&amp;gt; { const result = []; var nodes = document.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/leetcode/00.leetcode-hard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/00.leetcode-hard/</guid>
      <description>数组和字符串 除自身以外数组的乘积;; 螺旋矩阵;; 四数相加 II;; 盛最多水的容器;; 生命游戏;; 缺失的第一个正数;; 最长连续序列;; 寻找重复数;; 基本计算器 II;; 滑动窗口最大值;; 最小覆盖子串;; 链表 合并K个排序链表;; 排序链表;; 复制带随机指针的链表;; 树和图 单词接龙;; 被围绕的区域;; 二叉树的最近公共祖先;; 二叉树中的最大路径和;; 朋友圈;; 课程表;; 课程表 II;; 矩阵中的最长递增路径;; 计算右侧小于当前元素的个数;; 回溯算法 分割回文串;; 单词搜索 II;; 删除无效的括号;; 通配符匹配;; 正则表达式匹配;; 排序和搜索 摆动排序 II;; 有序矩阵中第K小的元素;; 寻找两个正序数组的中位数;; 动态规划 乘积最大子数组;; 最佳买卖股票时机含冷冻期;; 完全平方数;; 单词拆分;; 单词拆分 II;; 戳气球;; LRU缓存机制;; 实现 Trie (前缀树);; 扁平化嵌套列表迭代器;; offer41. 数据流的中位数;; 数学 最大数;; 直线上最多的点数;; 其他 根据身高重建队列;; 接雨水;; 天际线问题;; 柱状图中最大的矩形;; More 高级算法
https://leetcode-cn.com/leetbook/detail/top-interview-questions-hard/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/leetcode/00.leetcode-medium/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/00.leetcode-medium/</guid>
      <description>数组和字符串 三数之和;; 矩阵置零;; 字母异位词分组;; 无重复字符的最长子串;; 最长回文子串;; 递增的三元子序列;; 链表 两数相加;;(middle) 奇偶链表;;(middle) 相交链表;;(easy) 树和图 二叉树的中序遍历;; 二叉树的锯齿形层次遍历;; 从前序与中序遍历序列构造二叉树;; 填充每个节点的下一个右侧节点指针;; 二叉搜索树中第K小的元素;; 岛屿数量;; 回溯算法 电话号码的字母组合;; 括号生成;; 全排列;; 子集;; 单词搜索;; 排序和搜索 颜色分类;; 前 K 个高频元素;; 数组中的第K个最大元素;; 寻找峰值;; 在排序数组中查找元素的第一个和最后一个位置;; 合并区间;; 搜索旋转排序数组;; 搜索二维矩阵 II;; 动态规划 跳跃游戏;; 不同路径;; 零钱兑换;; 最长递增子序列;; 设计问题 二叉树的序列化与反序列化;; 常数时间插入、删除和获取随机元素;; 数学 快乐数;; 阶乘后的零;; Excel表列序号;; Pow(x, n);; x 的平方根;; 两数相除;; 分数到小数;; 其他 两整数之和;; 逆波兰表达式求值;; 多数元素;; 任务调度器;; More 中级算法
https://leetcode-cn.com/leetbook/detail/top-interview-questions-medium/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/leetcode/000.byte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/000.byte/</guid>
      <description>字节跳动前端高频算法题榜（截止 2021 年 8 月） 题目 出现次数；
无重复字符的最长子串 18； &amp;ndash; 88. 合并两个有序数组 17； 求根到叶子节点数字之和 15； 路径总和 13； 最大子序和 12； &amp;ndash; 1. 两数之和 11； 比较版本号 11； 数组中的第K个最大元素 10； 长度最小的子数组 8； 剑指 Offer 22. 链表中倒数第k个节点 8； 字符串相加 8； 全排列 8； &amp;mdash; 206. 反转链表 7； &amp;ndash; 102. 二叉树的层序遍历 6； 爬楼梯 6； 螺旋矩阵 6； 复原IP地址 5； 岛屿数量 5； 二叉搜索树中第K小的元素 5； 三数之和 5； 环形链表 5； N叉树的层序遍历 5； 翻转二叉树 4； 买卖股票的最佳时机 4； 最长重复子数组 4； &amp;ndash; 160. 相交链表 4； 岛屿的最大面积 4； 不同路径 4； 剑指 Offer 62.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/leetcode/000.gaochang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/000.gaochang/</guid>
      <description>2.贪心 买卖股票的最佳时机II (easy) 分发糖果 (hard) 406.根据身高重建队列 (middle) 无重叠区间 (middle) 452.用最少数量的箭引爆气球 (middle) 分发饼干 (easy) 605.种花问题 (easy) 665.非递减数列 (easy) 划分字母区间 (middle) 3.双指针 076.最小覆盖子串 (hard) 合并两个有序数组 (easy) 环形链表II (middle) 两数之和II-输入有序数组 (easy) 340.至多包含K个不同字符的最长子串 (middle) 通过删除字母匹配到字典里最长单词 (middle) 平方数之和 (middle) 验证回文字符串II (easy) 4.二分查找 寻找两个正序数组的中位数 (hard) 在排序数组中查找元素的第一个和最后一个位置 (middle) x的平方根 (easy) 搜索旋转排序数组II (middle) 寻找旋转排序数组中的最小值II (hard) 有序数组中的单一元素 (middle) 5.排序 颜色分类 (middle) 数组中的第K个最大元素 (middle) 前K个高频元素 (middle) 根据字符出现频率排序 (middle) 6.搜索 695.岛屿的最大面积 (middle) 547.省份数量 (middle) 417.太平洋大西洋水流问题(middle) 046.全排列 (middle) 077.组合 (middle) 079.单词搜索 (middle) 051.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/leetcode/000.index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/000.index/</guid>
      <description>链表 合并两个有序链表； 删除排序链表中的重复元素； 排序链表； 相交链表； 移除链表元素； sword:
从尾到头打印链表； 链表中倒数第k个结点； 反转链表； 合并两个排序的链表； 两个链表的第一个公共结点； 链表中环的入口结点； 删除链表中重复的结点； 链表测试数据 function ListNode(val, next) { this.val = val === undefined ? 0 : val; this.next = next === undefined ? null : next; } var node1 = new ListNode(1); var node2 = new ListNode(2); var node3 = new ListNode(3); var node4 = new ListNode(4); var node5 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/leetcode/001.gaoping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/leetcode/001.gaoping/</guid>
      <description>LeetCode高频算法题
BFS index 公交路线;;广度优先搜索;33。0% (hard) 743/网络延迟时间;;堆深度优先搜索广度优先搜索图;43。7% (middle) 二叉树的层次遍历II;;树,广度优先搜索;61。3% 接雨水II;;堆广度优先搜索;30。6% (hard) 542/01矩阵;;深度优先搜索广度优先搜索;33。8% (middle) 访问所有节点的最短路径;;广度优先搜索动态规划;42。6% (hard) 490/迷宫;;深度优先搜索广度优先搜索;38。7% (middle) 对称二叉树;;树,深度优先搜索,广度优先搜索;47。2% (easy) 滑动谜题;;广度优先搜索;55。5% (hard) 二叉树的层次遍历;;树,广度优先搜索;57。1% (middle) 员工的重要性;;深度优先搜索广度优先搜索哈希表;52。2% (easy) 二叉树的右视图;;树,深度优先搜索,广度优先搜索;59。3% (middle) 删除无效的括号;;深度优先搜索广度优先搜索;40。6% (hard) 279/完全平方数;;广度优先搜索数学动态规划;60。2% (middle) 二分查找 index 004/寻找两个有序数组的中位数;;数组,二分查找,分治算法;35。3% 644/最大平均子段和II;;数组,二分查找;40。0% 349/两个教组的交集;;排序哈希表双指针,二分查找;64。1% 287/寻找重复数;;数组双指针,二分查找;59。7% 167/两数之和II-输入有序数组;;数组双指针,二分查找;49。1% 363/矩形区域不超过K的最大数值和;;队列,二分查找,动态规划;33。3% 718/最长重复子数组;;数组哈希表,二分查找,动态规划;44。8% 862/和至少为K的最短子数组;;队列,二分查找;10。3% 300/最长上升子序列;;二分查找,动态规划;42。3% 050/Pow(x, n);;数学,二分查找;32。8% 327/区间和的个数;;排序树状数组线段树,二分查找,分治算法;33。0% 029/两数相除;;数学,二分查找;18。5% 033/搜索旋转排序数组;;数组,二分查找;36。5% 174/地下城游戏;;二分查找,动态规划;36。4% 动态规划 index 005/最长回文子串;;字符串动态规划;25。7% 053/最大子序和;;数组分治算法动态规划;45。9% 085/最大矩形;;栈数组哈希表动态规划;44。4% 010/正则表达式匹配;;字符串动态规划回溯算法;23。4% 095/不同的二叉搜索树II;;树动态规划;57。0% 351/安卓系统手势解锁;;动态规划回溯算法;81。8% 072/编辑距离;;字符串动态规划;52。4% 096/不同的二叉搜索树;;树动态规划;60。9% 070/爬楼梯;;动态规划;45。9% 818/赛车;;堆动态规划;23。7% 312/戳气球;;分治算法动态规划;;54。0% 064/最小路径和;;数组动态规划;61。6; 121/买卖股票的最佳时机;;数组动态规划;50。2% 005/最长回文子串（middle）;; 010/正则表达式匹配 （hard）;; 053/最大子序和（easy）;; 064/最小路径和（middle）;; 070/爬楼梯 （easy）;; 072/编辑距离（hard）;; 085/最大矩形（hard）;; 095/不同的二叉搜索树II （middle）;; 096/不同的二叉搜索树 （middle）;; 121/买卖股票的最佳时机（easy）;; 312/戳气球 （hard）;; 351/安卓系统手势解锁（middle）;; 818/赛车（hard）;;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/redis/</guid>
      <description>Redis系列 |（一）六种基本数据结构 https://cloud.tencent.com/developer/article/1667574</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/sword2/00.index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/00.index/</guid>
      <description>- 03.数组中重复的数字, difficulty: 简单;; - 04.二维数组中的查找, difficulty: 中等;; - 05.替换空格, difficulty: 简单;; - 06.从尾到头打印链表, difficulty: 简单;; - 07.重建二叉树, difficulty: 中等;; - 09.用两个栈实现队列, difficulty: 简单;; - 10-I.斐波那契数列, difficulty: 简单;; - 10-II.青蛙跳台阶问题, difficulty: 简单;; - 11.旋转数组的最小数字, difficulty: 简单;; - 12.矩阵中的路径, difficulty: 中等;; - 13.机器人的运动范围, difficulty: 中等;; - 14-I.剪绳子, difficulty: 中等;; - 14-II.剪绳子II, difficulty: 中等;; - 15.二进制中1的个数, difficulty: 简单;; - 16.数值的整数次方, difficulty: 中等;; - 17.打印从1到最大的n位数, difficulty: 简单;; - 18.删除链表的节点, difficulty: 简单;; - 19.正则表达式匹配, difficulty: 困难;; - 20.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.pengjielee.cn/draft/sword2/01.31day/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pengjielee.cn/draft/sword2/01.31day/</guid>
      <description>第 1 天 栈与队列（简单）day 剑指Offer 09.用两个栈实现队列 tags:栈,设计,队列 difficulty:简单;;
剑指Offer 30.包含min函数的栈 tags:栈,设计 difficulty:简单;;
第 2 天 链表（简单）day 剑指Offer 06.从尾到头打印链表 tags:栈,递归,链表,双指针 difficulty:简单;;
剑指Offer 24.反转链表 tags:递归,链表 difficulty:简单;;
剑指Offer 35.复杂链表的复制 tags:哈希表,链表 difficulty:中等;;
第 3 天 字符串（简单）day 剑指Offer 05.替换空格 tags:字符串 difficulty:简单;;
剑指Offer 58-II.左旋转字符串 tags:数学,双指针,字符串 difficulty:简单;;
第 4 天 查找算法（简单）day 剑指Offer 03.数组中重复的数字 tags:数组,哈希表,排序 difficulty:简单;;
剑指Offer 53-I.在排序数组中查找数字 I tags:数组,二分查找 difficulty:简单;;
剑指Offer 53-II.0～n-1中缺失的数字 tags:位运算,数组,哈希表,数学,二分查找 difficulty:简单;;
第 5 天 查找算法（中等）day 剑指Offer 04.二维数组中的查找 tags:数组,二分查找,分治,矩阵 difficulty:中等;;
剑指Offer 11.旋转数组的最小数字 tags:数组,二分查找 difficulty:简单;;
剑指Offer 50.</description>
    </item>
    
  </channel>
</rss>
